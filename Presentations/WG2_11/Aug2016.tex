\documentclass{beamer}

\usepackage[english]{babel}

\usepackage[latin1]{inputenc}

\usepackage{times}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tikz}
\usepackage{comment}

\title[Drasil]{Drasil: From generating code to generating software}

\author{\underline{Jacques Carette}, Spencer Smith, Dan Szymczak and
Steven Palmer}

\institute[McMaster University]{McMaster University}

\date[Aug 2016]{WG 2.11, August 2016 Meeting}

\beamertemplatenavigationsymbolsempty 

\begin{document}

%I will present some ongoing work that seeks to generate all the artefacts
%involved in software (obviously code, but also specification documents, design
%documents, tests, user manual, Makefiles, etc). In the context of software
%which requires (re)certification, all of these artefacts are involved -- and
%they normally contain a huge amount of duplicate information. Our approach is
%to do very aggressive knowledge encapsulation, followed by relatively
%straightforward generation passes. For domains (such as scientific computation)
%where there is well-established theory, our preliminary experiments shows that
%this works quite well. Note that we do NOT expect this to work so well in
%domains without well-established theory.

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\includegraphics{generate_all_the_things.jpg}
\end{frame}

\begin{frame}
\includegraphics[width=\textwidth]{no_silver_bullet.jpg}
\end{frame}

\begin{frame}
\frametitle{Context}
{\Large software \onslide<2->{(re)}certification}
\vspace*{.2cm}
\begin{itemize}
\item<3->All software artefacts:
\begin{itemize}
\item \textcolor{blue}{requirements, software specification, software design, code, 
  tests, "theory manual", user manual}
\end{itemize}
\vspace*{.5cm}
\item<4->Massive amounts of \textcolor{red}{knowledge duplication}
\begin{itemize}
  \item $\Rightarrow$
       non-code artefacts do not get maintained well enough
          OR are felt to be an expensive nuisance
  \item duplication harms traceability
\end{itemize}
\end{itemize}
\vfill
\end{frame}

\begin{frame}
\frametitle{Literate Programming}
What can we learn from it?
\begin{enumerate}
\item<2-> Code in most languages is not well organized for 
  \textcolor{red}{human understanding}.
\item<3-> Code in some languages can not \textcolor{red}{efficiently} be broken 
down into very small pieces.
\item<4-> Chunk labels add convenient \textcolor{red}{traceability} information.
\end{enumerate}
\end{frame}

\begin{comment}
\begin{frame}
- Goals
  - no information duplication: 
    - bug in one place, bug everywhere!
    - huge up-front investment
    - doesn't work if you have no theory.

Good slides from Spencer
5: SWHT
6: theory -> software
8: some sample information
9: information example
12: basic information infrastructure
13: SRS
14-17: internal DSL example
18: module architecture example
20: approach

\end{frame}
\end{comment}

\end{document}
