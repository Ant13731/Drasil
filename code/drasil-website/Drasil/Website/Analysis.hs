module Drasil.Website.Analysis where

import Language.Drasil

--------------------
-- Analysis Section
--------------------

-- | Creates the Analysis of Drasil Section.
analysisSec :: FilePath -> FilePath -> FilePath -> [String] -> Section
analysisSec analysisPath typePath clsIPath pkgs = section drasilAnalysisTitle [mkParagraph analysisIntro] [dataTableSec analysisPath, tableOfGraphsSec typePath clsIPath pkgs] analysisSecRef

-- | Analysis section title.
drasilAnalysisTitle :: Sentence
drasilAnalysisTitle = S "Analysis of Drasil"

-- | Analysis section introduction. Also introduces the Data Table.
analysisIntro :: Sentence
analysisIntro = S "This section contains an graphs and tables that may be used to analyze the \
  \structure of the Drasil framework. Here, we will explore the relationship between data types, \
  \classes, and instances of those classes within Drasil."

dataTableSec :: FilePath -> Section
dataTableSec path = section dataTableTitle [mkParagraph $ dataTableDesc path] [] $ makeSecRef "DataTable" $ S "DataTable"

dataTableTitle :: Sentence
dataTableTitle = S "Intersections of Types and Classes"
  
dataTableDesc :: FilePath -> Sentence
dataTableDesc path = S "This" +:+ namedRef (dataTableHTMLRef path) (S "Data Table") +:+
  S "is generated by Drasil to keep track of all the different types, classes, and where they intersect through instances. \
  \The rows are organized in order of Drasil packages, then Drasil modules, and lastly by data type. \
  \The data types are further separated by their structure; those labelled \
  \Data Type are completely new types created and used in Drasil, while Newtype Types are \
  \type synonyms or wrappers of other types. All of the classes in Drasil are defined as \
  \column headers, starting from Haskell-native classes like Eq and going through every \
  \unique Drasil-defined class. A box marked with \
  \'YYYY' symbolizes the file location of where that particular data type is an instance of a particular class. \
  \There is also a" +:+ namedRef (dataTableCSVRef path) (S "downloadable version") +:+ S "of the Data Table available as a .csv file."

-- | Data table references.
dataTableHTMLRef, dataTableCSVRef :: FilePath -> Reference
dataTableHTMLRef path = Reference "dataTableHTML" (URI $ path ++ "DataTable/DataTable.html") (shortname' $ S "dataTableHTML")
dataTableCSVRef path = Reference "dataTableCSV" (URI $ path ++ "DataTable/DataTable.csv") (shortname' $ S "dataTableCSV")

tableOfGraphsSec :: FilePath -> FilePath -> [String] -> Section
tableOfGraphsSec typePath clsIPath pkgs = section tableOfGraphsTitle [mkParagraph tableOfTypeGraphsDesc, mkTypeGraphTable typePath pkgs, mkParagraph tableOfClassIGraphsDesc, mkClassInstTable clsIPath pkgs] [] $ makeSecRef "TypeAndClassGraphs" $ S "TypeAndClassGraphs"

tableOfGraphsTitle :: Sentence
tableOfGraphsTitle = S "Table of Graphs"

tableOfTypeGraphsDesc :: Sentence
tableOfTypeGraphsDesc = S "The following" +:+ namedRef tableTypeGraphRef (S "Table of Type Graphs") +:+ S "is another artifact generated by Drasil. \
  \These graphs explore the dependency of data types upon each other. For more convrnient viewing, the graphs have been generated using both the dot \
  \algorithm (left side) and the circo algorithm (right side). This includes record-defined types, newtype wrappers, \
  \and types constructed from a combination of other types. For these graphs, a node with a black outline signifies that the type is not defined in that package, \
  \but still used in the creation of other types (this includes Haskell-native types since we do not redefine those). A red outline signifies \
  \that the type was created using Haskell's 'type' syntax, while dark green means the type was made using 'newtype' syntax. Purple shows \
  \that the type uses constructor syntax. Lastly, cyan is used for types written with record syntax. The arrow starts from the base types at the tip and \
  \follows through so that dependent types are placed at the tail. Usually, this means that those types at the tail may contain the type at the tip of the arrow."

tableOfClassIGraphsDesc :: Sentence
tableOfClassIGraphsDesc = S "This" +:+ namedRef classIGraphRef (S "Table of Class Instance Graphs") +:+ S "is similar in nature to the table above, where \
  \the generated graphs are rendered using two different algorithms. These graphs aim to look at the structure of classes, data types, and the interactions \
  \between those two. Specifically, each arrow represents the given type as an instance of a given class. The tip of the arrow points to the class, and the \
  \tail specifies the type that is an instance of the tip's class. For clarity in analyzing the structure, classes defined in a package are coloured magenta, \
  \classes that are used but not defined in the package are rendered pink (includes Haskell-native classes), and types are rendered with a turquoise border."

mkTypeGraphTable :: FilePath -> [String] -> Contents
mkTypeGraphTable typePath pkgs = LlC $ llcc tableTypeGraphRef $ Table [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"] (graphTable "datatype" typePath pkgs) (S "Type Graphs") True

mkClassInstTable :: FilePath -> [String] -> Contents
mkClassInstTable clsInstPath pkgs = LlC $ llcc classIGraphRef $ Table [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"] (graphTable "classInst" clsInstPath pkgs) (S "Class Instance Graphs") True

tableTypeGraphRef, classIGraphRef :: Reference
tableTypeGraphRef = makeTabRef "TypeGraphs"
classIGraphRef = makeTabRef "ClassInstGraphs"

graphTable :: String -> FilePath -> [String] -> [[Sentence]]
graphTable knd path = map (graphTableEntry knd path)

classInstTable :: FilePath -> [String] -> [[Sentence]]
classInstTable clsInstPath pkgs = [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"]
    : map (graphTableEntry "classInst" clsInstPath) pkgs

graphTableEntry :: String -> FilePath -> String -> [Sentence]
graphTableEntry knd path pkg = [S pkg, namedRef (getDataTypeRef knd "" path pkg) (S "Dot Graph"), namedRef (getDataTypeRef knd "circo_" path pkg) (S "Circo Graph")]

getDataTypeRef :: String -> String -> FilePath -> String -> Reference
getDataTypeRef knd prfx path pkg = Reference (knd ++ pkg ++ prfx ++ "graph") (URI $ path ++ prfx ++ pkg ++ ".svg") $ shortname' $ S $ pkg ++ prfx ++ "graph"

-- | Analysis section reference
analysisSecRef :: Reference
analysisSecRef = makeSecRef "Analysis" $ S "Analysis"

-- | Gathers all references used in this file.
analysisRefs :: FilePath -> FilePath -> FilePath -> [String] -> [Reference]
analysisRefs analysisPath typePath clsIPath pkgs = [analysisSecRef, dataTableHTMLRef analysisPath,
  dataTableCSVRef analysisPath, ref $ analysisSec analysisPath typePath clsIPath pkgs]
  ++ map (getDataTypeRef "datatype" "" typePath) pkgs ++ map (getDataTypeRef "classInst" "" clsIPath) pkgs
  ++ map (getDataTypeRef "datatype" "circo_" typePath) pkgs ++ map (getDataTypeRef "classInst" "circo_" clsIPath) pkgs

