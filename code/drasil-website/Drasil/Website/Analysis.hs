module Drasil.Website.Analysis where

import Language.Drasil

--------------------
-- Analysis Section
--------------------

-- | Creates the Analysis of Drasil Section.
analysisSec :: FilePath -> FilePath -> FilePath -> FilePath -> [String] -> Section
analysisSec analysisPath typePath clsIPath graphPath pkgs = section drasilAnalysisTitle [mkParagraph analysisIntro] [dataTableSec analysisPath, tableOfGraphsSec typePath clsIPath pkgs, graphSec graphPath $ map ("drasil-" ++) pkgs] analysisSecRef

-- | Analysis section title.
drasilAnalysisTitle :: Sentence
drasilAnalysisTitle = S "Analysis of Drasil"

-- | Analysis section introduction. Also introduces the Data Table.
analysisIntro :: Sentence
analysisIntro = S "This section contains an graphs and tables that may be used to analyze the \
  \structure of the Drasil framework. Here, we will explore the relationship between data types, \
  \classes, and instances of those classes within Drasil."

dataTableSec :: FilePath -> Section
dataTableSec path = section dataTableTitle [mkParagraph $ dataTableDesc path] [] $ makeSecRef "DataTable" $ S "DataTable"

dataTableTitle :: Sentence
dataTableTitle = S "Intersections of Types and Classes"
  
dataTableDesc :: FilePath -> Sentence
dataTableDesc path = S "This" +:+ namedRef (dataTableHTMLRef path) (S "Data Table") +:+
  S "is generated by Drasil to keep track of all the different types, classes, and where they intersect through instances. \
  \The rows are organized in order of Drasil packages, then Drasil modules, and lastly by data type. \
  \The data types are further separated by their structure; those labelled \
  \Data Type are completely new types created and used in Drasil, while Newtype Types are \
  \type synonyms or wrappers of other types. All of the classes in Drasil are defined as \
  \column headers, starting from Haskell-native classes like Eq and going through every \
  \unique Drasil-defined class. A box marked with \
  \'YYYY' symbolizes the file location of where that particular data type is an instance of a particular class. \
  \There is also a" +:+ namedRef (dataTableCSVRef path) (S "downloadable version") +:+ S "of the Data Table available as a .csv file."

-- | Data table references.
dataTableHTMLRef, dataTableCSVRef :: FilePath -> Reference
dataTableHTMLRef path = Reference "dataTableHTML" (URI $ path ++ "DataTable/DataTable.html") (shortname' $ S "dataTableHTML")
dataTableCSVRef path = Reference "dataTableCSV" (URI $ path ++ "DataTable/DataTable.csv") (shortname' $ S "dataTableCSV")

tableOfGraphsSec :: FilePath -> FilePath -> [String] -> Section
tableOfGraphsSec typePath clsIPath pkgs = section tableOfGraphsTitle [mkParagraph tableOfTypeGraphsDesc, mkTypeGraphTable typePath pkgs, mkParagraph tableOfClassIGraphsDesc, mkClassInstTable clsIPath pkgs] [] $ makeSecRef "TypeAndClassGraphs" $ S "TypeAndClassGraphs"

tableOfGraphsTitle :: Sentence
tableOfGraphsTitle = S "Table of Graphs"

tableOfTypeGraphsDesc :: Sentence
tableOfTypeGraphsDesc = S "The following" +:+ namedRef tableTypeGraphRef (S "Table of Type Graphs") +:+ S "is another artifact generated by Drasil. \
  \These graphs explore the dependency of data types upon each other. For more convrnient viewing, the graphs have been generated using both the dot \
  \algorithm (left side) and the circo algorithm (right side). This includes record-defined types, newtype wrappers, \
  \and types constructed from a combination of other types. For these graphs, a node with a black outline signifies that the type is not defined in that package, \
  \but still used in the creation of other types (this includes Haskell-native types since we do not redefine those). A red outline signifies \
  \that the type was created using Haskell's 'type' syntax, while dark green means the type was made using 'newtype' syntax. Purple shows \
  \that the type uses constructor syntax. Lastly, cyan is used for types written with record syntax. The arrow starts from the base types at the tip and \
  \follows through so that dependent types are placed at the tail. Usually, this means that those types at the tail may contain the type at the tip of the arrow."

tableOfClassIGraphsDesc :: Sentence
tableOfClassIGraphsDesc = S "This" +:+ namedRef classIGraphRef (S "Table of Class Instance Graphs") +:+ S "is similar in nature to the table above, where \
  \the generated graphs are rendered using two different algorithms. These graphs aim to look at the structure of classes, data types, and the interactions \
  \between those two. Specifically, each arrow represents the given type as an instance of a given class. The tip of the arrow points to the class, and the \
  \tail specifies the type that is an instance of the tip's class. For clarity in analyzing the structure, classes defined in a package are coloured magenta, \
  \classes that are used but not defined in the package are rendered pink (includes Haskell-native classes), and types are rendered with a turquoise border."

mkTypeGraphTable :: FilePath -> [String] -> Contents
mkTypeGraphTable typePath pkgs = LlC $ llcc tableTypeGraphRef $ Table [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"] (graphTable "datatype" typePath pkgs) (S "Type Graphs") True

mkClassInstTable :: FilePath -> [String] -> Contents
mkClassInstTable clsInstPath pkgs = LlC $ llcc classIGraphRef $ Table [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"] (graphTable "classInst" clsInstPath pkgs) (S "Class Instance Graphs") True

tableTypeGraphRef, classIGraphRef :: Reference
tableTypeGraphRef = makeTabRef "TypeGraphs"
classIGraphRef = makeTabRef "ClassInstGraphs"

graphTable :: String -> FilePath -> [String] -> [[Sentence]]
graphTable knd path = map (graphTableEntry knd path)

classInstTable :: FilePath -> [String] -> [[Sentence]]
classInstTable clsInstPath pkgs = [S "Drasil Package", S "Generated using Dot algorithm", S "Generated using Circo algorithm"]
    : map (graphTableEntry "classInst" clsInstPath) pkgs

graphTableEntry :: String -> FilePath -> String -> [Sentence]
graphTableEntry knd path pkg = [S pkg, namedRef (getDataTypeRef knd "" path pkg) (S "Dot Graph"), namedRef (getDataTypeRef knd "circo_" path pkg) (S "Circo Graph")]

getDataTypeRef :: String -> String -> FilePath -> String -> Reference
getDataTypeRef knd prfx path pkg = Reference (knd ++ pkg ++ prfx ++ "graph") (URI $ path ++ prfx ++ pkg ++ ".svg") $ shortname' $ S $ pkg ++ prfx ++ "graph"

-- | Analysis section reference
analysisSecRef :: Reference
analysisSecRef = makeSecRef "Analysis" $ S "Analysis"

-- | Gathers all references used in this file.
analysisRefs :: FilePath -> FilePath -> FilePath -> FilePath -> [String] -> [Reference]
analysisRefs analysisPath typePath clsIPath graphPath pkgs = [analysisSecRef, dataTableHTMLRef analysisPath,
  dataTableCSVRef analysisPath, ref $ analysisSec analysisPath typePath clsIPath graphPath pkgs]
  ++ map (getDataTypeRef "datatype" "" typePath) pkgs ++ map (getDataTypeRef "classInst" "" clsIPath) pkgs
  ++ map (getDataTypeRef "datatype" "circo_" typePath) pkgs ++ map (getDataTypeRef "classInst" "circo_" clsIPath) pkgs
  ++ graphRefs graphPath (map ("drasil-" ++) pkgs)

----------------------------------
-- Dependency Graphs Section
----------------------------------

-- | Creates the Package Dependency Graphs section
graphSec :: FilePath -> [String] -> Section
graphSec path pkgs = section packDepGraphTitle 
  (mkParagraph (S graphSecIntro) : displayGraphs ++ listOfLinkedGraphs) [] graphSecRef
  where
    -- may want to display more graphs later, but for now qw only display the "drasil-website"
    -- package dependencies. If you change this, you should also change the introduction.
    displayGraphs = map (dependencyGraphs path) ["drasil-website"]
    -- these graphs are listed at the bottom of the Drasil website. They are links to the
    -- pdf versions of the package dependency graphs.
    listOfLinkedGraphs = [UlC $ ulcc $ folderList path pkgs]

-- | Package Dependency Graphs section title.
packDepGraphTitle :: Sentence
packDepGraphTitle = S "Package Dependency Graphs"

-- | Introduces what the package dependency graphs are.
graphSecIntro :: String
graphSecIntro = "The below list contains all of the different packages used to build the Drasil Framework. \
  \Each package and its dependencies are displayed in the form of a graph, with the tail of the arrow being the dependent module, \
  \and the tip of the arrow being the base module. In other words, the tip builds off of (or relies on) the tail to work. \
  \Links are available to a pdf version of each package's dependency graph at the bottom. For example, the graph for the website package \
  \is shown below. Each section is made from different modules that come together under the Drasil.Website.Body module and then \
  \are generated by Drasil.Website.Main. This result shows that the package structure has a pyramid-like hierarchy."

-- | Function to create displayable versions of the graphs.
dependencyGraphs :: FilePath -> String -> Contents
dependencyGraphs path pkg = LlC $ llcc (makeFigRef $ "Figure" ++ pkg) $ fig (S $ "Package: " ++ pkg) $ drasilDisplayDepGraphPath path pkg

-- | Function to get the paths of graphs we want to display on the website.
drasilDisplayDepGraphPath :: FilePath -> FilePath -> String
drasilDisplayDepGraphPath path fldr = path ++ fldr ++ ".png" -- for some reason, svg doesn't show up on generated website, so use png for now

-- | Gets all the paths to the pdf graphs from a given list of packages.
drasilDepGraphPathsPDF :: FilePath -> [String] -> [String]
drasilDepGraphPathsPDF path = map (\x -> path ++ x ++ ".pdf")

-- | Create References to display as links for the dependency graph pdfs.
drasilDepGraphRefs :: FilePath -> [String] -> [Reference]
drasilDepGraphRefs path pkgs = zipWith (\x y -> Reference x (URI y) $ shortname' $ S x) pkgs $ drasilDepGraphPathsPDF path pkgs

-- | Create the list of folders with the links to dependency graph pdfs.
folderList :: FilePath -> [String] -> RawContent
folderList path pkgs = Enumeration $ Bullet $ zip (folderListItems path pkgs) $ repeat Nothing

-- | Helper to create the list items for dependency graph pdfs.
folderListItems :: FilePath -> [String] -> [ItemType]
folderListItems path pkgs = map Flat $ zipWith namedRef (drasilDepGraphRefs path pkgs) $ map S pkgs

-- | Create section reference for Package Dependency Graphs.
graphSecRef :: Reference
graphSecRef = makeSecRef "DependencyGraphs" $ S "Dependency Graphs"

-- | All references used in this section.
graphRefs :: FilePath -> [String] -> [Reference]
graphRefs path pkgs = [graphSecRef, ref $ graphSec path pkgs] ++ drasilDepGraphRefs path pkgs

