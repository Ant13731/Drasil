%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[10pt, preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{SPLASH '15}{Oct 25--30, 2015, Pittsburgh, Pennsylvania, USA} 
\copyrightyear{2015} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} %D What goes here?
\doi{nnnnnnn.nnnnnnn} 								 %D and here?

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{DRAFT -- DO NOT DISTRIBUTE}        % These are ignored unless
\preprintfooter{A literate program family approach to scientific software}   % 'preprint' option specified.

\title{Learning to Cook 'ware}
\subtitle{A Family Approach} %D Something about prog families?

\authorinfo{Daniel Szymczak}
           {McMaster University}
           {szymczdm@mcmaster.ca}
\authorinfo{Spencer Smith\and Jacques Carette}
           {McMaster University}
           {smiths at mcmaster.ca/carette at mcmaster.ca}

\maketitle

\begin{abstract}
This is where we will put the abstract of our paper. It will be super-fantastic and make all the reviewers think that this should not only be accepted, but most definitely published. %D Going to need to work on this
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2 %D What goes here?

\keywords
Program families, generative programming, documentation, scientific computing, literate programming %D Should anything else go here?

\section{Introduction} 

	Scientific computing (SC) was the first application of computers. It is still used today for a wide variety of tasks: constructing mathematical models, performing quantitative analyses, creating simulations, solving scientific problems, etc. SC software has been developed for increasingly safety and security critical systems (nuclear reactor simulation, satellite guidance%D MORE EXAMPLES)
) as well as predictive systems. %D Change the next bit about applications, pick better examples that fit with the theme: nuclear / avionics / automotive
It has applications including (but not limited to) predicting weather patterns and natural disasters, and simulating economic fluctuations. As such, it is an incredibly important part of an increasing number of industries today.%D and can be seen as a third mode of science which complements experimentation and theory.

%D Removed something about earthquake prediction as an example.
In the medical, nuclear power, aerospace, automotive, and manufacturing fields there are many safety critical systems in play. With each system, there is the possibility of a catastrophic failure endangering lives. It is incredibly important then to have some means of certifying and assuring the quality of each software system. As Smith et al. \cite{SmithKoothoorAndNedialkov2014} stated ``Certification of Scientiﬁc Computing (SC) software is official recognition by an authority or regulatory body that the software is ﬁt for its intended use.'' These regulatory bodies determine certain certification standards that must be met in order for a system to become recognized as certified. One example of a certification standard is the Canadian Standards Association (CSA) requirements for quality assurance of scientific software for nuclear power plants. 

The main goal of software certification is to ``... systematically determine, based on the principles of science, engineering, and measurement theory, whether a software product satisfies accepted, well-defined and measurable criteria'' \cite{HHLMWW}. As such, certification would not only involve analyzing the code systematically and rigorously, but also analyzing the documentation. Essentially, this means the software must be both valid and verifiable, reliable, usable, maintainable, reusable, understandable, and reproducible. %D Verification involves ensuring that the software is ``solving the equations right'', whereas validation requires ensuring that the software is ``solving the right equations''\cite{Roache1998}.

Developing certifiable software can end up being a much more involved process than developing uncertified software: it takes more money, time, and effort on the part of developers to produce. These increased costs lead to reluctance from practitioners to develop certifiable software \cite{Roache1998}. However, in our %D my?
opinion, cost is not the only contributing factor for the developers. As it stands in the field, scientists seem to prefer a more agile development process \cite{Segal2008}. Typically this would lead to problems maintaining the documentation, meaning that not all aspects of the software would be traceable through the design process and making certification more difficult (if not impossible).

Given proper methods and tools, scientists would be able to follow a more structured approach (while capitalizing on frequent feedback and course correction) to meet documentation requirements for certification as well as improve their overall productivity. This is where our work comes in: our goal is to eat our cake and have it too.  We want to improve the qualities (verifiability, reliability, understandability etc.) and at the same time improve performance.  Moreover, we want to improve developer productivity; save time and money on SC software development, certification and re-certification. To accomplish this we need to do the following:

\begin{enumerate}
	\item Remove duplication between software artifacts for scientific computing software \cite{WilsonEtAl2013}
	\item Provide complete traceability between all artifacts
\end{enumerate}


To achieve the above goals, we propose the following:

\begin{enumerate}
	\item Provide methods, tools and techniques to support developing scientific software using a literate process
	\item Use ideas from software product lines, or program families
	\item Use code generation
\end{enumerate}

Section \ref{sec:background} will give a more in-depth look at SC software, specifically focusing on SC software quality (including historical attempts to improve quality), the program family approach, and literate programming. Section \ref{sec:what} focuses on what a literate family approach can achieve, specifically related to software certification; domain knowledge capture; simplification, reusability, and portability; optimization; verification; and how it can incorporate non-functional requirements as well as functional. Finally, section \ref{sec:concluding} will provide a few concluding remarks.

\section{Background}
\label{sec:background}

Throughout the history of computing, specifically scientific computing, there have been many challenges towards assuring the quality of software. Many attempts have been made (some successful, others not) at improving the software quality. In this section we will discuss those attempts and challenges, as well as introduce the ideas behind our proposed approach.

\subsection{Challenges for SC Software Quality}
\label{subsec:challenges}

SC software has certain characteristics which create challenges for its development. We will not discuss them all in depth, however, those of interest to us are the approximation, unknown solution, technique, input output, and modification challenges as described by Yu \cite{Yu2011}.

The \textit{approximation challenge} is a challenge to SC software's reliability. Since real numbers are approximated by floating point numbers on computers, round off and truncation errors can be introduced to a SC software system during computation steps. While any single step may introduce a very small error, they can compound quickly and become unmanageable. 

The \textit{unknown solution challenge} is another challenge to SC software's reliability. This challenge arises when SC programs are used to solve problems with unknown true solutions, i.e. there are very limited test cases with known solutions. As such, the accuracy and precision of the software can be hard (if not impossible) to judge.

The \textit{technique selection challenge} is a challenge that comes up often when dealing with continuous mathematical equations. Since these cannot be solved directly (due to computers being discrete), some technique must be chosen which can produce a solution which is ``good enough'' for the user. Choosing the technique to use is typically left to domain experts as each technique will (not) satisfy certain non-functional requirements.

The \textit{input output} challenge impacts the usability of SC software and typically comes up where considerable amounts of input data are used in the production of large volumes of output. The main issue in this case is the complicated nature of the input data and the output, leading developers to recreate existing library routines (slightly modified) in order to deal with the nature of the input and output.

Finally, the \textit{modification challenge} tends to come up as requirements change. As SC software is used at the forefront of scientific knowledge, there can be a high frequency of requirements changes. As changing requirements can mean completely modified systems, it poses a problem for scientists: commercial software can be difficult/expensive to modify and noncommercial programs are not often flexible enough to change.

\subsection{History of Attempts to Improve Quality}
\label{subsec:history}

SC software has not seen many focused attempts at improving software quality. Most attempts at improving software quality have been aimed at a broader target than SC specifically. However, many of the methods used have been useful to SC software. Yu \cite{Yu2011} addresses the issue in-depth, but we will give a brief overview.

The object-orientation (OO) approach aims to increase software quality through the use of several mechanisms. \textit{Encapsulation} ensures information hiding \cite{Parnas1972} by keeping information hidden from the classes that do not require it. \textit{Inheritance} is useful in the OO approach, but not necessarily when applied to SC as many SC problems do not deal with a hierarchical structure. \textit{Polymorphism} can improve reusability by, for example, allowing algorithms to be bound at runtime (though the use of abstract classes). However, for SC software, the algorithm being solved is typically known ahead of time and thus a general program using different algorithms is not necessarily useful. 

Agile methods, on the other hand, are one of the most prevalent approaches used by software engineers. It is useful in the context of SC software as it allows for flexibility in dealing with unpredictably changing requirements, on the flip side, if the requirements are fairly stable there is no real benefit to using agile methods.

A program family approach is meant to improve reusability. As the program family is reused and retested, it is likely that any defects will be discovered, thus improving reliability. Developing a program family is a general, plan-driven approach. Where agile methods dealt with unpredictably changing requirements, the program family approach is tailored toward projects with stable or predictably changing requirements. The program family is designed to solve a small set of problems, and we will discuss it in more depth in Section \ref{subsec:program}. %D Mention maintainability in sebsec:program.

- several techniques
	- libraries
	- component-based development
	- aspect-oriented programming
	- generic programming
	- generative programming
	- problem solving environment
	- design patterns


\subsection{Program Family Approach}
\label{subsec:program}

- define the program family approach
- SC software satisfies the 3 hypotheses from Weiss: redevelopment hypothesis, oracle hypothesis and organizational hypothesis
- many examples where reuse has not been achieved

\subsection{Literate Programming}
\label{subsec:literate}

- overview of LP, starting with Knuth - a similar background to what we need here is given in SmithKoothoorAndNedialkov.pdf

\section{What is Possible with a Literate Family Approach}
\label{sec:what}

- this is the discussion section - give advantages and then use examples to illustrate

\subsection{Software Certification}
\label{subsec:software}

- need to generate required documentation, without impeding the work of the scientists
- need to be able to make changes at reasonable cost - this requires traceability

Start with a default set of documentation, as follows
	- Problem Statement
	- Development Plan
	- Requirements Specification
	- Verification and Validation plan
	- Design Specification
	- Code
	- Verification and Validation Report
	- User Manual
(A start to an explanation about these documents is in ZhengEtAl2015SS, since the document is not complete, I will not check it into the repository, but e-mail it to you.)

\subsection{Knowledge Capture}
\label{subsec:knowledge}

- conservation of thermal energy equation - used for thermal analysis of fuel pins and then reused for solar water heating tank
- maybe hg/hc example?
- Build a library of artifacts that can be reused in many different contexts
- example of “Commonality Analysis for a Family of Material Models” (SmithMcCutchanAndCarette2014 - not yet published - in mmsc repos) - the section on the purpose of the document (Section 1.1) discusses how the documentation combines various sources and uses a consistent notation and terminology

\subsection{``Everything should be made as simple as possible, but not simpler.'' (Einstein quote)}
\label{subsec:everything}

- although powerful/general commercial finite element programs are available, they are often not used to develop new “widgets”
- reasons are cost, and complexity
- rather than use simulation, engineers often resort to building prototypes and testing
- engineers would greatly benefit from tools to assist their design efforts that are customized to their exact set of problems - with a literate family approach family members can be generated to fit their needs
- if an engineer designs parts for strength, they could have a general stress analysis program - the program could be 3D if needed, or specialized for plane stress or plane strain, if that was the appropriate assumption - the program could even be customized to the parameterized shape of the part they are interested in, with only the degrees of freedom, like material properties, or the specific dimensions, they can change being exposed.

\subsection{Optimization}
\label{subsec:optimization}

- Connect optimization with analysis.  Optimization requires running multiple analysis cases.  Code generation can be used to build an efficient model that has just what is needed, and no more.  As the optimization searches the design space, new models can be generated.
- An optimization problem for a part where the shape and constitutive equation are degrees of freedom, cite family of material models (SmithMcCutchanAndCarette2014)

\subsection{Verification}
\label{subsec:verification}

- requirements include so-called “sanity” checks that can be reused when they come up in subsequent phases
- for instance, requirement would state conservation of mass, or the fact that lengths are always positive - the first used to test output, the second to guard against invalid input

- computational variability testing, from Yu (2011), FEM example
- usual to do grid refinement tests - same order of interpolation, but more points
- code generation allows for increases in the order of interpolation, for the same grid
- Yu discusses in section 6.3 of her thesis

\subsection{Incorporating Non-Functional Requirements in a decision support system for selecting the best design options}
\label{subsec:incorporating}

Use AHP. - see Smith2006.pdf

\section{Concluding Remarks}
\label{sec:concluding}

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright
%D Need to fix bibliography so it's all in one place since it should be embedded.

%@article{SmithKoothoorAndNedialkov2014,
%	Author = {Spencer Smith and Nirmitha Koothoor and Ned Nedialkov},
%	Date-Added = {2014-10-03 23:52:21 +0000},
%	Date-Modified = {2014-10-03 23:52:21 +0000},
%	Journal = {IEEE Transactions on Software Engineering},
%	Title = {A Document Driven Method for Facilitating Certification of Scientific Computing Software},
%	Year = {Submitted 2014},
%	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHVNtaXRoS29vdGhvb3JBbmROZWRpYWxrb3YucGRm0hcLGBlXTlMuZGF0YU8RAgYAAAAAAgYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM6Xc4NIKwAAA3DDZB1TbWl0aEtvb3Rob29yQW5kTmVkaWFsa292LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADcMOO0EreAAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAXU2NpQ29tcEFuZFNvZnRFbmdQYXBlcnMAABAACAAAzperwwAAABEACAAA0EsWQAAAAAEAFANww2QCkcRMABIVpwAI92YAAmSOAAIAX01hY2ludG9zaCBIRDpVc2VyczoAc21pdGhzOgBSZXBvczoAbW1zYzoAU2NpQ29tcEFuZFNvZnRFbmdQYXBlcnM6AFNtaXRoS29vdGhvb3JBbmROZWRpYWxrb3YucGRmAAAOADwAHQBTAG0AaQB0AGgASwBvAG8AdABoAG8AbwByAEEAbgBkAE4AZQBkAGkAYQBsAGsAbwB2AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBNVXNlcnMvc21pdGhzL1JlcG9zL21tc2MvU2NpQ29tcEFuZFNvZnRFbmdQYXBlcnMvU21pdGhLb290aG9vckFuZE5lZGlhbGtvdi5wZGYAABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArgCzALsCxQLHAswC1wLgAu4C8gL5AwIDBwMUAxcDKQMsAzEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==}}

%@book{Roache1998,
%	Address = {Albuquerque, New Mexico},
%	Author = {Patrick J. Roache},
%	Date-Added = {2015-03-19 19:26:55 +0000},
%	Date-Modified = {2015-03-19 19:26:55 +0000},
%	Publisher = {Hermosa Publishers},
%	Title = {Verification and Validation in Computational Science and Engineering},
%	Year = {1998}}

%@inproceedings{Segal2008,
%	Address = {Leipzig, Germany},
%	Author = {Judith Segal},
%	Booktitle = {Proceedings of the First International Workshop on Software Engineering for Computational Science and Engineering (SECSE 2008)},
%	Date-Added = {2015-03-19 19:24:05 +0000},
%	Date-Modified = {2015-03-19 19:24:05 +0000},
%	Organization = {In conjunction with the 30th International Conference on Software Engineering (ICSE)},
%	Pages = {1--6},
%	Title = {Models of Scientific Software Development},
%	Url = {http://www.cse.msstate.edu/~SECSE08/schedule.htm},
%	Year = {2008},
%	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLy4uLy4uLy4uL1dvcmsvUmVzZWFyY2gvUmVmZXJlbmNlcy9TZWdhbDIwMDgucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM6Xc4NIKwAAABcCDA1TZWdhbDIwMDgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuN1l0KzCSAAAAAAAAAAAAAMABAAACSAAAAAAAAAAAAAAAAAAAAAKUmVmZXJlbmNlcwAQAAgAAM6Xq8MAAAARAAgAANCtCJgAAAABABQAFwIMABcATQAW/e0ACPdmAAJkjgACAEVNYWNpbnRvc2ggSEQ6VXNlcnM6AHNtaXRoczoAV29yazoAUmVzZWFyY2g6AFJlZmVyZW5jZXM6AFNlZ2FsMjAwOC5wZGYAAA4AHAANAFMAZQBnAGEAbAAyADAAMAA4AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAzVXNlcnMvc21pdGhzL1dvcmsvUmVzZWFyY2gvUmVmZXJlbmNlcy9TZWdhbDIwMDgucGRmAAATAAEvAAAVAAIADf//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAMAAxQDNAnUCdwJ8AocCkAKeAqICqQKyArcCxALHAtkC3ALhAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuM=},
%	Bdsk-Url-1 = {http://secse08.cs.ua.edu/schedule.htm}}

%@article{WilsonEtAl2013,
%	Author = {Greg Wilson and D.A. Aruliah and C. Titus Brown and Neil P. Chue Hong and Matt Davis and Richard T. Guy and Steven H.D. Haddock and Kathryn D. Huff and Ian M. Mitchell and Mark D. Plumblet and Ben Waugh and Ethan P. White and Paul Wilson},
%	Bibsource = {DBLP, http://dblp.uni-trier.de},
%	Date-Added = {2015-03-19 19:44:59 +0000},
%	Date-Modified = {2015-03-19 19:44:59 +0000},
%	Ee = {http://arxiv.org/abs/1210.0530},
%	Journal = {CoRR},
%	Title = {Best Practices for Scientific Computing},
%	Volume = {abs/1210.0530},
%	Year = {2013},
%	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QNC4uLy4uLy4uL1dvcmsvUmVzZWFyY2gvUmVmZXJlbmNlcy9XaWxzb25FdEFsMjAxMy5wZGbSFwsYGVdOUy5kYXRhTxEBtgAAAAABtgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzpdzg0grAAAAFwIMEldpbHNvbkV0QWwyMDEzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALYZiPQPnKfAAAAAAAAAAAAAwAEAAAJIAAAAAAAAAAAAAAAAAAAAApSZWZlcmVuY2VzABAACAAAzperwwAAABEACAAA0D6q3wAAAAEAFAAXAgwAFwBNABb97QAI92YAAmSOAAIASk1hY2ludG9zaCBIRDpVc2VyczoAc21pdGhzOgBXb3JrOgBSZXNlYXJjaDoAUmVmZXJlbmNlczoAV2lsc29uRXRBbDIwMTMucGRmAA4AJgASAFcAaQBsAHMAbwBuAEUAdABBAGwAMgAwADEAMwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOFVzZXJzL3NtaXRocy9Xb3JrL1Jlc2VhcmNoL1JlZmVyZW5jZXMvV2lsc29uRXRBbDIwMTMucGRmABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AxQDKANICjAKOApMCngKnArUCuQLAAskCzgLbAt4C8ALzAvgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC+g==}}

%@phdthesis{Yu2011,
%	Address = {Hamilton, ON, Canada},
%	Author = {Wen Yu},
%	Date-Added = {2015-03-27 15:01:41 +0000},
%	Date-Modified = {2015-03-27 15:01:41 +0000},
%	School = {McMaster University},
%	Title = {{FASCS}: A Family Approach for Developing Scientific Computing Software},
%	Year = {2011},
%	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YVpZdTIwMTEucGRm0hcLGBlXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM6Xc4NIKwAAA3DDZApZdTIwMTEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE+7xt0TGXAgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAXU2NpQ29tcEFuZFNvZnRFbmdQYXBlcnMAABAACAAAzperwwAAABEACAAA0THPQgAAAAEAFANww2QCkcRMABIVpwAI92YAAmSOAAIATE1hY2ludG9zaCBIRDpVc2VyczoAc21pdGhzOgBSZXBvczoAbW1zYzoAU2NpQ29tcEFuZFNvZnRFbmdQYXBlcnM6AFl1MjAxMS5wZGYADgAWAAoAWQB1ADIAMAAxADEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADpVc2Vycy9zbWl0aHMvUmVwb3MvbW1zYy9TY2lDb21wQW5kU29mdEVuZ1BhcGVycy9ZdTIwMTEucGRmABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AmQCeAKYCYgJkAmkCdAJ9AosCjwKWAp8CpAKxArQCxgLJAs4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC0A==}}


\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

