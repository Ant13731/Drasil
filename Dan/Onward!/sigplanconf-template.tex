%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[10pt, preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{SPLASH '15}{Oct 25--30, 2015, Pittsburgh, Pennsylvania, USA} 
\copyrightyear{2015} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} %D What goes here?
\doi{nnnnnnn.nnnnnnn} 								 %D and here?

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{DRAFT -- DO NOT DISTRIBUTE}        % These are ignored unless
\preprintfooter{A literate program family approach to scientific software}   % 'preprint' option specified.

\title{Learning to Cook 'ware}
\subtitle{A Family Approach} %D Something about prog families?

\authorinfo{Daniel Szymczak}
           {McMaster University}
           {szymczdm@mcmaster.ca}
\authorinfo{Spencer Smith\and Jacques Carette}
           {McMaster University}
           {smiths at mcmaster.ca/carette at mcmaster.ca}

\maketitle

\begin{abstract}
This is where we will put the abstract of our paper. It will be super-fantastic and make all the reviewers think that this should not only be accepted, but most definitely published. %D Going to need to work on this
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2 %D What goes here?

\keywords
Program families, generative programming, documentation, scientific computing, literate programming %D Should anything else go here?

\section{Introduction} 

	Scientific computing (SC) was the first application of computers. It is still used today for a wide variety of tasks: constructing mathematical models, performing quantitative analyses, creating simulations, solving scientific problems, etc. SC software has been developed for increasingly safety and security critical systems (nuclear reactor simulation, satellite guidance%D MORE EXAMPLES)
) as well as predictive systems. %D Change the next bit about applications, pick better examples that fit with the theme: nuclear / avionics / automotive
It has applications including (but not limited to) predicting weather patterns and natural disasters, and simulating economic fluctuations. As such, it is an incredibly important part of an increasing number of industries today.%D and can be seen as a third mode of science which complements experimentation and theory.

%D Removed something about earthquake prediction as an example.
In the medical, nuclear power, aerospace, automotive, and manufacturing fields there are many safety critical systems in play. With each system, there is the possibility of a catastrophic failure endangering lives. It is incredibly important then to have some means of certifying and assuring the quality of each software system. As Smith et al. \cite{SmithKoothoorAndNedialkov2014} stated ``Certification of Scientiﬁc Computing (SC) software is official recognition by an authority or regulatory body that the software is ﬁt for its intended use.'' These regulatory bodies determine certain certification standards that must be met in order for a system to become recognized as certified. One example of a certification standard is the Canadian Standards Association (CSA) requirements for quality assurance of scientific software for nuclear power plants. 

The main goal of software certification is to ``... systematically determine, based on the principles of science, engineering, and measurement theory, whether a software product satisfies accepted, well-defined and measurable criteria'' \cite{HHLMWW}. As such, certification would not only involve analyzing the code systematically and rigorously, but also analyzing the documentation. Essentially, this means the software must be both valid and verifiable, reliable, usable, maintainable, reusable, understandable, and reproducible. %D Verification involves ensuring that the software is ``solving the equations right'', whereas validation requires ensuring that the software is ``solving the right equations''\cite{Roache1998}.

Developing certifiable software can end up being a much more involved process than developing uncertified software: it takes more money, time, and effort on the part of developers to produce. These increased costs lead to reluctance from practitioners to develop certifiable software \cite{Roache1998}. However, in our %D my?
opinion, cost is not the only contributing factor for the developers. As it stands in the field, scientists seem to prefer a more agile development process \cite{Segal2008}. Typically this would lead to problems maintaining the documentation, meaning that not all aspects of the software would be traceable through the design process and making certification more difficult (if not impossible).

Given proper methods and tools, scientists would be able to follow a more structured approach (while capitalizing on frequent feedback and course correction) to meet documentation requirements for certification as well as improve their overall productivity. This is where our work comes in: our goal is to eat our cake and have it too.  We want to improve the qualities (verifiability, reliability, understandability etc.) and at the same time improve performance.  Moreover, we want to improve developer productivity; save time and money on SC software development, certification and re-certification. To accomplish this we need to do the following:

\begin{enumerate}
	\item Remove duplication between software artifacts for scientific computing software \cite{WilsonEtAl2013}
	\item Provide complete traceability between all artifacts
\end{enumerate}


To achieve the above goals, we propose the following:

\begin{enumerate}
	\item Provide methods, tools and techniques to support developing scientific software using a literate process
	\item Use ideas from software product lines, or program families
	\item Use code generation
\end{enumerate}

Section \ref{sec:background} will give a more in-depth look at SC software, specifically focusing on SC software quality (including historical attempts to improve quality), the program family approach, and literate programming. Section \ref{sec:what} focuses on what a literate family approach can achieve, specifically related to software certification; domain knowledge capture; simplification, reusability, and portability; optimization; verification; and how it can incorporate non-functional requirements as well as functional. Finally, section \ref{sec:concluding} will provide a few concluding remarks.

\section{Background}
\label{sec:background}

Throughout the history of computing, specifically scientific computing, there have been many challenges towards assuring the quality of software. Many attempts have been made (some successful, others not) at improving the software quality. In this section we will discuss those attempts and challenges, as well as introduce the ideas behind our proposed approach.

\subsection{Challenges for SC Software Quality}
\label{subsec:challenges}

SC software has certain characteristics which create challenges for its development. We will not discuss them all in depth, however, those of interest to us are the approximation, unknown solution, technique, input output, and modification challenges as described by Yu \cite{Yu2011}.

The \textit{approximation challenge} is a challenge to SC software's reliability. Since real numbers are approximated by floating point numbers on computers, round off and truncation errors can be introduced to a SC software system during computation steps. While any single step may introduce a very small error, they can compound quickly and become unmanageable. 

The \textit{unknown solution challenge} is another challenge to SC software's reliability. This challenge arises when SC programs are used to solve problems with unknown true solutions, i.e. there are very limited test cases with known solutions. As such, the accuracy and precision of the software can be hard (if not impossible) to judge.

The \textit{technique selection challenge} is a challenge that comes up often when dealing with continuous mathematical equations. Since these cannot be solved directly (due to computers being discrete), some technique must be chosen which can produce a solution which is ``good enough'' for the user. Choosing the technique to use is typically left to domain experts as each technique will (not) satisfy certain non-functional requirements.

The \textit{input output} challenge impacts the usability of SC software and typically comes up where considerable amounts of input data are used in the production of large volumes of output. The main issue in this case is the complicated nature of the input data and the output, leading developers to recreate existing library routines (slightly modified) in order to deal with the nature of the input and output.

Finally, the \textit{modification challenge} tends to come up as requirements change. As SC software is used at the forefront of scientific knowledge, there can be a high frequency of requirements changes. As changing requirements can mean completely modified systems, it poses a problem for scientists: commercial software can be difficult/expensive to modify and noncommercial programs are not often flexible enough to change.

\subsection{History of Attempts to Improve Quality}
\label{subsec:history}

SC software has not seen many focused attempts at improving software quality. Most attempts at improving software quality have been aimed at a broader target than SC specifically. However, many of the methods used have been useful to SC software. Yu \cite{Yu2011} addresses the issue in-depth, but we will give a brief overview.

The object-orientation (OO) approach aims to increase software quality through the use of several mechanisms. \textit{Encapsulation} ensures information hiding \cite{Parnas1972} by keeping information hidden from the classes that do not require it. \textit{Inheritance} is useful in the OO approach, but not necessarily when applied to SC as many SC problems do not deal with a hierarchical structure. \textit{Polymorphism} can improve reusability by, for example, allowing algorithms to be bound at runtime (though the use of abstract classes). However, for SC software, the algorithm being solved is typically known ahead of time and thus a general program using different algorithms is not necessarily useful. 

Agile methods, on the other hand, are one of the most prevalent approaches used by software engineers. It is useful in the context of SC software as it allows for flexibility in dealing with unpredictably changing requirements, on the flip side, if the requirements are fairly stable there is no real benefit to using agile methods.

A program family approach is meant to improve reusability. As the program family is reused and retested, it is likely that any defects will be discovered, thus improving reliability. Developing a program family is a general, plan-driven approach. Where agile methods dealt with unpredictably changing requirements, the program family approach is tailored toward projects with stable or predictably changing requirements. The program family is designed such that each member solves a small set of problems, and we will discuss it in more depth in Section \ref{subsec:program}. %D Mention maintainability in sebsec:program.

There are several other techniques for improving SC software quality. The use of \textit{libraries}, for one, is a fairly standard technique used in many areas of software development. However, in SC software, libraries can be cumbersome or difficult to use due to the variety of their subroutines. \textit{Component-based development (CBD)} is similar to the library approach, but the components that are being reused are not restricted to subroutines, and CBD suggests techniques for the development of reusable components.

A \textit{problem solving environment (PSE)} is similar to both libraries and CBD, however, it is much more involved. A PSE provides all of the facilities necessary for solving a class of problems. This includes (semi-)automatic solution method selection, advanced solution methods, and the means to include novel solutions. Combining PSEs and libraries can help avoid the difficulties of using libraries independently \cite{RiceBoisvert1996}. PSEs have already been used for SC for years, with major examples being Matlab and Maple.

Another technique is \textit{aspect-oriented programming (AOP)}. It is similar to the OO approach mentioned above in that the main focus is separating concerns, however, AOP deals with cross-cutting concerns of a system (ex: logging). Aspects modularize supporting functions and isolate them from the business logic of the main program.

\textit{Generic programming} is a technique for developing reusable software. Generic programming looks at an algorithm and determines the commonalities between similar implementations of it. From there, a single, generic algorithm is created (through the use of abstractions) which will be able to cover many concrete implementations.

\textit{Generative programming} is used for automatically creating members of program families. Given a requirements specification, generative programming can produce highly customized and optimized products on demand. The product is manufactured using reusable implementation components and specific configuration knowledge.

Finally, \textit{design patterns} are solutions to recurring problems in software design. Each pattern is both general and reusable. Essentially, design patterns are templates for solving problems (that can occur in many different situations), and are typically found in OO design. As such, design patterns can be used in SC in certain cases where the OO approach is taken.

\subsection{Program Family Approach}
\label{subsec:program}

In the previous section, we introduced the idea of a program family approach. To re-iterate: the program family approach should be used in projects with stable, or predictably changing, requirements. The program family approach is reusable, reliable, and easily maintainable.

Reusability of program families is enforced by design. If the product were not reusable, there would be no reason to undertake a program family approach. Reliability stems from the reuse of the common core of the program family; defects are more likely to be found. Finally, since the core assets of the program family are managed together, it is easier to maintain. 

In a program family, each member is not a general purpose program. The family members each solve a specific (small) set of problems. This can lead to increased usability, as there is no need to configure a general purpose program for a specific problem.

Determining how or when to apply the program family approach can be difficult. However, Weiss \cite{Weiss} proposed a strategy which relies on three assumptions (phrased as hypotheses) which aid in determining whether a domain is suitable for the program family approach. The hypotheses are as follows:

\begin{itemize}
	\item \textit{The Redevelopment Hypothesis}: Most software development consists of a majority of redevelopment. Existing software systems are modified to create new variations as opposed to entirely new software systems. In most cases, these variations are more alike than different from each other.
	\item \textit{The Oracle Hypothesis}: Changes to a piece of software over its lifetime can be predicted. Specifically, necessary types of variations of a system can be predicted.
	\item \textit{The Organizational Hypothesis}: The software may be organized in such a way that predicted changes of one type can be made independently of other types of changes. Essentially, changing at most a few modules in the system for any given type of change.
\end{itemize}

Many SC programs can be developed as families because they adhere to these hypotheses. With respect to the redevelopment hypothesis, SC software that performs simulations, for example, typically has several of its own assumptions. If these assumptions are modified, then it is likely that the software can now perform a different (hopefully useful) simulation. The same applies to any SC software which solve problems in similar ways: there is reuse of common functionality so it would necessarily be redeveloped in other situations. 

Many SC software adhere to the oracle hypothesis since they are equations that model scientific theories which have been studied over many, many years. The theories are stable, so any change to the software is predictable. Changes to the computational design are generally known ahead of time or can be estimated by the domain specialists (scientists).

The organizational hypothesis holds for SC software as well, but perhaps not as strongly as the other two (yet). As we mentioned, a major area of change are the underlying assumptions for programs. These assumption changes for the models are not often strongly dependent, thus few modules would need to be changed to modify the software. However, there is typically a strong connection between algorithms and data structures in SC software, but separating the data structures from the algorithms is not impossible \cite{Berti2000, ElSheikh2004}. 

- many examples where reuse has not been achieved

\subsection{Literate Programming}
\label{subsec:literate}

- overview of LP, starting with Knuth - a similar background to what we need here is given in SmithKoothoorAndNedialkov.pdf

\section{What is Possible with a Literate Family Approach}
\label{sec:what}

- this is the discussion section - give advantages and then use examples to illustrate

\subsection{Software Certification}
\label{subsec:software}

- need to generate required documentation, without impeding the work of the scientists
- need to be able to make changes at reasonable cost - this requires traceability

Start with a default set of documentation, as follows
	- Problem Statement
	- Development Plan
	- Requirements Specification
	- Verification and Validation plan
	- Design Specification
	- Code
	- Verification and Validation Report
	- User Manual
(A start to an explanation about these documents is in ZhengEtAl2015SS, since the document is not complete, I will not check it into the repository, but e-mail it to you.)

\subsection{Knowledge Capture}
\label{subsec:knowledge}

- conservation of thermal energy equation - used for thermal analysis of fuel pins and then reused for solar water heating tank
- maybe hg/hc example?
- Build a library of artifacts that can be reused in many different contexts
- example of “Commonality Analysis for a Family of Material Models” (SmithMcCutchanAndCarette2014 - not yet published - in mmsc repos) - the section on the purpose of the document (Section 1.1) discusses how the documentation combines various sources and uses a consistent notation and terminology

\subsection{``Everything should be made as simple as possible, but not simpler.'' (Einstein quote)}
\label{subsec:everything}

- although powerful/general commercial finite element programs are available, they are often not used to develop new “widgets”
- reasons are cost, and complexity
- rather than use simulation, engineers often resort to building prototypes and testing
- engineers would greatly benefit from tools to assist their design efforts that are customized to their exact set of problems - with a literate family approach family members can be generated to fit their needs
- if an engineer designs parts for strength, they could have a general stress analysis program - the program could be 3D if needed, or specialized for plane stress or plane strain, if that was the appropriate assumption - the program could even be customized to the parameterized shape of the part they are interested in, with only the degrees of freedom, like material properties, or the specific dimensions, they can change being exposed.

\subsection{Optimization}
\label{subsec:optimization}

- Connect optimization with analysis.  Optimization requires running multiple analysis cases.  Code generation can be used to build an efficient model that has just what is needed, and no more.  As the optimization searches the design space, new models can be generated.
- An optimization problem for a part where the shape and constitutive equation are degrees of freedom, cite family of material models (SmithMcCutchanAndCarette2014)

\subsection{Verification}
\label{subsec:verification}

- requirements include so-called “sanity” checks that can be reused when they come up in subsequent phases
- for instance, requirement would state conservation of mass, or the fact that lengths are always positive - the first used to test output, the second to guard against invalid input

- computational variability testing, from Yu (2011), FEM example
- usual to do grid refinement tests - same order of interpolation, but more points
- code generation allows for increases in the order of interpolation, for the same grid
- Yu discusses in section 6.3 of her thesis

\subsection{Incorporating Non-Functional Requirements in a decision support system for selecting the best design options}
\label{subsec:incorporating}

Use AHP. - see Smith2006.pdf

\section{Concluding Remarks}
\label{sec:concluding}

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

%D Need to remember how to do bibtex.

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

