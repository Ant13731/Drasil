\documentclass[preprint, 10pt]{sigplanconf}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{positioning}
\newcommand{\cL}{{\cal L}}
\newcommand{\colAwidth}{0.1\textwidth}
\newcommand{\colBwidth}{0.34\textwidth}
\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{Onward! '16}{October 30--November 4, 2016, Amsterdam, Netherlands}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Title Text}
\subtitle{Subtitle Text, if any}

\authorinfo{Dan Szymczak}
           {McMaster University}
           {szymczdm@mcmaster.ca}
\authorinfo{Jacques Carette\and Spencer Smith}
           {McMaster University}
           {carette@mcmaster.ca / smiths@mcmaster.ca}

\maketitle

\begin{abstract}
This will be filled in once we're done drafting. For now I'm putting in a solid
block of text that will let me ramble on for a while when it comes down to the
final abstract. Programmers are like gods of tiny universes. They create worlds
according to their rules. If we think of software artifacts (that is, all
documentation, build instructions, source code, etc.) as their own tiny worlds,
a universe takes shape. Now think about what would happen if the laws of that
universe were inconsistent between worlds. What if the laws of thermodynamics
fundamentally changed as soon as you left Earth? Say goodbye to space travel.
Keeping artifacts consistent with each other is hugely important in the software
world, and Drasil aims to ensure it...
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%\terms
%term1, term2

\keywords
Literate software, knowledge capture, traceability, software engineering,scientific 
computing, artifact generation, software quality

\section{Introduction}
\label{sec:Intro}

We want to make better software.  In particular, we are interested in
increased maintainability, traceability, reproducibility, verifiability, and
reusability.  Our approach is to invest (much) more in the short-term to provide
outstanding long-term benefits. This is the fundamental trade-off in
our work: we expect our methods to work very well for domains which are 
well understood with known (but potentially enormous) design spaces.  We do
not claim to tackle areas of software development where methodologies such
as agile are well-suited.  But we firmly believe that there are domains --
such as safety-critical applications -- where agile is not only ill-suited,
it would be downright unprofessional to use such a methology in that setting.

Rather than talk in vague generalities, we will pick Scientific Computation
(SC) for illustrative purporses throughout this paper.  But the fundamental
ideas (and, in fact, our framework) should be applicable to any software
domain which has well-established theoretical underpinnings, and a well
understood translation of the theory into effective code.  SC is particularly
well-suited as it is also replete with \emph{program families}.

We believe that Knuth's Literate Programming (LP)~\cite{Knuth1984} contains
some fundamental insights, but is too restricted (i.e. just to code).  Rather
than restrict LP to just source code, we want to apply it to all software
artifacts (requirements and design documents, source files, test cases, build
instructions, user manuals, etc.) from a singular common knowledge base.

We want to break away from the LP idea of ``one source'', instead introducing
the idea of ``common knowledge'' libraries for problems that come up regularly.
For example: the theory behind heat transfer including the conservation of
energy equations would be in a ``common knowledge'' library. We could also see
the idea of the Syst\`{e}me International (SI) Units as another piece of
``common knowledge''.

We also very much want to keep the idea of ``chunks'' and assemble everything
from chunks. How we do that will be discussed in more detail in
Section~\ref{sec:Drasil}.

We intend to make working on program families trivial for the cost of losing the
capability to create ``local hacks'' to ``just get things working''.

Another disclaimer before we go further: none of the ideas presented
in this paper are new. We are building on a very longstanding history of work,
and not being particularly creative with the ideas therein. Knuth himself even
said that ``I have simply combined a bunch of ideas that have been in the air
for a long time'' when he coined LP~\cite{Knuth1984}. We are, however, taking old
ideas and breaking them down into something practical that we can work with. We
want to \emph{do} something, not spend years stuck in the design phase.

Others have done similar work (which we will get into in Section~\ref{sec:bg}),
but they did not achieve the results we are envisioning. They either set their
aims on other targets, spent too long creating a grand design and ended up
without any real, practical results, or they simply were not brave enough to
break things down into the smallest necessary chunks.

We believe that we have assembled the right ideas to achieve our vision.
The overall success or failure of our approach hinges on the idea of a stable,
well understood knowledge base. Without that we might as well give up and go
home. If we do not understand the fundamentals behind the software we intend to
create, then we will be unable to properly encapsulate that fundamental
knowledge for use in our framework (effectively getting us nowhere).

As it stands, we are on a (not so) humble, practical route to achieving our
goals and improving the overall quality of software.

\section{Drasil}
\label{sec:Drasil}

Our framework is called Drasil (shortened from \emph{Yggdrasil} from Norse
Mythology, which is also known as the \emph{world tree}). It is currently being
developed through a practical, example-driven approach in an effort to bring our
vision to life. There are three main ideas driving Drasil's development:

\begin{enumerate}
\item Organize the knowledge base -- We want a knowledge base that we can
structure conceptually (i.e. keep knowledge for a certain class of problems
together). This is where chunks come into play: each chunk encapsulates a single
piece of knowledge like a concept or a quantity. We want to break our knowledge
base down into the smallest possible pieces.

\item Use recipes to create artifacts -- We can think of each artifact in our
software project as a different view of our knowledge base. We want to use
recipes to specify exactly what information from the knowledge base is necessary
for each artifact, and how that information should be displayed. For many
artifacts we would like to have a standard recipe which can be quickly
customized for the current problem and that is how we will avoid duplicating
knowledge.

\item Remove technology constraints -- We want to be able to create our software
without worrying about the underlying technical constraints of our display or
specification technology, programming language(s), etc. Anyone using Drasil
should be able to work with the knowledge base and their recipes, then simply
set their output technology and have the generator take care of all the
technical details.
\end{enumerate}

We argue that by implementing Drasil around these ideas, we can see drastic
improvements in software quality. In fact, using a generative approach we can
avoid certain problems altogether. One obvious and recurring problem that comes
to mind when upgrading software is ``feature creep'' or ``software
bloat''~\cite{AmselEtAl2011}. With Drasil, a software upgrade will actually be a
completely new piece of software that includes the previously desired
functionality as well as the new upgrades. We will discuss further improvements
in more detail after our example in Section~\ref{subsec:example}.

\subsection{Drasil's current implementation}
\label{subsec:current}

Fundamentally, Drasil must be able to capture knowledge and produce different
views of that knowledge. With our current implementation we have each individual
piece of knowledge as a named \emph{chunk}. We are then able to manipulate our
chunks through the use of a \emph{recipe}. Our \emph{generator} interprets the
recipes to produce the final desired view. This view represents one of the many
software artifacts mentioned in Section~\ref{sec:Intro}.

As mentioned, we capture knowledge into named chunks, of which there
are several varieties. Actually, we have a hierarchy of chunk types, where each
new chunk encapsulates more than the previous one(s) (see
Figure~\ref{fig:chunks} for an idea). The most basic \emph{chunk} represents a
named piece of information. Above that we have named \emph{concepts} which
introduce some descriptive information.

A \emph{quantity} is a concept that has a symbolic representation, we can refer
to the quantity by either its name or symbol. In a similar vein are
\emph{units}, %need something more here -- (which encapsulates the units
%attached to a concept)?? 
and \emph{relation chunks} (which add the idea of a
relation between some other pieces of knowledge).

In an SC context, most of the knowledge we work with is represented as a
quantity with some units, in other words a \emph{unital} chunk. Expanding on
that, we can actually calculate values for many of these unital concepts. As
such, we have \emph{eqchunks} which allow us to capture the equation along with
everything else included in a unital chunk.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=6mm]
  \tikzstyle{every node}=[draw,shape=rectangle, rounded corners,
    text width=6em, text centered];
  \node (ch)                     {Chunk (\emph{name})};
  \node (co) [below = of ch]       {Concept (\emph{description})};
  \node (qu) [below left = of co]  {Quantity (\emph{symbol})};
  \node (rc) [below = of co]		   {RelationChunk (\emph{relation})};
  \node (u ) [below right = of co] {Unit (\emph{unit})};
  \node (uc) [below = of rc] 		{Unital};
  \node (eq) [below = of uc]		   {EqChunk (\emph{equation})};

  \draw [->, line width=2pt] (ch) -- (co);
  \draw [->, line width=2pt] (co) -- (qu);
  \draw [->, line width=2pt] (co) -- (rc);
  \draw [->, line width=2pt] (co) -- (u );
  \draw [->, line width=2pt] (qu) -- (uc);
  \draw [->, line width=2pt] (u ) -- (uc);
  \draw [->, line width=2pt] (uc) -- (eq);
\end{tikzpicture}
\end{center}
\caption{Our current chunk design}
\label{fig:chunks}
\end{figure}

Now with the means to encapsulate knowledge, we can turn our attention to our
recipes. The recipes are implemented using a combination of embedded Domain
Specific Languages (DSLs) in Haskell. We have currently implemented the
following DSLs:

\begin{enumerate}
\item Expression language -- A simple expression language that allows us to
capture knowledge relating to equations and mathematical operations. It
includes, but is not limited to, operations such as addition, multiplication,
negation, derivation, and exponentiation.

\item Expression layout language -- A micro-scoped language for describing how
expressions should appear. Expressions may need to use subscripts, superscripts,
concatenated symbols, etc. to be properly displayed.

\item Document layout language -- A macro-scoped language for describing how
large-scale layout objects (tables, sections, figures, etc.) should appear.

\item C Representation Language -- A DSL for representing parts of the C
programming language inside the Drasil framework. This allows the generator to
produce working C code.

\item \LaTeX Representation Language -- A DSL for representing \LaTeX code
inside of Drasil.

\item HTML Representation Language -- A DSL for representing HTML within Drasil.
\end{enumerate}

Of the DSLs mentioned, we only actually have to write our recipes using three of
them. Each of the representation languages are used strictly by the generator as
an intermediary in the production of our desired views. We write our recipes
using the document layout language, expression layout language, and expression
language. We will discuss the particulars of each of these in more depth during
our example (Section~\ref{subsec:example}).

The last piece of the puzzle is the generator. We use it to interpret the
recipes, create intermediary representations of our desired views, and then
pretty-print them.

\subsection{Drasil in Action} \label{subsec:example}
For this section we will take a look at a simplified version of a Software
Requirements Specification (SRS) for a fuel pin in a nuclear reactor (for more
information on that particular SRS see~\cite{SmithAndKoothoor2016}).

Starting off we will look at one specific term: $h_c$. In this example, $h_c$
represents the convective heat transfer coefficient between the clad and
coolant. The data definition for $h_c$ from the original SRS can be seen in
Figure~\ref{fig:h_c}.

\begin{figure}
~\newline \noindent \begin{minipage}{\textwidth}
\begin{tabular}{p{\colAwidth} p{\colBwidth}}
\toprule \textbf{Number} & \textbf{DD2 \label{hc}}
\\ \midrule 
Label & 
$h_{c}$
\\ \midrule
Units & $ML^0t^{-3}T^{-1}$\\ \midrule
SI Units & $\mathrm{\frac{kW}{m^{2o}C}}$\\ \midrule
Equation & $h_{c}$ =$
\frac{2k_{c}h_{b}}{2k_{c}+\tau_{c}h_{b}}$\\ \midrule
Description &  $h_{c}$ is the convective heat transfer coefficient between clad and coolant
\newline
$k_{c}$ is the
clad conductivity \newline
$h_{b}$ is the
initial coolant film conductance \newline
$\tau_{c}$ is the
clad thickness 
\newline
%NOTE: Equation taken from the code\\ \midrule  Sources & source code \\ \bottomrule 
\end{tabular} \end{minipage}\\ 
\caption{Data definition for $h_c$ from the fuel pin SRS}
\label{fig:h_c}
\end{figure}

The data definition of $h_c$ displays some interesting knowledge. It gives us
the name for a concept, its description, a symbol to use for easier reference,
its (SI) units, and its defining equation. Encapsulating all of this knowledge
into a chunk is not very difficult as shown in Figure~\ref{fig:h_cChunk}. We use
an EqChunk as it allows us to capture all of the relevant knowledge.

\begin{figure}
\begin{lstlisting}[frame=single, showstringspaces=false, basicstyle=\small]
h_c_eq :: Expr
h_c_eq = 2*(C k_c)*(C h_b) /
  (2*(C k_c) + (C tau_c)*(C h_b))

h_c :: EqChunk
h_c = fromEqn "h_c" 
 "convective heat transfer coefficient
    between clad and coolant"
 (sub h c) heat_transfer h_c_eq
\end{lstlisting}
\caption{The $h_c$ chunk in Drasil}
\label{fig:h_cChunk}
\end{figure}


%What about common knowledge? Wa-bam SI Units. 
%HTML vs LaTeX? Show raw code or pretty-version? Pretty version. 
%Might need to screencap HTML and drop it in.

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{drasil}
%
% The bibliography should be embedded for final submission.
%
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}


\end{document}
