\documentclass{article}
\begin{document}

\bibliographystyle{plain}
\pagestyle{plain}
\thispagestyle{empty}
\markboth{{\sc thesis proposal}}{{\sc thesis proposal}}
\def\title{\large \sc TODO: Title Here}
\def\author{\sc Dan Szymczak}
\def\studnum{0759661}
\def\email{\sc szymczdm@mcmaster.ca}

\def\degree{Doctor of Philosophy}
\def\deptname{Computing and Software}
\def\supJ{Jacques Carette}
\def\supS{Spencer Smith}

\def\submissiondate{\today}
\def\completiondate{August 2018}

\begin{center}
{\Large \bf 
   McMaster University
\\ Department of \deptname \\}
\vspace{.25in}
{\Large \bf
   Proposal for Thesis Research in Partial Fulfillment
 of the Requirements for the Degree of \degree \\}
\end{center}

\vspace{.5in}

\begin{tabular}{rlc}
   {\large \sc Title:}                       & \multicolumn{2}{l}{\title}
\\ {\sc Submitted by:}
                            & \author  & \\
    {\sc Student Number:}   & \studnum & \\
                            & \email   & \\ 
			    &	       &
\\ { \sc Date of Submission:}          & \multicolumn{2}{l}{\submissiondate}
\\ {\small \sc Expected Date of Completion:} & \multicolumn{2}{l}{\completiondate}
\\ & \\ & \\
\\ {\large \sc Supervisors:}                 & {\large {\supJ}}
\\ & {\large {\supS}}
\end{tabular}

\cleardoublepage
\pagenumbering{roman}
\begin{abstract}

TODO: ABSTRACT

\end{abstract}
\pagebreak
\tableofcontents
\pagebreak
\pagenumbering{arabic}

\section{Introduction}

TODO: Introduce the main ideas

\section{State of the Art}

To pursue this line of research, first one needs to understand the history of research in several closely-related areas. Since I will be focusing on the improvement of SC software, the obvious starting point would be to look at the current state of SC software development and its challenges. Also, as I am intending to expand the ideas of literate programming, it is necessary to delve into sufficient depth on LP and why it has not been widely adapted as yet, as well as any attempts to expand or build upon it. Finally, with the idea of long-term maintainability, full traceability, and reproducibility in mind, I would be remiss if I did not look into the field of reproducible research.

\subsection{Current State of SC Software Development}

In many instances of SC software development, the developers are the scientists. These developers tend to put the most emphasis on their science instead of good software development practices~\cite{Kelly2007}. Rigid, process-heavy approaches are typically considered unfavourable to these developers~\cite{CarverEtAl2007}. We see the developers choose to use an agile philosophy~\cite{AckroydEtAl2008, CarverEtAl2007, EasterbrookAndJohns2009, Segal2005}, an amethododical~\cite{Kelly2013}, or a knowledge acquisition driven process~\cite{Kelly2015} instead.

There are several clear problems with the current state of SC software development. The first, fairly obvious problem is that knowledge reuse is not being utilized to the fullest extent possible. As an example, a survey~\cite{Owen1998} showed that of 81 different mesh generator packages, 52 generated triangular meshes. Now that in itself may not show a lack of knowledge reuse, however, looking deeper we see that 37 of those packages used the same Delaunay triangulation algorithm for generating those meshes. There is no reason that the exact same algorithm should be implemented 37 separate times when it could simply be reused.

Another problem in SC software development is the lack of understanding of software testing. More than half the scientists developing SC software lack a good understanding of software testing~\cite{Merali2010}. It is in such a bad state that quality assurance has ``a bad name among creative scientists and engineers''~\cite[p.~352]{Roache1998}, not to mention the very limited use of automated testing~\cite{PatrickEtAl2015}.

It should be obvious that some of these issues could be solved through the use of certain tools. However, it should be noted that tool use by SC software developers is also very limited, especially the use of version control software~\cite{Wilson2006}.

Not everything about SC software development today is a negative. For example advanced techniques like code generation have been quite successful in SC. Some generation examples that come to mind are FEniCS~\cite{LoggEtAl2012}, FFT~\cite{KiselyovEtAl2004}, Gaussian Elimination~\cite{Carette2006}, and Spiral. The focus of generation techniques, thus far, have been solely on one software artifact: the source code. Focusing solely on code is a disadvantage to SC software developers as the value of documentation, as well as a structured (or rational) process, have been repeatedly illustrated~\cite{SmithAndKoothoor2016, SmithEtAl2015-SS-TR, SmithEtAl2015SQJ, SmithEtAl2013}.

\subsection{Literate Programming}

The LP methodology introduced by Knuth changes the focus from writing programs that simply instruct the computer on how to perform a task to explaining (\emph{to humans}) what we want the computer to do~\cite{Knuth1984}.

Developing literate programs involves breaking algorithms down into \emph{chunks}~\cite{JohnsonAndJohnson1997} or \emph{sections}~\cite{Knuth1984} which are small and easily understandable. The chunks are ordered to promote understanding, a ``psychological order''~\cite{PieterseKourieAndBoake2004} if you will. They do not have to be written in the same order that a computer would read them. It should also be noted that in a literate program, the code and documentation are kept together in one source. To extract working source code, a process known as \emph{tangle} must be run on the source. A similar process known as \emph{weave} is used to extract and typeset the documentation from the source.

There are many advantages to LP beyond understandability. As a program is developed and updated, the documentation surrounding the source code tends to be updated simultaneously. It has been experimentally found that using LP ends up with more consistent documentation and code~\cite{ShumAndCook1993}. Having consistent documentation has its own advantages while developing or maintaining software~\cite{Hyman1990, Kotula2000}. Similarly, there are many downsides to inconsistent documentation~\cite{Kotula2000,Thimbleby1986}. Keeping both of those in mind we can see that more effective, maintainable code can be produced when (properly) using LP~\cite{PieterseKourieAndBoake2004}.

Even with all of the benefits of LP, it has not been very popular~\cite{ShumAndCook1993}. Though it has not been popular, there are still several successful examples of LP's use in SC; two that come to mind are VNODE-LP~\cite{Nedialkov2006} and ``Physically Based Rendering: From Theory to Implementation''~\cite{PharrAndHumphreys2004}. The latter being a literate program as well as a textbook. Shum and Cook discuss the topic of LP's lack of popularity and present the idea that it comes from a couple of main issues: dependency on a particular output language or text processor, the lack of flexibility on what should be presented/suppressed in the output.

Many attempts to address the issues with LP's popularity have focused on changing or
removing the output language or text processor dependency. Many new tools were developed such as: CWeb (for the C language), javadoc (for Java), DOC++ (for C++), Doxygen (for multiple languages), noweb (programming language independent), and more. The development of new tools led the introduction of many new features including, but not limited to, a ``What You See Is What You Get'' (WYSIWYG) editor~\cite{FritzsonGunnarssonAndJirstrand2002}, phantom abstracting~\cite{ShumAndCook1993}, and even movement away from the ``one source'' idea~\cite{Simonis2003}.

While these tools did not bring LP into the mainstream~\cite{Ramsey1994}, they did help drive the understanding behind what exactly LP tools must do. Although LP is not yet mainstream, we can see it becoming more standardized in certain domains (for example: Agda, Haskell, and R support LP).

\subsection{Literate Software}

A combination of LP and Box Structure~\cite{Mills1986} was proposed as a new methodology called ``Literate Software Development'' (LSD)~\cite{AlMatiiAndBoujarwah2002}. Box structure can be summarized as the idea of different views (ex. system specifications, design, code) which are abstractions that communicate the same information in different levels of detail, for different purposes.

LSD was developend with the intent to overcome the disadvantages of both LP and box structure. Specifically, it was intended to overcome LP's inability to specify interfaces between modules, box structure's inability to decompose boxes and the inability to implement the design created by box structures, as well as the lack of tools to support box structure~\cite{Deck1996}. 

The main idea behind LSD was to overcome the disadvantages of LP and box
structure. These disadvantages included: the inability of LP to specify
interfaces between modules; the lack of ability to decompose boxes; a lack of
tools to support box structure~\cite{Deck1996}; a lack of ability to implement
the high-level analysis and design created using box structures.

The framework developed for LSD, ``WebBox'', expanded LP and box structures in a variety of ways. It included new chunk types, the ability to refine chunks, the ability to specify interfaces and communication between boxes, and the ability to decompose boxes at any level.

\subsection{Reproducible Research}

Being able to reproduce results is fundamental to the idea of good science. Reproducible research has been used to mean embedding executable code in research papers to allow readers to reproduce the results described~\cite{SchulteEtAl2012}. 

Combining research reports with relevant code, data, etc. is not necessarily easy, especially when dealing with the publication versions of an author's work. As such, the idea of \emph{compendia} were introduced~\cite{GentlemanAndLang2012} to provide a means of encapsulating the full scope of the work. Compendia allow readers to see computational details, as well as re-run computations performed by the author. Gentleman and Lang proposed that compendia should be used for peer review and distribution of scientific work~\cite{GentlemanAndLang2012}.

Currently, several tools have been developed for reproducible research including, but not limited to, Sweave, SASweave, Statweave, Scribble, and Org-mode. The most popular of those being Sweave~\cite{SchulteEtAl2012}.

\section{Research Objectives and Approach}
\subsection{Objectives}
-Want to tackle SC software dev current problems by simplifying the dev process

-Improve software qualities (maint. trace. reproduc. verify. reus.). How? Better understand underlying knowledge.

-Communicate the understanding of the knowledge -> better documentation (software artifacts) that's always up to date.

-Devs should spend less time maintaining.

-Avoid a classical software mistake (shown to be prevalent in SC thanks to Owen): duplication. Reuse, don't reimplement.

-Everything should be reproducible.

-Remove technology constraints

\subsection{Approach}

-Use ideas from LP, but expand them.
	-chunks: not just pieces of code; representations of knowledge.
	-capture knowledge: easily reuse it, never duplicate it.

-Knowledge stored should be spec-level. Assumptions, derivations, etc.
	- Pretty easy to get code from there.
	- Automate code generation.
	
-Move away from LP for maintainability, consistency, traceability, and reproducibility.
	-Recipes, standard generator, thematically linked knowledge-bases.
	-Given the above, anyone should be able to reproduce results.
	-All knowledge is easily traced to a source chunk.
	-Running the gen will ensure all artifacts are consistent.
	
-Make sure everything from the previous section is addressed.

\section{Current Work and Preliminary Results}

\subsection{The Drasil Framework}

-Introduce Drasil; eDSL(s) in Haskell

-chunks, recipes, generator

-multiple types of chunks (diagram)

-Recipe DSLs - Expr, Spec, LayoutObj.

-Gen specific ASTs - ASTC, ASTTeX, ASTHTML

\subsection{Using Drasil}

-$h_g$ and $h_c$ example overview.

-Water heater example overview.

-show some of the simple example impl.

-talk about common knowledge and (example) reusable library SI Units.

-discuss the output being nearly identical to the original (exceptions being specific design decisions such as ignoring the initial ``Units'' and only using ``SI Equivalent'').

-Show off some of the output -> Screencap the HTML page for water heater or FP?

-Discuss adv and disadv of method.

-Adv: No inconsistencies. Avoid manual copying of knowl through artifacts. Auto-propagate updates to knowl. Mentioned before: reusable knowl (SI). Supports design for change (properly captured knowledge means we just tweak a config to change our software). 100\% traceability. Pervasive bugs!

-Disadv: No (consistent) local hacks. All-or-nothing approach removes meaningful iteration. Modifying knowledge over the lifetime of a project can become a very involved process. Creating common-knowledge libraries is difficult (requires domain expert).


\section{Work Plan and Next Steps}

A full schedule of my work plan can be found in Section~\ref{subsec:schedule}. There are still many features I would like to add to Drasil as well as improvements to the overall implementation. Currently anticipated additions and changes (in no particular order) are as follows:

\begin{itemize}
\item Encapsulate more types of information in chunks. Some of the next additions should be 		physical constraints and reasonable values.
\item Use constraints to generate test cases.
\item Implement much larger examples.
\item Generate code in more languages. Specifically MATLAB is the next planned output 
		language implementation.
\item Generate more artifact types. As it stands, the current recipes only create 
		requirements documents or code. New recipes should be included to cover design 
		documents, test cases, build instructions, user manuals, and more.
\item Generate different document views. This is partially implemented in the requirements 
		document recipe by allowing simplified or verbose data descriptions. The ability to 
		simplify parts of the document that are unnecessary for a target audience should be 
		expanded.
\item Create an external syntax for Drasil.
\end{itemize}

Over the summer (2016), three undergraduate students will be working on translating existing implementations of large examples into Drasil implementations. It is my hope that this experiment will provide insight onto any lacking features of Drasil, as well as how well the new approach works. A second PhD student will also be joining the project over the summer. His first task will involve implementing a large example and helping to expand Drasil.

\subsection{Detailed Schedule}
\label{subsec:schedule}

Table~\ref{table:schedule} shows a current breakdown of what I will be doing for the rest of my tenure as a PhD student.
% TODO: Make Table
\begin{table}
\caption{A detailed work schedule for the next twenty-eight months}
\begin{tabular}{|l|p{0.85\textwidth}|}
\hline
      Summer 2016 & Summer student experiment.
            Implement multiple (3-4) large examples using Drasil, updating the
              framework as new needs for features arise.\\ \hline

      May 2nd 2016 & Introduce summer students to Drasil and begin teaching them.
\\ \hline
      May 2016 & Improve C output and implement MATLAB output in Drasil.
\\ \hline
      June/July 2016 & Implement more artifact types in Drasil
\\ \hline
      August 2016 & Submit results of summer experimentation to SEHPCCSE'16
\\ \hline
      September 2016 & Overhaul the Drasil back-end to solidify necessary features
                      and re-design parts of the implementation.
\\ \hline
      September 2016 & Begin the last course for my PhD requirements.
\\ \hline
      October 2016 & Meet with Ernie from OPG.
\\ \hline
      October 2016 & Begin implementation of more knowledge capture.
\\ \hline
      November 13, 2016 & (Hopefully) Present work at SEHPCCSE'16.
\\ \hline
      November 2016 & Finish implementation of more KC.
\\ \hline
      December 2016 & Finish coursework.
\\ \hline
      December 2016 & Write a paper to submit to ??.
\\ \hline
      January 2016 & Begin implementation of auto-gen'd test cases.
\\ \hline
      January 2017 & Begin work on external syntax.
\\ \hline
      February 2017 & Finish work on external syntax.
\\ \hline
      February 2017 & Write a paper to submit to a Journal ??
\\ \hline
      March 2017 & Re-evaluate current Drasil implementation for usability. 
        Work on making it as user-friendly as possible
\\ \hline
      April 2017 & Find and collect more large-scale examples to be implemented 
        and begin implementation of one.
\\ \hline
      April 2017 & Meet with my committee.
\\ \hline
      May 2017 & Write a paper to submit to ?? %SYNASC?
\\ \hline
      Summer 2017 & Attempt to get summer students for second round of 
        experimentation. Complete implementation of multiple large-scale 
        examples.
\\ \hline
      August 2017 & Write a paper to submit to (Journal ??) detailing results.
\\ \hline
      September 2017 & Meet with Ernie from OPG.
\\ \hline
      Sept - Nov 2017 & Update Drasil and perform a final evaluation.
\\ \hline
      Dec 2017 & Begin writing up full PhD Thesis.
\\ \hline
      February 2018 & Complete first draft of thesis and send to supervisors for 
        comments.
\\ \hline
      March 2018 & Begin editing thesis.
\\ \hline
      May 2018 & Complete final thesis draft before defense.
\\ \hline
      June 1-14 & Vacation.
\\ \hline
      June 21, 2018 & Defend thesis.
\\ \hline
      July-August 2018 & Make any necessary revisions to the thesis, 
        if major: defend again;
        if minor: submit the finished copy.
\\ \hline
\end{tabular}
\label{table:schedule}
\end{table}


\newpage
\bibliography{drasil}

\end{document}




