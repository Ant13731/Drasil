JC: I will put my comments inline below, but with all lines prefixed with JC.
DS: Responses to comments/questions will be prefixed with DS.

Title: Being redundant just got less tedious! 
          The Drasil framework.

==Intro==

Documentation is good [source], yet it is not often prioritized on software 
projects. Code and other software artifacts say the same thing, but to different
audiences - if they didn't, they would be describing different systems.

Take, for example, a software requirements document. It is a human-readable 
abstraction of *what* the software is supposed to do. Whereas a design document 
is a human-readable version of *how* the software is supposed to fulfill its 
requirements. The source code itself is a computer-readable list of instructions
of *what* must be done and, in many languages, *how* that is to be accomplished.

[Put in figures of an example from GlassBR/Projectile here, showing SRS, DD, and
code versions of the same knowledge]

Manually writing and maintaining multiple documents for different audiences is 
redundant and tedious. Factor in deadlines, changing requirements, and other 
common issues faced by developers and you have a perfect storm for 
syncronization issues between artifacts for a given piece of software.

How can we avoid out of sync artifacts? Some would argue "just write code!" And 
that is exactly what a number of other approaches have tried. Documentation 
generators like Doxygen, Javadoc, Pandoc, and more take a code-centric view of 
the problem. Typically, they work by having natural-language descriptions and/or
explanations written as specially delimited comments in the code which are later
automatically compiled into a human-readable document.

While these approaches definitely have their place, they do not solve the 
underlying redundancy problem. The developers are still forced to manually write 
descriptions of systems in both code and comments. They also do not generate all
software artifacts.

We propose a new framework, Drasil, alongside a knowledge-centric view of
software, to help deal with these redundancy and syncronization problems.
Our approach looks at what underlies the problems we solve using software, then 
capturing that "common" or "core" knowledge to generate our software artifacts.

==Background==
-- Software Artifacts --

- Here we give a list of what we mean when we refer to all software artifacts.
  Brief description of each and their audience (in terms of stakeholders?).
  - Requirements 
    - All stakeholders - What problem are we solving?
    - What do we need to do?
  - Design
    - All stakeholders 
      - business - budget concerns; 
      - technical - implementation/platform concerns
    - How are we going to do it?
  - Build instructions
    - For the machine
    - How to build the software from source
  - Implementation
    - For the machine
    - What is built/ what is the system doing?
  - Implementation guide
    - For the humans
    - What did we actually build?
  - Test plan
    - For the humans
    - How do we test it?
  - Test results (?)
    - How did our tests go?
  - User guide
    - How do you use the software?
  - ... {Let's figure out all the ones we agree on}
  
-- Software Re-Use and Software Families --

        - We want to see more software re-use, but the reality is its often
          faster (or cheaper) to re-develop a particular tool, algorithm, etc.
          rather than find an existing project to adapt 
            (re-word previous, it's not quite what I want to say)
JC: Good point. Leads to justification for 'knowledge capture' via current artifacts of SE
JC: perhaps not being the 'right' ones. Some libraries (and frameworks) have had huge success
JC: regarding re-use, while others have flopped completely. No obvious trend.
        - Significant efforts can be made to develop a software variant that is very 
          similar to an existing project
          - These variants are members of the same software family, typically with
            minor changes
JC: need to be more concrete. The linux kernel here is an interesting example - it is a huge
JC: software family. No one really knows which of the variants actually work!
DS: That's a great example.
            - Can happen when it seems easier to create a new variant as a stand-alone
              rather than attempt to update old code and docs
            - Also influenced by lack of documentation around existing software,
              confusing APIs, lack of subject-matter-experts, etc.
JC: Do you have citations to back that up? Proper science needs its citations.
DS: Yes, just need to re-find them.

-- Literate Programming --
- Fairly code-centric view as mentioned in intro. Lots of examples 
    (wiki: Comparison of documentation generators)
- One source, multiple views.
- Somewhat redundant b/c of natural-language descriptions + code.

-- Generative Programming --

== Understanding Commonality and the source of redundancy==
- Breakdown our process of working through each of the case studies and 
developing our "common" / "core" knowledge for each example.
- Breakdown the process of working through each case study and developing the
"recipe" for each artifact.

== Drasil ==
  - Drasil is a framework we've developed for generating *ALL* software artifacts (in their
    desired format) from a single source using transformations and projections.
      - Core knowledge (not system-specific) is reusable inter- and intra-project
      - No manual duplication - reduced redundancy.
      - Consistent by construction

    - Leveraged our understanding of generative software & software development
    principles and practices in dev
    - Development of Drasil has been practical and example-driven
    - Guiding principle: If software artifacts are views of the same information,
    we should be able to abstract out the core knowledge, then generate the views 
    as necessary
      - Remove the need for manual duplication
      - Use transformations to format knowledge appropriately
        - Ex. Code-views vs. document-views of calculations
        look very different, even across similar languages, but say the same thing
          - Figure: A calculation in C# code, python code, LaTeX, and HTML
      - Ensure consistency & traceability
JC: agreed on all points above (leveraged ... here).

    - "Recipes" used to create our views, can be thought of as "little programs"
    that assemble our artifacts.
      - Based off of document templates, and similar to code templating, but 
      much broader configuration scope(or something?)
    - Includes KC mechanisms for creating a 'living database' of common information 
JC: not sure about mentioning KC *here*. Agree that it is part of our ideas.
DS: KC was just being used as a descriptor, doesn't need to be here.
      - Currently hand-curated
      - Expands as needed, all projects share it
      - Very low-level, system-specific information stored elsewhere to avoid pollution
        - Easy to move around if determined to be 'general-enough' for the common
        knowledge base (KB)
    - Captured knowledge acts as a uniform source for artifact generation
    - Structure of a project in Drasil can be broken down (generally) as:
      [Core knowledge], [Specific knowledge], & [Recipes]
JC: on Recipes and 'living database': this is all true, and important. But I am not quite
JC: "feeling it" as far as how/when to say this.
DS: This is where I'm explaining the key parts of our design/impl.
DS: It's as good a place as any to introduce the concepts. We can get into more
DS: detail later on.
  
  - What Drasil isn't
    - Not the be-all, end-all of software development
    - Only useful (and useable) in well-understood domains
      - We need to know how to capture and structure knowledge effectively
        - Ex. Science/math
    - One tool with a specific set of possible outputs and limited scope
    - Will not replace human developers, only help remove some of the tedium of
      following good software development practices
    - Not complete - Dev is still in progress
JC: Right. We don't want to over-emphasize, but do want to say.

  - Our examples - SWHS, GlassBR, SSP, Gamephys, Tiny, and NoPCM
    - Drove our practical approach
    - All re-developed to follow the SmithEtAl artifact templates using modern SE approaches
      - Gives us consistent views
        - Knowledge is easier to extract
        - We know what we want the generator to create from our Recipes
        - Gives a base structure to our recipes
JC: Right.
    - SWHS and NoPCM are software family members
      - Model solar water heating system with and without phase change material (PCM)
    - GlassBR
      - Models whether glass panes will break due to force of explosions
    - SSP
      - Models slope stability
    - Gamephys
      - Reduced-scope section of the Chipmunk2D game physics engine
      - Simulates rigid-body physics
    - Tiny
      - Toy example taken from a model of a fuel-pin in a nuclear reactor
      - Used for proof of concept mainly, and as a test case to ensure 
      updates to Drasil don't create any unwanted behaviours
    - Examples share common baseline math/science knowledge
      - Gives us a starting point for the common KB
JC: Right.
