Title: Being redundant just got less tedious! The Drasil framework.
OR
Repeating Yourself Without Repeating Yourself: The Drasil framework.

==Intro==

Documentation is good [source], yet it is not often prioritized on software
projects. Code and other software artifacts say the same thing, but to different
audiences - if they didn't, they would be describing different systems.

Take, for example, a software requirements document. It is a human-readable
abstraction of *what* the software is supposed to do. Whereas a design document
is a human-readable version of *how* the software is supposed to fulfill its
requirements. The source code itself is a computer-readable list of instructions
combining *what* must be done and, in many languages, *how* that is to be
accomplished.

[Put in figures of an example from GlassBR/Projectile here, showing SRS, DD, and
code versions of the same knowledge]

[Figure] shows an example of the same information represented in several
different views (requirements, detailed design, and source code). We aim to
take advantage of the inherent redundancy across these views to distill a single
source of information, thus removing the need to manually duplicate information
across software artifacts.

Manually writing and maintaining a full range of software artifacts (i.e.
multiple documents for different audiences plus the source code) is
redundant and tedious. Factor in deadlines, changing requirements, and other
common issues faced during development and you have a perfect storm for
inter-artifact syncronization issues.

How can we avoid having our artifacts fall out of sync with each other?
Some would argue "just write code!" And that is exactly what a number of other
approaches have tried. Documentation generators like Doxygen, Javadoc, Pandoc,
and more take a code-centric view of the problem. Typically, they work by having
natural-language descriptions and/or explanations written as specially delimited
comments in the code which are later automatically compiled into a
human-readable document.

While these approaches definitely have their place and can come in quite handy,
they do not solve the underlying redundancy problem. The developers are still
forced to manually write descriptions of systems in both code and comments.
They also do not generate all software artifacts - commonly they are used to
generate only API documentation targeted towards developers or user manuals.

We propose a new framework, Drasil, alongside a knowledge-centric view of
software, to help take advantage of inherent redundancy, while avoiding manual
duplication and syncronization problems. Our approach looks at what underlies
the problems we solve using software and capturing that "common" or "core"
knowledge. We then use that knowledge to generate our software artifacts, thus
gaining the benefits inherent to the generation process: lack of manual
duplication, one source to maintain, and 'free' traceability of information.

-- Scope --
We are well aware of the ambitious nature of attempting to solve the problem of
manual duplication and unnecessary redundancy across all possible software
systems. Frankly, it would be highly impractical to attempt to solve such a
broad spectrum of problems. Each software domain poses its own challenges,
alongside specific benefits and drawbacks. With that in mind, we have decided to
focus solely on scientific computing (SC) software. Specifically, we look at
software that follows the pattern 'input -> process -> output'.

SC software has a strong fundamental underpinning of well-understood concepts.
It also has the benefit of seldomly changing, and when it does, existing models
are not necessarily invalidated. For example, rigid-body problems in physics are
well-understood and the underlying modeling equations are unlikely to change.
However, should they change, the current models will likely remain as good
approximations under a specific set of assumptions. For instance, who hasn't
heard 'assume each body is a sphere' during a physics lecture?

-- Roadmap? --

==Background==
*TBD see 'OLD STUFF' for ideas

== A look under the hood - Our process ==
  **Section roadmap:
    - We break down our artifacts to see commonalities
    - Summarize and extract patterns
    - Patterns inform a fluid organization of knowledge
    - Organizing the knowledge gives us structure
      (Templates + quasi-knowledge-base)
    - Structure gives us a starting point (Seeds of the Drasil framework)
                                            |-> HA
    - Next section -> Growing Drasil. (Because it came into being organically!)

The first step in removing unnecessary redundancy is identifying exactly what
that redundancy is, and where it exists. To that end we need to understand what
each of our software artifacts is attempting to communicate, who their audience
is, and what information can be considered boilerplate versus system-specific.
  **NOTE: in the breakdown make sure to mention "We actually found that some
  info is boilerplate, some is system-specific, and some is general to all
  members of a software family, but more specific than generic boilerplate"
  **NOTE: Also ensure each artifact has a 'who' (audience), 'what' (problem
  being solved), and 'how' (specific-knowledge vs boilerplate)
Luckily, we have an excellent starting point thanks to the work of many smart
people - artifact templates.

Lots of work has been done to specify exactly what should be documented in a
given artifact in an effort for standardization. Ironically, this has led to
many different 'standardized' templates. However, through the examination of a
number of templates for different artifact types, we have concluded they convey
roughly the same overall information for a given artifact. Most differences are
stylistic or related to content organization, as we will demonstrate in the 
following sections.
--Or naming conventions

Once we understand our artifacts, we take a practical, example-driven approach
to identifying redundancy through the use of existing software system case
studies. For each of these case studies, we start by examining the source code
and existing software artifacts to understand exactly what problem they are
trying to solve. From there, we attempt to distill the system-specific knowledge
and generalize the boilerplate.

-- A (very) brief introduction to our case study systems --
  [ Potentially canibalize the intro from the next section to specify the
    templates in use, so it doesn't seem to come out of nowhere.
    
    Summarize the following:
      -- Case study name
      -- Problem being solved
      -- Appendices containing artifacts? -- May come in handy for examples
  ]
  
To simplify the process of identifying redundancies and patterns, we have chosen
case studies developed using common artifact templates, specifically those 
used by [SmithEtAl] [source]. Also, as mentioned in [SCOPE], we have chosen
software systems that follow the 'input' -> 'process' -> 'output' pattern.
These systems cover a variety of use cases, to help avoid over-specializing into
one particular system-type. 

This section is meant to be used as a high-level reference to each case study, 
providing the general details at a glance. For the specifics of each system, 
all relevant case study artifacts can be found in the appendices.

** Should this be a table / series of cards?
 | Case Study Name: GlassBR
 | 
 | Problem being solved: We need to efficiently and correctly predict whether a 
 | glass slab can withstand a blast under given conditions.
 | 
 | Relevant artifacts in Appendix [A_GLASSBR]

 | Case Study Name: SWHS
 | 
 | Problem being solved: Solar water heating systems incorporating phase change 
 | material (PCM) use a renewable energy source and provide a novel way of 
 | storing energy. A system is needed to investigate the effect of employing PCM
 | within a solar water heating tank. 
 | 
 | Relevant artifacts in Appendix [A_SWHS]
 
 | Case Study Name: NoPCM
 | 
 | Problem being solved: Solar water heating systems provide a novel way of 
 | heating water and storing renewable energy. A system is needed to investigate
 | the heating of water within a solar water heating tank.
 | 
 | Relevant artifacts in Appendix [A_NoPCM]

 | Case Study Name: 
 | 
 | Problem being solved: 
 | 
 | Relevant artifacts in Appendix [A_]


--Breaking down artifacts--
As noted earlier, for our approach to work we must understand exactly what each
of our artifacts are trying to say and to whom. Since we are taking a practical,
example-driven approach to our process, we have specifically chosen our case
studies from software systems that were developed using common artifact
templates. Specifically the templates used by [SmithEtAl] [source].

To start, we look at the Software Requirements Specification (SRS). The SRS
(or some incarnation of it) is one of the most important artifacts for any
software project as it specifies what problem the software is trying to solve.
There are many ways to state this problem, and [SmithEtAl] have given us a
strong recommendation of what to use as a starting point in their template.
[Figure] shows the table of contents for an SRS using the [SmithEtAl] template.

[Figure showing the ToC of SmithEtAl template]

With the structure of the document in mind, let us look at several of our case
studies' SRS documents to get a deeper understanding of what each section truly
represents. [Figure] shows the first section of [one/several of our case studies, rest in Appendices].
[ The case studies themselves will be introduced in more detail in later sections, but
keep in mind at this point, we don't care about the superficial differences. -- Not exactly true if we introduce them in previous section ]
 We are strictly looking for patterns! Patterns will give us insight
into the root of *what* is being said in each section.

[Figure showing the Ref Section of at least 3 (preferably 4-6) case studies, may
need to be split into multiple, or have them somehow cropped/overlayed/arranged
to be not terrible to look at - TBD]

Looking at the Table of Symbols, Table of Units, and Table of Abbreviations and 
Acronyms from [Previous Figure] we can see that, barring the table values 
themselves, they are almost identical. The Table of Symbols is simply a table 
of values, essentially akin to a glossary, specific to the symbols that appear 
throughout the rest of the document. For each of those symbols, we see the 
symbol itself, a brief description of what that symbol represents, and the units
it is measured in (if applicable). Similarly, the Table of Units lists the
Système International d’Unités (SI) Units used throughout the document, their
descriptions, and the SI name. Finally, the table of Abbreviations and Acronyms
merely lists the abbreviations and their full forms, which are essentially the
symbols and their descriptions.

- Practical approach to design
- Let's use some case studies
- Understanding what's really going on

-- Artifact Summary --

See Table [NUM] for a summary of each software artifact's 'what', 'who', and
'how'.

*TABLE*
| Artifact | Who (Audience) | What (Problem) | How (Specific vs boilerplate) |

-- Patterns and repetition and patterns and repetition -- (OR -- Repeating patterns and patterns that repeat --)
From the above sections, we see many emerging patterns in our software
artifacts. Ignoring, for now, the organizational patterns from the [SmithEtAl]
templates we can already see simple patterns emerging. For example, we see the
same concept being introduced in multiple areas within a single artifact and
across artifacts in a project. [Example from one of the figures in the previous
section. Preferably something like a DD or TM that shows up within a single doc
multiple times]. We also see patterns of commonality across software family
members (The SWHS and NoPCM case studies) as they have been developed to solve
similar, or in our case nearly identical, problems.

- inter-project (repetition throughout different views + other patterns.)
  vs intra-project knowledge (repetition across projects/family memebers,
  minor modifications, but fundamentally the same + other patterns.)
- Hint at chunkifying/parceling out the fundamental (system/view-agnostic)
knowledge vs the specific knowledge

-- Organizing knowledge - a fluid approach --
  **Subsec roadmap:
    - We see the patterns above, we can generalize a lot of that
    - Direct repetition (copy-paste) vs indirect repetition (view-changes)
    require us to pull together knowledge from all artifacts into one place
    - Some can be derived automatically, the rest must be explicitly stated
    - We need to create a categorization system (hint at chunks) that is both
    robust and extensible to cover a wide variety of use cases.
    - Finally the templates give us structure

  **NOTE: Under the hood section should explain the process of how we determined
  what we needed to do. What we ended up doing should come in the following
  section(s) - no 'real' implementation details, only conceptual stuff here.
  
-- The seeds of Drasil --
  **Subsec roadmap:
    -- Summarize the above subsections and lead into next section
    -- Add relevant information that doesn't quite fit above 
      and isn't implementation related
    -- 'Relevant buckshot section'

== Welcome to Drasil ==
  **Section Roadmap:
    -- This is where the real meat of Drasil is discussed (implementation details)
    -- Intro to our knowledge-capture mechanisms
      - Chunks/hierarchy
      - Break down each with examples from the case studies.
      - Look for 'interesting' examples (synonyms, acronyms, complexity, etc.)
    -- Intro to the DSL
      - Captured knowledge is useless without the transformations/rendering engine
      - DSL for each softifact
      
== ??? ==
== ??? ==

== Results ==

-- Usability --

One of Drasil's biggest issues is that of usability. Unless one reads the source
code or has a member of the Drasil team working with them, it can be incredibly
difficult, or even impossible, to create a new piece of software in Drasil.

As seen in the examples from [SECTION], while the recipe language is fairly
readable, the knowledge-capture mechanisms are arcane and determining which
knowledge has already been added to the database can be very difficult. As our
living knowledge-base expands, this will become even more difficult,
particularly for those concepts with many possible names.

== Future Work ==

Development of Drasil is ongoing and the framework is still being iterated upon
to date. In this section we present areas we believe have room for improvement
along with plans for additional features to be added in the long-term.

-- Usability --
As mentioned in the results section, usability remains a great area for
improvement for Drasil. Work to create a visual front-end for the framework
has been planned and we hope to eventually get to the point of usability being
as simple as drag-and-drop or similar mechanisms.

Work on usability will address each of the core areas of development with
Drasil: knowledge-capture of system-agnostic information,
knowledge-capture of system-specific information, and recipe creation and
modification.


%%%%%%%%%%%%%%%%%%%%%% END CURRENT DOC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
============================== Notes ===========================================
Things I want to touch on
  - Synonyms can cause headaches, especially if they're not caught / curated into
  the right part of the KB.
  
===============OLD STUFF (Not part of current paper yet)========================
JC: I will put my comments inline below, but with all lines prefixed with JC.
DS: Responses to comments/questions will be prefixed with DS.

==Background==
-- Software Artifacts --

- Here we give a list of what we mean when we refer to all software artifacts.
  Brief description of each and their audience (in terms of stakeholders?).
  - Requirements
    - All stakeholders - What problem are we solving?
    - What do we need to do?
  - Design
    - All stakeholders
      - business - budget concerns;
      - technical - implementation/platform concerns
    - How are we going to do it?
  - Build instructions
    - For the machine
    - How to build the software from source
  - Implementation
    - For the machine
    - What is built/ what is the system doing?
  - Implementation guide
    - For the humans
    - What did we actually build?
  - Test plan
    - For the humans
    - How do we test it?
  - Test results (?)
    - For the humans
    - How did our tests go?
  - User guide
    - For the humans
    - How do you use the software?
  - ... {Let's figure out all the ones we agree on}

-- Software Re-Use and Software Families --

        - We want to see more software re-use, but the reality is its often
          faster (or cheaper) to re-develop a particular tool, algorithm, etc.
          rather than find an existing project to adapt
            (re-word previous, it's not quite what I want to say)
JC: Good point. Leads to justification for 'knowledge capture' via current
  artifacts of SE
JC: perhaps not being the 'right' ones. Some libraries (and frameworks) have had
  huge success
JC: regarding re-use, while others have flopped completely. No obvious trend.
        - Significant efforts can be made to develop a software variant that is
        very similar to an existing project
          - These variants are members of the same software family, typically
          with minor changes
JC: need to be more concrete. The linux kernel here is an interesting example -
  it is a huge software family. No one really knows which of the variants
  actually work!
DS: That's a great example.
            - Can happen when it seems easier to create a new variant as a
              stand-alone rather than attempt to update old code and docs
            - Also influenced by lack of documentation around existing software,
              confusing APIs, lack of subject-matter-experts, etc.
JC: Do you have citations to back that up? Proper science needs its citations.
DS: Yes, just need to re-find them.

-- Literate Programming --
- Fairly code-centric view as mentioned in intro. Lots of examples
    (wiki: Comparison of documentation generators)
- One source, multiple views.
- Somewhat redundant b/c of natural-language descriptions + code.

-- Generative Programming --


== Understanding Commonality and the source of redundancy==
- Breakdown our process of working through each of the case studies and
developing our "common" / "core" knowledge for each example.
- Breakdown the process of working through each case study and developing the
"recipe" for each artifact.

== Drasil ==
  - Drasil is a framework we've developed for generating *ALL* software
  artifacts (in their desired format) from a single source using transformations
  and projections.
      - Core knowledge (not system-specific) is reusable inter- and
        intra-project
      - No manual duplication - reduced redundancy.
      - Consistent by construction

    - Leveraged our understanding of generative software & software development
    principles and practices in dev
    - Development of Drasil has been practical and example-driven
    - Guiding principle: If software artifacts are views of the same
    information, we should be able to abstract out the core knowledge, then
    generate the views as necessary
      - Remove the need for manual duplication
      - Use transformations to format knowledge appropriately
        - Ex. Code-views vs. document-views of calculations
        look very different, even across similar languages, but say the
        same thing
          - Figure: A calculation in C# code, python code, LaTeX, and HTML
      - Ensure consistency & traceability
JC: agreed on all points above (leveraged ... here).

    - "Recipes" used to create our views, can be thought of as "little programs"
    that assemble our artifacts.
      - Based off of document templates, and similar to code templating, but
      much broader configuration scope(or something?)
    - Includes KC mechanisms for creating a 'living database' of common
    information
JC: not sure about mentioning KC *here*. Agree that it is part of our ideas.
DS: KC was just being used as a descriptor, doesn't need to be here.
      - Currently hand-curated
      - Expands as needed, all projects share it
      - Very low-level, system-specific information stored elsewhere to avoid
        pollution
        - Easy to move around if determined to be 'general-enough' for the
        common knowledge base (KB)
    - Captured knowledge acts as a uniform source for artifact generation
    - Structure of a project in Drasil can be broken down (generally) as:
      [Core knowledge], [Specific knowledge], & [Recipes]
JC: on Recipes and 'living database': this is all true, and important. But I am
  not quite "feeling it" as far as how/when to say this.
DS: This is where I'm explaining the key parts of our design/impl.
DS: It's as good a place as any to introduce the concepts. We can get into more
DS: detail later on.

  - What Drasil isn't
    - Not the be-all, end-all of software development
    - Only useful (and useable) in well-understood domains
      - We need to know how to capture and structure knowledge effectively
        - Ex. Science/math
    - One tool with a specific set of possible outputs and limited scope
    - Will not replace human developers, only help remove some of the tedium of
      following good software development practices
    - Not complete - Dev is still in progress
JC: Right. We don't want to over-emphasize, but do want to say.

  - Our examples - SWHS, GlassBR, SSP, Gamephys, Tiny, and NoPCM
    - Drove our practical approach
    - All re-developed to follow the SmithEtAl artifact templates using modern
    SE approaches
      - Gives us consistent views
        - Knowledge is easier to extract
        - We know what we want the generator to create from our Recipes
        - Gives a base structure to our recipes
JC: Right.
    - SWHS and NoPCM are software family members
      - Model solar water heating sys with/without phase change material (PCM)
    - GlassBR
      - Models whether glass panes will break due to force of explosions
    - SSP
      - Models slope stability
    - Gamephys
      - Reduced-scope section of the Chipmunk2D game physics engine
      - Simulates rigid-body physics
    - Tiny
      - Toy example taken from a model of a fuel-pin in a nuclear reactor
      - Used for proof of concept mainly, and as a test case to ensure
      updates to Drasil don't create any unwanted behaviours
    - Examples share common baseline math/science knowledge
      - Gives us a starting point for the common KB
JC: Right.
