\chapter{Build System}\label{bs}
%\section{More Automation!}\label{bsFraming}

\autoref{ci} and \autoref{dl} both had the potential to effect (and did) how SRS documents are laid out and rendered. We are required to build\ \LaTeX\ into a Portable Document Format (PDF) file to verify expected visual changes to the\ \LaTeX\ produced by Drasil. Drasil generates a Makefile for each\ \LaTeX\ artefact produced to aid in compiling them. While Drasil produces these Makefiles, there is no mechanism in the central Drasil Makefile to generate a PDF file for each SRS artefact produced by Drasil within the bundled examples. As such, compiling\ \LaTeX\ is often a task not performed by developers when contributing changes as they would be required to enter (up to) seven folders and individually build each PDF file. It is not certain if any contributor to Drasil regularly builds\ \LaTeX\ files into PDFs, as there have been at least two separate occasions where the generated\ \LaTeX\ has failed to compile for over one month at a time. 

Drasil containing broken artefact generation, which effects bundled examples for over a month at a time, is unacceptable. One reason is because it reflects poorly on Drasil and the developers, another because it adds complications for users wishing to investigate and evaluate Drasil. A more important technical reason: the bundled Drasil examples act as a set of test cases for Drasil. The artefacts generated by Drasil are compared (using \texttt{diff}) against a known ``good" output. If there are differences between the compared artefacts, the reviewer of the change is expected to ensure the changes are desirable. If the changes are desirable, they become the new ``good" output. Nowhere in the process do we ensure the artefacts (\LaTeX\ or otherwise) build properly. Reviewers typically rely on language knowledge to visually verify any changes are correct; we never enforce that the artefacts are built before changes are integrated. While authors (including the author of this report) are supposed to verify artefacts build, it seems unlikely that any regular developer of Drasil ever builds the artefacts as demonstrated by the prolonged periods of time to detect\ \LaTeX\ errors. By providing a top-level Makefile target to build all\ \LaTeX\ (and other artefacts) we would lower the tedium required to verify generated artefact changes in an effort to reduce the time between a produced artefact being invalid and when it is discovered as invalid. Further, a convenient, consistent, and reliable method for producing artefacts may be useful in a continuous integration and deploy setting (as discussed in \autoref{contInt}) to ensure artefacts shown are continually up to date.

\section{Leveraging Makefile Primitives}\label{bsRefactor}

%Unfortunately the syntax of make is more verbose than the Haskell we have included snippets from up to now. We begin by examining some Makefile variables at the top of the %Makefile:%
%
%\begin{tcolorbox}
%\begin{minted}{makefile}
%TINY_PREF  = Tiny_
%GLASS_PREF = GlassBR_
%NoPCM_PREF = NoPCM_
%...
%
%TINY_DIR  = Tiny
%GLASS_DIR = GlassBR
%NoPCM_DIR = NoPCM
%...
%\end{minted}
%\end{tcolorbox}
%
%Based on the snippet provided, the difference between the value of \mintinline{makefile}{_PREF} and \mintinline{makefile}{_DIR} variables of the same prefix is an underscore %is appended to the \makefile{_DIR} value to obtain the \makefile{_PREF} value. We could simply use the \makefile{_DIR} value anywhere the \makefile{_PREF} value is used and %instead add a literal \makefile{_} to obtain the correct value without requiring such duplication. We have yet to examine the uses of \makefile{_PREF} variables which may %spoil our plans.
%
As has been performed in \autoref{ci} and \autoref{dl}, we begin by examining the existing implementation and surrounding code. The first set of targets we encounter when examining the central Drasil Makefile are the ones to build the sub-packages of Drasil:

\begin{tcolorbox}
\begin{minted}{makefile}
build: FORCE
	stack install -j2 $(stackArgs) drasil-lang

build_code: build
	stack install -j2 $(stackArgs) drasil-code

build_print: build_code
	stack install -j2 $(stackArgs) drasil-printers

build_gen: build_print
	stack install -j2 $(stackArgs) drasil-gen

...
\end{minted}
\end{tcolorbox}

\bash{stack}, officially named ``The Haskell Tool Stack," is a build system for Haskell\footnote{\url{https://haskellstack.org}}. The command \bash{stack install} installs built programs and libraries, transparently invoking \bash{stack build} if any transitive dependencies have \linebreak changed since the last build. The \bash{FORCE} target is one that ensures Make\footnote{Drasil uses GNU Make (\url{https://www.gnu.org/software/make/}), which is the common \bash{make} program on both macOS and Linux.} will always rebuild a target when invoked.

Most of the body of the displayed rules is duplicated. The difference between \bash{stack install -j2 $(stackArgs) drasil-lang} and \bash{stack install -j2 $(stackArgs) drasil-code} is the remainder of the sub-package name after \textit{drasil-}. If we were to abstract the rules such that the sub-package name (the part after \textit{drasil-}) was the suffix to \bash{build_} we would be closer to creating a generic rule.% Performing the change to the existing build rules yields:

%\begin{tcolorbox}
%\begin{minted}{makefile}
%build_lang: FORCE
%	stack install -j2 $(stackArgs) drasil-lang
%
%build_code: build_lang
%	stack install -j2 $(stackArgs) drasil-code
%
%build_printers: build_code
%	stack install -j2 $(stackArgs) drasil-printers
%
%build_gen: build_printers
%	stack install -j2 $(stackArgs) drasil-gen
%
%...
%\end{minted}
%\end{tcolorbox}

Another observation arising from the Makefile snippet is the dependencies. By specifying a single dependency to each \bash{build_} rule, we serialize the build such that only one package is compiling at any time. As an example, \textit{drasil-code} and \textit{drasil-printers} do not depend on each other and could be built simultaneously given enough processing power. If we were to properly track sub-package dependencies to use in rules we may lose opportunities for abstraction. As mentioned previously, \bash{stack} performs dependency and transitive dependency management for us! If we invoke \bash{stack install drasil-example}, \bash{stack} would notice \textit{drasil-example} has not been built and attempt to build it. When attempting to build \textit{drasil-example}, \bash{stack} may notice that its dependencies have not been built or are out-of-date and attempt to build those first. \bash{stack}'s dependency management means we are able to remove the target dependencies and simplify the set of Makefile rules into a single rule:

\begin{tcolorbox}
\begin{minted}{makefile}
build_%: FORCE
	stack install -j2 $(stackArgs) drasil-$*
\end{minted}
\end{tcolorbox}

In Make, \bash{%} is a wildcard character (for rules) matching anything and \bash{$*} is an automatic Makefile variable that expands to the string matched by \bash{%}.\footnote{\url{https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html}} For example, if we invoke Make with \bash{make build_lang}, \bash{$*} will expand to \bash{lang} in the above rule.

While this rule achieves the desired level of abstraction there are outstanding issues. First, this rule will match \textit{any} such string after \bash{build_}, for example, \bash{make build_foo} will attempt to build the Drasil sub-package \textit{drasil-foo}, which does not exist. Make supports filtering wildcard rules to restrict the targets \bash{build_%} will invoke. Syntactically \bash{filter} prefixes each target with: \bash{$(filter build_%, <whitelist>):} where the first argument is the pattern to match and the second argument is the whitelist of valid values for the pattern match. We describe a \bash{WHITELIST} consisting of all valid targets (i.e. \bash{build_lang}, \bash{build_code}, etc) as a starting point. This is less than ideal, we still have to write out \bash{build_} for every sub-package target. What if we extend the abstraction another layer by defining a list of sub-packages and building the list of targets from that list? That would give reuse for any other rules that act upon different sub-packages as well.

\begin{tcolorbox}
\begin{minted}{makefile}
PACKAGES = lang code printers gen ...
BUILD_P_SUFFIX = _build
BUILD_PACKAGES = $(addsuffix $(BUILD_P_SUFFIX), $(PACKAGES))
\end{minted}
\end{tcolorbox}

We split the \bash{WHITELIST} variable into three to compartmentalize data while ensuring consistency in the event of changes. The \bash{PACKAGE} variable describes the name of all sub-packages, \bash{BUILD_P_SUFFIX} describes a suffix to be used for build rules --- we have switched \bash{build_} rules to \bash{_build} rules to make the Makefile target formatting consistent with other rules already present in the Makefile --- and \bash{BUILD_PACKAGES} creates target names by appending the \bash{BUILD_P_SUFFIX} to each space-separated item in \bash{PACKAGES}. If a new sub-package is added to Drasil, the only line in the Makefile requiring a change is \bash{PACKAGES}.

Using the variables defined, we refine the Makefile target to:

\begin{tcolorbox}
\begin{minted}{makefile}
$(filter %$(BUILD_P_SUFFIX), $(BUILD_PACKAGES)): \ 
  %$(BUILD_P_SUFFIX): FORCE
	stack install -j2 $(stackArgs) "drasil-$*"
\end{minted}
\end{tcolorbox}

The backslash (in the above snippet) is added to indicate line continuation of the target specification. We have quoted the \bash{"drasil-$*"} fragment to ensure any character escaping performed by a user to encode a particular character is properly passed to \bash{stack} allowing \bash{stack} to decide whether the character can be part of a valid package name. 

Finally, we address the target dependency \bash{FORCE}, defined as: \makefile{FORCE: ;}, and why it is sub-optimal. Due to \bash{FORCE} being a target that does nothing, there is no file ever created by Make with the name ``FORCE" effectively forcing Make to attempt to rebuild it, and any rules that transitively depend on it, each time \bash{make} is invoked. If a file were ever created with the name ``FORCE" then this would break the functionality desired of the \bash{FORCE} target. Make contains a special target that provides the functionality desired of \bash{FORCE} without being a ``hack." The special target is \bash{.PHONY}. The \bash{.PHONY} target ensures files with the same name as a target do not prevent the accompanying rule from being executed and hints to Make that the rule does not produce a file of the same name. We can remove the \bash{FORCE} target and add \bash{BUILD_PACKAGES} to \bash{.PHONY} to achieve the same functional result:

% I'm calling this "done" for this rule. I've left out a few things, but they're less impressive. I am going to talk about -Wall and -Werror though!
% Like I kind of ignore -j flag to both stack and ghc as that's parallelism related and not super interesting
\begin{tcolorbox}
\begin{minted}{makefile}
$(filter %$(BUILD_P_SUFFIX), $(BUILD_PACKAGES)): \ 
  %$(BUILD_P_SUFFIX):
	stack install -j2 $(stackArgs) "drasil-$*"

.PHONY: $(BUILD_PACKAGES)
\end{minted}
\end{tcolorbox}

\subsection{Examining Sub-package Compilation in Depth}\label{bsRefactorCI}

Over the course of working on Drasil, developers have unintentionally left code that resulted in compiler warnings when building sub-packages. While this can be considered ``only compiler noise," it is rather inconsiderate to commit code to the Drasil repository that introduces warnings. Because warnings are not critical and can be ignored, having any when compiling code results in additional warnings from further changes being less noticeable and thus less likely to be detected and corrected. In the Drasil repository there are at least six separate instances where warning removal was the sole reason for making changes to the codebase. 

Drasil uses TravisCI\footnote{https://travis-ci.org} (Travis) to build Drasil whenever changes are made, commonly called \textit{Continuous Integration} (CI). Any time a contributor to Drasil would like to have their proposed changes integrated into the main codebase, they produce a ``pull request" (PR). Contributors assign a core Drasil member, or supervisor to review the changes. Travis builds user's changes to Drasil any time they update their work on GitHub --- where Drasil's code repository lives --- in addition to when they produce a pull request. 

We can leverage the CI infrastructure currently in place to indicate to reviewers whether changes introduce warnings to Drasil by specifying the \linebreak\bash{-Werror} flag to the Haskell compiler. The \bash{-Werror} flag treats any warning as an error and halts the compilation process, marking the build on Travis as a failure, which propagates feedback to GitHub and displays it to the user. The easy way to achieve such a result is to add \bash{-Werror} to the \bash{stack install} command specified in the rule we refactored. Specifying it there may fail local builds as developers are actively working on changes to Drasil. Enabling \bash{-Werror} locally adds friction to a Drasil contributor's workflow. For example, if a maintainer is in the process of moving code around to realize a better structure or solution, the build may fail for a file including an import that is not necessary at the moment. Such a failure locally can distract a developer and result in a train-of-thought loss. Therefore, \bash{-Werror} should only be enforced when code has been contributed for review to ensure the developer has not introduced any warnings after their change has been completed. As a further step to increase code quality, we wish to enable the flag \bash{-Wall}, indicating to the compiler to turn on all (common and stable) warnings when building the Haskell code. 

We begin by locating the appropriate place to add the \bash{-Wall} flag. To specify the flag in the \bash{stack install} command, through \bash{stackArgs}, we must wrap it in another parameter indicating flags to pass to the Glasgow Haskell Compiler (\bash{ghc}), named \bash{--ghc-options}. While an excellent start, to add \linebreak\bash{-Werror} to the command line as we plan to do on Travis, we would have to write \bash{make stackArgs="--ghc-options=-Werror"}. Specifying \bash{-Werror} in this way is rather clunky and overwrites any \bash{stackArgs} we specify by default in the Makefile (i.e. \bash{-Wall} to \bash{--ghc-options}). Instead we expose another Make variable, \bash{GHCFLAGS}, which stores the default options and provides a more convenient specification location for \bash{ghc} flags to users:

\begin{tcolorbox}
\begin{minted}{makefile}
override GHCFLAGS += -Wall

$(filter %$(BUILD_P_SUFFIX), $(BUILD_PACKAGES)): \ 
  %$(BUILD_P_SUFFIX):
	stack install -j2 $(stackArgs) \
	--ghc-options="$(GHCFLAGS)" "drasil-$*"
\end{minted}
\end{tcolorbox}

The \bash{GHCFLAGS} variable simplifies the CI invocation to \bash{make GHCFLAGS=}\linebreak\bash{-Werror}. The uncommon syntax for the \bash{GHCFLAGS} variable ensures the \bash{-Wall} flag is added to any existing \bash{GHCFLAGS} value. The \bash{override} directive is so the \bash{-Wall} value is appended even though the variable was initially set on the command line (or in the environment). Make's default behaviour is to ignore setting variables with values defined in the Makefile if the value was previously set on the command line.\footnote{\url{https://www.gnu.org/software/make/manual/make.html\#Override-Directive}} 

Both \bash{-j2} and \bash{--ghc-options} are arguments to \bash{stack} and thus \bash{stackArgs}, we should be consistent and provide the same treatment to \bash{stackArgs} as \bash{GHCFLAGS} yielding defaults for \bash{stackArgs}:

\begin{tcolorbox}
\begin{minted}{makefile}
override stackArgs += -j2 --ghc-options="$(GHCFLAGS)"
\end{minted}
\end{tcolorbox}

%\begin{tcolorbox}
%\begin{minted}{makefile}
%override GHCFLAGS += -Wall
%override stackArgs += -j2 --ghc-options="$(GHCFLAGS)"
%
%
%$(filter %$(BUILD_P_SUFFIX), $(BUILD_PACKAGES)): \ 
%  %$(BUILD_P_SUFFIX):
%	stack install $(stackArgs) "drasil-$*"
%\end{minted}
%\end{tcolorbox}

The introduction of \bash{-Wall} and \bash{-Werror} (on TravisCI) have raised the bar for Drasil code quality. The arguments added to GHC ensures all common warnings are brought to developers' attention and no warnings exist before code is merged into the main Drasil repository.

\subsection{A Pattern of Makefile Targets}\label{bsRefactorEnd}

We perform similar refactoring for other Makefile rules present in the central Drasil Makefile, matching them to the build targets. In particular, we examine the rules involved with generating example binaries and running them to produce their artefacts. These rules exhibit slightly different requirements than those of the build rules. We begin by examining (a subset of) the current generation targets:

% Author Note: I'm skipping changing the suffix and adding it here because it was nothing and really adds nothing
\begin{tcolorbox}[breakable, toprule at break=0pt, bottomrule at break=0pt]
\begin{minted}{makefile}
hghc_gen: example_build
	mkdir -p build/$(HGHC_DIR)
	cd build/$(HGHC_DIR) && \
	stack exec -- $(HGHC_EXE) $(EXECARGS)

glassbr_gen: hghc_gen
	mkdir -p build/$(GLASS_DIR)
	cd build/$(GLASS_DIR) && \
	stack exec -- $(GLASS_EXE) $(EXECARGS)

nopcm_gen: glassbr_gen
	mkdir -p build/$(NoPCM_DIR)
	cd build/$(NoPCM_DIR) && \
	stack exec -- $(NoPCM_EXE) $(EXECARGS)
\end{minted}
\end{tcolorbox}

The \bash{_gen} targets suffer from many of the same problems as the sub-package \bash{_build} targets! A problem arises attempting to mimic the pattern of \bash{_build} rules: each example rule retrieves a different set of variables to determine properties about itself. To address this, we take advantage of the way Makefile variables work. As a demonstration, if we have a variable \linebreak\bash{A = FOO} and another variable \bash{FOO_BAR = BAZ}, then evaluating the following substitution: \bash{$($(A)_BAR)} first expands \bash{A}; the substitution becomes \linebreak\bash{$(FOO_BAR)}. \bash{FOO_BAR} is then expanded to become \bash{BAZ}. We can use the planned target pattern match (hghc, glassbr, etc) for the \bash{_gen} rule to ``lookup" the correct value for a given variable suffix using nested expansion. To start, we rename the variables to be all uppercase and character-consistent with the target pattern match (\bash{NoPCM} becomes \bash{NOPCM} and \bash{GLASS} becomes \bash{GLASSBR}). %With the renaming performed, we follow a similar form as the \makefile{_build} targets:

% \begin{tcolorbox}
% \begin{minted}{makefile}
% EXAMPLES = hghc glassbr nopcm ...
% GEN_E_SUFFIX = _gen
% GEN_EXAMPLES = $(addsuffix $(GEN_E_SUFFIX), $(EXAMPLES))
% 
% $(filter %$(GEN_E_SUFFIX), $(GEN_EXAMPLES)): \
%   %$(GEN_E_SUFFIX): example$(BUILD_P_SUFFIX)
% 	mkdir -p build/$($(shell echo $* | tr a-z A-Z)_DIR)
% 	cd build/$($(shell echo $* | tr a-z A-Z)_DIR) && \
% 	stack exec -- \
% 	$($(shell echo $* | tr a-z A-Z)_EXE) $(EXECARGS)
% \end{minted}
% \end{tcolorbox}

The next step is translating pattern matches to uppercase to parallel the variable convention used in the Makefiles. Make allows for invoking shell commands as part of variable expansion meaning we are able to use the Unix command \bash{tr}. \bash{tr} allows for translating groups of characters, supporting ranges for compact syntax. Using standard input as the input to \bash{tr}, we express the desired translation to uppercase as \bash{tr a-z A-Z}, where the output is printed to standard out. 

Similar to what was performed for \bash{_build} targets, we use the automatic Makefile variable \bash{$*} --- containing the matched part of \bash{%} --- in the refactoring of the \bash{_gen} rules. In this instance, we do not quote the variable as it does not map to a ``real" object, unlike \bash{_build} targets, which may contain a space. In \bash{_gen} targets, the example name is only used for variable ``lookups" and the target itself. We opt to ignore space as a valid character as we do not see a case where a contributor to the Makefile would want a target with a space in the name. Allowing spaces exposes the contributor to a multitude of problems with escaping and ``fixing up" spaces for values in various places. Consider the omission of space support to be a simplifying assumption, if anything.

Lifting the \bash{tr} command into a sub-shell executed by the Makefile is done as: \bash{$(shell echo $* | tr a-z A-Z)}. In an effort to avoid copy-pasting and re-executing the translation anywhere a variable lookup is required, we can leverage target-specific variables. A target-specific variable is a variable that is only defined when the target is invoked --- thus we have special variable \bash{$*} available --- and in any dependencies required by the target. Combining target-specific variables, pattern matching, automatic variables, and nested expansions, we can produce a compact, generic rule.

The rule includes the path \bash{build/}. As a final step, we abstract the path \bash{build/} to a Makefile variable as it may be useful for other rules interacting with the artefacts. The benefit of a variable should be obvious: we can change the path of the artefacts and only require the modification of a single line in the Makefile.

% where \bash{tr} substitutes characters matched from the first argument to the one at the same index in the second argument. \bash{tr a-z A-Z} transforms a string to all uppercase. A note of interest with the \makefile{_gen} targets: we do not quote \makefile{$*} as it never maps directly to a Drasil artefact like the \makefile{_build} targets do. In \makefile{_gen} targets, the name is only used for variable lookups and the target itself, as such we opt to ignore it as we do not see a case where a contributor to the makefile would want a target with a space in the name and expose themselves  and thus require altering it to some other character with \bash{tr}.

%While our targets have been condensed in a similar manner, the \makefile{$(shell echo $* | tr a-z A-Z)} written multiple times is less than ideal. To address this repetition, we can introduce a target-specific variable. A target-specific variable is a variable which is only defined when the target is invoked (and thus we have special variable \makefile{$*} available). We defined a target-specific variable, \makefile{EXAMPLE}, as:

%\begin{tcolorbox}
%\begin{minted}{makefile}
%%$(GEN_E_SUFFIX): EXAMPLE=$(shell echo $* | tr a-z A-Z)
%$(filter %$(GEN_E_SUFFIX), $(GEN_EXAMPLES)): \
%  %$(GEN_E_SUFFIX): example$(BUILD_P_SUFFIX)
%	mkdir -p build/$($(EXAMPLE)_DIR)
%	cd build/$($(EXAMPLE)_DIR) && \
%	stack exec -- $($(EXAMPLE)_EXE) $(EXECARGS)
%\end{minted}
%\end{tcolorbox}

% We are getting somewhere! We still have to perform multiple substitutions to look up the variable of interest. We can simply use more target-specific variables!

%\begin{tcolorbox}
%\begin{minted}{makefile}
%%$(GEN_E_SUFFIX): EXAMPLE=$(shell echo $* | tr a-z A-Z)
%%$(GEN_E_SUFFIX): EDIR=$($(EXAMPLE)_DIR)
%%$(GEN_E_SUFFIX): EEXE=$($(EXAMPLE)_EXE)
%$(filter %$(GEN_E_SUFFIX), $(GEN_EXAMPLES)):\
%  %$(GEN_E_SUFFIX): example$(BUILD_P_SUFFIX)
%	@mkdir -p build/$(EDIR)
%	cd build/$(EDIR) && stack exec -- $(EEXE) $(EXECARGS)
%\end{minted}
%\end{tcolorbox}
%
%There are two remaining changes to enact for this target template. The first is to make the build folder name a variable making it easier to change with other targets. The second is to quote uses of variables representing filenames or paths in the event they are modified to include a space:

All of the changes to the \bash{_gen} rules results in:

\begin{tcolorbox}
\begin{minted}{makefile}
BUILD_FOLDER = build/

%$(GEN_E_SUFFIX): EXAMPLE=$(shell echo $* | tr a-z A-Z)
%$(GEN_E_SUFFIX): EDIR=$($(EXAMPLE)_DIR)
%$(GEN_E_SUFFIX): EEXE=$($(EXAMPLE)_EXE)
$(filter %$(GEN_E_SUFFIX), $(GEN_EXAMPLES)):\
  %$(GEN_E_SUFFIX): example$(BUILD_P_SUFFIX)
	@mkdir -p "$(BUILD_FOLDER)$(EDIR)"
	cd "$(BUILD_FOLDER)$(EDIR)" && stack exec -- \
	"$(EEXE)" $(EXECARGS)
\end{minted}
\end{tcolorbox}

With the completion of the \bash{%_gen} targets, we have examined all the tricks required to refactor the remaining Makefile rules used in Drasil into a more sensible, generic state. 
% Numbers were pulled from
% Before: https://github.com/JacquesCarette/Drasil/blob/1b6d64d71a2313052737d388642ee0c1ef00d904/code/Makefile
% After being current master only counting Makefile lines of targets present in Before BUT including all variables to properly handle the current lines.
In the process of refactoring the Makefile we reduced it from 178 lines to 80 lines. We also enforced, within the central Drasil repository, that changes must not introduce warnings when building Drasil or its bundled examples. The result is a cleaner codebase and more correct code through, for example, not allowing functions that only perform partial pattern matches. Further, we have begun encoding Drasil structural and layout information within the Makefile, making the Makefile a knowledge store for build-related information, which we will leverage in subsequent sections.

% Current has 28 Lines of commments, if we remove that we have 209 total lines - 28 = 181 = 3 lines more than what we started with with a BUNCH of other targets

\section{Batch\ \LaTeX\ Compilation}\label{bsTex}

We have examined how the central Drasil Makefile works (refactored and abstracted too); we can begin designing a new target template to invoke each example's\ \LaTeX\ Makefile. To begin, we require a suffix for the template rule, we use \bash{%_tex}. As for dependencies of the target, we require that the example being compiled has had its artefacts generated (\bash{%$(GEN_E_SUFFIX)}). 

Constructing the command run when the target is invoked, we examine what is required to build the\ \LaTeX: change to the directory of the Makefile constructed to build the\ \LaTeX\ and invoke it. These simple requirements work when invoked from an interactive terminal, but encounters a limitation when invoked on TravisCI. An issue occurs when \bash{lualatex} --- the supported\ \LaTeX\ compiler used by Drasil due to its support of Unicode literals --- encounters an error in the\ \LaTeX; \bash{lualatex} stops the build and queries the user for input on how to proceed. When run as part of an automated process, particularly when running on TravisCI, if compiling\ \LaTeX\ fails, the build will hang waiting for user input. The \bash{lualatex} documentation reveals that passing the argument \bash{--interaction=nonstopmode} will cause \bash{lualatex} to exit when an error is encountered instead. 

We can piece together a command to execute within Make as: 

\begin{tcolorbox}
\begin{minted}{bash}
cd $(BUILD_FOLDER)$(EDIR)/SRS/} && \
$(MAKE) TEXFLAGS="--interaction=nonstopmode"
\end{minted}
\end{tcolorbox}

\bash{$(EDIR)} is assumed to be defined as a target-specific variable (similar to how it was with \bash{_gen}), \bash{$(MAKE)} is an implicit Makefile variable pointing to the path of the \bash{make} binary, and \bash{TEXFLAGS} is a variable exposed by the generated\ \LaTeX\ Makefiles as a way to specify variables to \bash{lualatex}.

% As such we update the command in the makefile target:
% 
% \begin{tcolorbox}
% \begin{minted}{bash}
% cd $(BUILD_FOLDER)$(EDIR)/SRS/ && \
% $(MAKE) TEXFLAGS="--interaction=nonstopmode"
% \end{minted}
% \end{tcolorbox}
% 
% where \makefile{TEXFLAGS} is a variable exposed by the generated SRS makefile of arguments to pass to \bash{lualatex}.

An issue with the existing command line is TravisCI only pretty-prints the first ten thousand lines of terminal output on any particular build before truncating the output.\ \LaTeX\ builds tend to produce a large amount of text during each invocation. The final invocation of \bash{lualatex} for one bundled Drasil example produces 1753 lines of output with multiple invocations occurring to find the fixpoint of the generated PDF. Why are we concerned with the output of \bash{lualatex} when building\ \LaTeX\ on TravisCI? We would like to capture any error messages in the event compiling a PDF --- referred to as ``the build" for the rest of this section --- fails.

As it happens, if one invocation of \bash{lualatex} fails, no further invocations of \bash{lualatex} will occur for the document. We are only interested in the output of the final invocation of \bash{lualatex} for any particular bundled example. \bash{lualatex} produces a \bash{.log} file whenever invoked overwriting the file if it already exists. We are able to leverage this behaviour to extract the last invocation! As for silencing the terminal output, \bash{lualatex} provides another interaction mode, \bash{batchmode}, which stops executing on error like \bash{nonstopmode}, but also suppresses printing the output. It may be convenient to specify whether to print to standard output or only to the log from the central Drasil Makefile without requiring the user to understand the (not so clear in our opinion) nuance of \bash{nonstopmode} and \bash{batchmode}. We expose this through the Makefile variable \bash{SUMMARIZE_TEX}, set to display the output by default.

%We begin to implement the refined ideas as a shell script invoked through the makefile in order to avoid having to newline escape the embedded shell script. We name the variable controlling the verbosity of the output \bash{SUMMARIZE_TEX}:

%\begin{tcolorbox}
%\begin{minted}{bash}
%if [ "$SUMMARIZE_TEX" = "yes" ]; then
%  IMODE=batchmode
%else
%  IMODE=nonstopmode
%fi
%
%GEN_NAME_SUFFIX=_SRS
%
%cd "$BUILD_FOLDER$EDIR"/SRS/
%"$MAKE" TEXFLAGS=--interaction="$IMODE"
%RET=$?
%
%if [ "$SUMMARIZE_TEX" = "yes" ]; then
%  echo "\n\n\033[0;33m$EDIR TeX Summary\033[0m:"
%  if [ "$RET" -ne 0 ]; then
%    cat "$EDIR$GEN_NAME_SUFFIX".log
%  fi
%  echo ""
%fi
%exit $RET
%\end{minted}
%\end{tcolorbox}
%
%where \bash{$?} is an implicit bash variable containing the return value of the most recently run process. The strings \bash{\033[0;33m} and \bash{\033[0m} are (rather convoluted) commands to change the text output to yellow and ``back to default" respectively around a heading indicating which log file is being printed for ease of visual scanning. \makefile{GEN_NAME_SUFFIX} encodes information about how Drasil (specifically the bundled examples) name the generated\ \LaTeX\ SRS documents. In its current formulation, only if the build fails will any\ \LaTeX\ log information be emitted in an effort to further conserve terminal line use.

We briefly switch focus to \bash{bibtex}, the program responsible for compiling the\ \LaTeX\ bibliography information. The generated Makefiles ignore the return code of \bash{bibtex} as an empty file will trigger a build failure. Specifically, one of Drasil's bundled examples does not contain any bibliography information by design. We wish to keep the command line output of \bash{bibtex} to a minimum and check the log generated for errors. \bash{bibtex} supports a \bash{-terse} flag to reduce the amount of output generated, which would be useful to specify if \bash{SUMMARIZE_TEX} is set to \bash{yes}. 

In an effort to catch possible errors from a \bash{bibtex} invocation, we look for the string ``error" in the produced log file. If it is found, we fail the build. While possibly not exhaustive, all observed \bash{bibtex} errors emit a message containing the string ``error" to the log file. Similar to how we try to detect error messages in \bash{bibtex} logs, we should perform a comparable action for \bash{lualatex} invocations. \bash{lualatex} invocations have not been observed to exit with a non-zero exit code in undesirable circumstances; thus, we examine the \bash{lualatex} logs for warnings instead. To our knowledge, \bash{lualatex} warnings contain no discernible, consistent format to easily extract; hence, we look for the following strings in the log file if \bash{lualatex} exits successfully and was invoked with \bash{SUMMARIZE_TEX} set to \bash{yes}: ``warning" and ``erfull." Like \bash{bibtex}, the two strings match all instances of warnings currently observed. ``erfull" may seem like an odd warning match; however, it matches\ \LaTeX\ warnings of the form ``\{und,ov\}erfull \{h,v\}box," indicating content may appear off-screen or in an unexpected manner.

% when they do not fail as there may be warnings about undefined references or overfull and underfull boxes which may be of interest to viewers. 

% Include filtering erros for bibtex and then doing the same for latex
%We realize this as:

% \begin{tcolorbox}
% \begin{minted}{bash}
% if [ "$SUMMARIZE_TEX" = "yes" ]; then
%   IMODE=batchmode
%   BIFLAGS=-terse
% else
%   IMODE=nonstopmode
% fi
% 
% GEN_NAME_SUFFIX=_SRS
% 
% cd "$BUILD_FOLDER$EDIR"/SRS/
% "$MAKE" TEXFLAGS=--interaction="$IMODE" \
% BIBTEXFLAGS="$BIFLAGS"
% RET=$?
% 
% if [ "$SUMMARIZE_TEX" = "yes" ]; then
%   echo "\n\n\033[0;33m$EDIR TeX Summary\033[0m:"
%   if [ "$RET" -eq 0 ]; then
%     cat "$EDIR$GEN_NAME_SUFFIX".blg | grep -B3 -E "Error"
%     BIBERRS=$(cat "$EDIR$GEN_NAME_SUFFIX".blg | \
%       grep -E "Error" | wc -l)
%     if [ "$BIBERRS" -gt 0 ]; then
%       RET=1
%     fi
%   else
%     cat "$EDIR$GEN_NAME_SUFFIX".log
%   fi
%   echo ""
% fi
% exit $RET
% \end{minted}
% \end{tcolorbox}

%where \bash{BIBTEXFLAGS} is a variable exposed by the generated\ \LaTeX\ makefiles to specify argument to \bash{bibtex}. On top of indicating to \bash{bibtex} to be more terse, we check the generated log for instance of the word ``Error" and fail a build intentionally if it is exists in the log as it likely is an error message. The \bash{-B3} argument to \bash{grep} prints the three lines before any line containing ``Error" in an effort to provide additional context to any error messages encountered. 

%We realize this addition as:

% \begin{tcolorbox}
% \begin{minted}{bash}
% if [ "$SUMMARIZE_TEX" = "yes" ]; then
%   IMODE=batchmode
%   BIFLAGS=-terse
% else
%   IMODE=nonstopmode
% fi
% 
% GEN_NAME_SUFFIX=_SRS
% 
% cd "$BUILD_FOLDER$EDIR"/SRS/
% "$MAKE" TEXFLAGS=--interaction="$IMODE" \
%   BIBTEXFLAGS="$BIFLAGS"
% RET=$?
% 
% if [ "$SUMMARIZE_TEX" = "yes" ]; then
%   echo "\n\n\033[0;33m$EDIR TeX Summary\033[0m:"
%   if [ "$RET" -eq 0 ]; then
%     # Approximate error gathering from TeX logs.
%     cat "$EDIR$GEN_NAME_SUFFIX".log | \
%       grep -E "erfull|Warning"
%     cat "$EDIR$GEN_NAME_SUFFIX".blg | grep -B3 -E "Error"
%     BIBERRS=$(cat "$EDIR$GEN_NAME_SUFFIX".blg | \
%       grep -E "Error" | wc -l)
%     if [ "$BIBERRS" -gt 0 ]; then
%       RET=1
%     fi
%   else
%     cat "$EDIR$GEN_NAME_SUFFIX".log
%   fi
%   echo ""
% fi
% exit $RET
% \end{minted}
% \end{tcolorbox}

To reiterate, the generated PDFs produced from Drasil artefacts can either all be built sending the log output to standard out unedited or they can all be invoked in a more terse fashion. When \bash{SUMMARIZE_TEX} is set to \bash{yes} in the central Drasil Makefile, \bash{lualatex} and \bash{bibtex} omit printing any full logs to standard out. If \bash{lualatex} exits with an error, the log file is printed to standard out. If the \bash{bibtex} log contains the string ``error," the build fails. If an example produces a complete PDF, we scrape the \bash{lualatex} log for any warnings and display them on standard out. 

We implement this logic, to build and validate the output of a single generated PDF, in a shell script. We chose a shell script rather than producing it all under the \bash{_tex} rule template to avoid requiring `\textbackslash' at the end of each line to indicate to Make the next line is a continuation of the same command, as would be necessary in a (pretty-printed) inline shell script. We invoke the shell script from the central Drasil Makefile in the template rule \bash{_tex}. We achieve the goal of building all PDF artefacts by adding a target \bash{tex}, whose dependencies are all the \bash{_tex} targets.

%With this final modification our work on the script to invoke the makefile of a particular SRS and adapt the output for TravisCI, we turn back to the central Drasil makefile to connect the targets to the shell script:

% \begin{tcolorbox}
% \begin{minted}{makefile}
% %$(TEX_E_SUFFIX): EXAMPLE=$(shell echo $* | tr a-z A-Z)
% %$(TEX_E_SUFFIX): EDIR=$($(EXAMPLE)_DIR)
% $(filter %$(TEX_E_SUFFIX), $(TEX_EXAMPLES)): \
%   %$(TEX_E_SUFFIX): %$(GEN_E_SUFFIX)
% 	EDIR="$(EDIR)" BUILD_FOLDER="$(BUILD_FOLDER)" \
% 	SUMMARIZE_TEX=$(SUMMARIZE_TEX) MAKE="$(MAKE)" \
% 	"$(SHELL)" "$(SCRIPT_FOLDER)"tex_build.sh
% 
% tex: $(TEX_EXAMPLES)
% \end{minted}
% \end{tcolorbox}
% 
% where the variable assignment prior to \bash{"$(SHELL)"} export the variables such that the shell script has them in scope, \bash{$(SHELL)} is an environment variable containing the path to the user's preferred terminal binary, and \bash{"$(SCRIPT_FOLDER)"tex_build.sh} is the path to the shell script we created with \bash{$(SCRIPT_FOLDER)} being a variable defined in the makefile abstracting the location of all build-related shell scripts.

Finally, we enable building of all\ \LaTeX\ artefacts on Travis by adding the following line to Drasil's CI configuration: \bash{make tex SUMMARIZE_TEX=yes}.

With the addition of a fifty line shell script (which includes checks to ensure variables expected to be passed from the Makefile are in scope) and six lines in the central Drasil Makefile, we created a single rule that will compile the\ \LaTeX\ for all bundled examples. The single target for producing SRS PDFs for all bundled examples reduces the effort a contributor must exert to verify changes to the\ \LaTeX\ output. As a bonus, we have accommodated the limitations of TravisCI to enable the building of\ \LaTeX\ whenever a contributor makes a change to Drasil. With the enforcement that changes to Drasil must generate\ \LaTeX\ that compiles, we have further increased the quality and reliability of Drasil. Gone are the days of wondering if the\ \LaTeX\ will compile when contributors must look at the generated PDFs. The emission of warnings on Travis (when the\ \LaTeX\ compiles) unexpectedly uncovered three incorrect references within the examples bundled with Drasil, which were remedied shortly after their discovery.


\section{Compiling Generated Code}\label{bsCode}

The other type of artefact Drasil generates is implementations of the software system in one or more of: \CC, C\#, Python, or Java. In a similar manner to the\ \LaTeX\ artefacts, Drasil does not ensure the code compiles as part of the continuous integration process. The generated code is in a worse place than the generated\ \LaTeX, as no Makefile is generated to accompany the code. We begin by adding support to Drasil to generate a Makefile for each generated implementation.

\subsection{\textit{drasil-build}}\label{bsDrasilBuild}

Before investigating the existing Makefile generation facilities present within Drasil, we should specify the high-level design of the Makefile we aim to generate. The default target for the Makefile should only compile the code into a binary. For a language like Python, which does not require compilation, the default target should be a no-op. The default target's name should be the filename of the binary being generated. The dependencies to the compilation target, if not a no-op, should be all source files Drasil generates for a given implementation. The command executed in the rule should invoke the compiler with either the file containing the main method (like in Java), or specify all generated (source) files (like for C\# and \CC). Further, some compilers may require specifying the name of the output file (like \CC~with the \bash{-o} flag). We wrap the target filename in another target, named \bash{build}, to maintain a consistent ``address" for building a generated implementation regardless of implementation details.

The second target contained in the Makefile is \bash{run}. The \bash{run} target abstracts away the generated binary name and possibly associated interpreter (Java and Python) to create a simple interface for running an implementation regardless of language. The only dependency for the target is any binary built with the \bash{build} target. The examples bundled with Drasil require an input file specified when invoking the built program necessitating a free variable, which is set when \bash{make run} is invoked. 

Piecing these features together yields a Makefile with format:

\begin{tcolorbox}
\begin{minted}{makefile}
build: <binary name>

<binary name>: <generated files>
	<compiler> <compiler arguments>

run: build
	<interpreter> <binary name> $(RUNARGS)
\end{minted}
\end{tcolorbox}

\bash{$(RUNARGS)} is the free variable to be parameterized with input files, such as \bash{make run RUNARGS=input.txt}.

To begin implementing these Makefiles, we start by examining how the\ \LaTeX\ artefacts construct their Makefiles. We trace the existing Makefile generation for\ \LaTeX\ to a small block of code in \textit{drasil-printers}:

% I omitted the cases for MG and MIS because they're not terribly relevant and would only add an expository tangent.
\begin{tcolorbox}
\begin{minted}{haskell}
makeRule :: DocSpec -> [Rule]
makeRule (DocSpec SRS fn)     = 
  [(Phony, "srs", [fn ++ ".pdf"]), (TeX, fn, [])]
makeRule (DocSpec Website _)  = []
\end{minted}
\end{tcolorbox}

\haskell{"srs"} is the rule name and \haskell{fn} is the filename as a \haskell{String}. The Makefile generation occurs within \textit{drasil-printers}:

\begin{tcolorbox}
\begin{minted}{haskell}
printRule :: Rule -> Doc
printRule (Phony, nameLb, deps) =
  text (".PHONY: " ++ nameLb) $+$ printTarget nameLb deps
printRule (TeX, nameLb, _) = 
  printTarget (nameLb ++ ".pdf") [(nameLb ++ ".tex")] $+$
  printLatexCmd nameLb
\end{minted}
\end{tcolorbox}

The operator \haskell{$+$} combines fragments with a certain formatting implemented by \haskell{Text.PrettyPrint}~\cite{Hughes95thedesign}.

The Makefile generation system in place for the\ \LaTeX\ SRS documents is quite inadequate for code generation Makefiles. One large issue is its residence in \textit{drasil-printers}. Having \textit{drasil-code} depend on \textit{drasil-printers} for Makefile generation capabilities does not make sense and entangles the two unrelated sub-packages, increasing their coupling. Further, Makefile generation is not \haskell{Document} generation and, thus, does not belong in \textit{drasil-printers}; however, it does not belong in \textit{drasil-code} as a Makefile is not a (reasonable) form of code generation. It lies closer to a language for build generation. The logical choice is to migrate Makefile functionality to a new sub-package: \textit{drasil-build}, a sub-package for generating build systems. While we will only implement Makefile in \textit{drasil-build} for this report, the sub-package could be extended to accommodate other build systems as well.

The other issue with the current Makefile generation routines is the deep knowledge encoded. The \haskell{TeX} constructor encodes a \haskell{Type} that the Makefile generator ``knows about," including what commands to emit to satisfy (or build) the \haskell{Type}. An (unimplemented) \haskell{Type} is \haskell{CCode}, which would emit the correct commands to build a piece of C language code. This embedding of knowledge is a bad idea. We must maintain a list of \haskell{Type}s outside of the relevant \haskell{Document} or code generation implementations; thus, sprinkling knowledge around the codebase, introducing opportunities for changes to ``miss" updating build commands. With the movement of the Makefile generation functions to \textit{drasil-build}, this spread knowledge further indicates \haskell{Type} is a bad idea due to requiring modification of \textit{drasil-build} with implementation of a new language in \textit{drasil-code} or document language in \textit{drasil-printers}.

We begin by migrating the existing Makefile generation routines to \textit{drasil-build}. We briefly recall \autoref{bsRefactor} to reinforce the effort we exerted to refactor the central Drasil Makefile. Adding a new sub-package to the central Makefile, we only modify a single line:

\begin{tcolorbox}
\begin{minted}{makefile}
PACKAGES = lang code printers gen build ...
\end{minted}
\end{tcolorbox}

That is it. The text \bash{build} is all that is required to add support for \textit{drasil-build} to any package target template within the Makefile.

We begin by moving most of the existing Makefile generation to \textit{drasil-build}. In the process we encounter a \textit{drasil-build} function calling \textit{drasil-printers}' \haskell{makeRule}:

\begin{tcolorbox}
\begin{minted}{haskell}
genMake :: [DocSpec] -> Doc
genMake = build . toMake

toMake :: [DocSpec] -> Makefile
toMake rl = M $ makeRules rl

makeRules :: [DocSpec] -> [Rule]
makeRules l = concatMap makeRule l
\end{minted}
\end{tcolorbox}

The notion of \haskell{DocSpec} (a \textit{drasil-printers} concept) is embedded in the type of \haskell{genMake}, \haskell{toMake}, and \haskell{makeRules}. Makefile generation embeds document generation concepts much more than we thought. We aim to keep the same structure for generating the Makefile by instead calling \haskell{genMake} with \textit{some} type that can be transformed into a list of \haskell{Rule}s, while leaving the transformation up to the sub-package implementing the type. A typeclass addresses both issues! We introduce a \haskell{RuleTransformer} typeclass where any data structure implementing it contains a function \haskell{makeRule} to generate a set of rules from the structure! Updating \textit{drasil-build} yields:

\begin{tcolorbox}
\begin{minted}{haskell}
class RuleTransformer c where
  makeRule :: c -> [Rule]

genMake :: RuleTransformer c => [c] -> Doc
genMake = build . toMake

toMake :: RuleTransformer c => [c] -> Makefile
toMake rl = M $ makeRules rl

makeRules :: RuleTransformer c => [c] -> [Rule]
makeRules l = concatMap makeRule l
\end{minted}
\end{tcolorbox}

Updating \haskell{DocSpec} to implement \haskell{RuleTransformer} in \textit{drasil-printers} yields:

\begin{tcolorbox}
\begin{minted}{haskell}
instance RuleTransformer DocSpec where
  makeRule (DocSpec SRS fn) = 
    [(Phony, "srs", [fn ++ ".pdf"]), (TeX, fn, [])]
  makeRule (DocSpec Website _)  = []
\end{minted}
\end{tcolorbox}

The typeclass, \haskell{RuleTransformer}, begins the process of making \textit{drasil-build} target-language agnostic. The idea is to make \textit{drasil-build} only concerned with exposing high-level build system concepts, which \haskell{RuleTransformer} instances can use to produce a set of \haskell{Rule}s that \textit{drasil-build} can further transform into Makefile fragments. 

With the addition of \textit{drasil-build} and coupling between \textit{drasil-code} and \textit{drasil-printers} being avoided, we should continue the effort of abstracting Makefile generation constructs by discerning high-level build system concepts to replace the \haskell{TeX} and \haskell{CCode} embedding from \textit{drasil-build}. We begin by designing a \haskell{mkRule} function. The function should implement encoding of entire Makefile rules of the form:

\begin{tcolorbox}
\begin{minted}{makefile}
target: dependency1 dependency2
	command1
	command2

.PHONY: target
\end{minted}
\end{tcolorbox}

We explicitly specify the \bash{.PHONY} target in the minimal example as \haskell{mkRule} should create abstract rules, something similar to a function and not a file. \haskell{mkRule} should take a name for the target, as well as a list of targets and files as dependencies. Finally, it should take a list of command line commands. The type signature for such a function being:

\begin{tcolorbox}
\begin{minted}{haskell}
mkRule :: Target -> Dependencies -> [Command] -> Rule
\end{minted}
\end{tcolorbox}

To compliment \haskell{mkRule} we create another function, \haskell{mkFile}, taking the same arguments, but whose target is a file to be created.

The next functions to create are those of commands. While the signatures will be simple, we include two functions providing slightly differing behaviour. The first is \haskell{mkCommand}, which represents a terminal command to invoke, the exit code will be ignored. The other is \haskell{mkCheckedCommand}, which ensures the return value of the command is zero.

Before we describe the signatures for the command functions, we ought to discuss how we define and use Makefile variables within the existing constructs, as well as how to interpolate them into plain text (\haskell{String}). Due to the relaxed syntactic constructs in the Make ``language," many items are string literals with variable expansion mixed in to provide an abstraction and configuration mechanism. For the purpose of this report, we consider \haskell{Target}s, \haskell{Dependencies} and \haskell{Command}s to be string literals with variables intermixed as required. To realize this within \textit{drasil-build} we construct a simple monoid, \haskell{MakeString}, which ``extends" string literals with a variable type:

\begin{tcolorbox}
\begin{minted}{haskell}
data MakeString = Mr String -- String
  | Mv MVar  -- Variable
  | Mc MakeString MakeString -- Append
\end{minted}
\end{tcolorbox}

% with an infix concatenation operator \haskell{+:+} defined as:
% 
% \begin{tcolorbox}
% \begin{minted}{haskell}
% (+:+) :: MakeString -> MakeString -> MakeString
% a +:+ (Mr "") = a
% (Mr "") +:+ b = b
% a +:+ b = a <> Mr " " <> b
% \end{minted}
% \end{tcolorbox}

\haskell{MVar} is a data structure encoding (some of) the types of variables. The first type included is implicit variables, where variables are defined implicitly by Make --- such as \bash{CC} for the C compiler path. The second type is free variables, variables that have no value by default but can be specified through the environment or command line, if these values are unset, Make's implicit value for these is the empty string. An example of a free variable within the Makefile format we are targeting is \bash{RUNARGS}. The final type required for the code Makefiles is an ``operating system" variable, providing semantics of how the variable is set by default. An ``operating system" variable sets its default value based on the system where the Makefile is invoked. An example of this type of variable, as could be used in the generated code Makefiles, is indicating the binary file extension based on the operating system. We realize \haskell{MVar} as:

\begin{tcolorbox}
\begin{minted}{haskell}
type VarName = String
type VarVal = String

data MVar = Os VarName VarVal VarVal VarVal
  | Implicit VarName
  | Free VarName
  deriving Eq
\end{minted}
\end{tcolorbox}

The first value to \haskell{Os} is Windows, second is macOS, and third is Linux. 

% We provide ``smart" constructors for the constructors of \haskell{MVar} (promoting it to \haskell{MakeString}) and \haskell{MakeString} as:
% 
% \begin{tcolorbox}
% \begin{minted}{haskell}
% makeS :: String -> MakeString
% makeS = Mr
% 
% mkWindowsVar :: VarName -> VarVal -> VarVal -> MakeString
% mkWindowsVar n w e = Mv $ Os n w e e
% 
% mkImplicitVar :: VarName -> MakeString
% mkImplicitVar = Mv . Implicit
% 
% mkFreeVar :: VarName -> MakeString
% mkFreeVar = Mv . Free
% \end{minted}
% \end{tcolorbox}

% We elide the code to render \haskell{MakeString} to \haskell{String} as it is trivial.

The specification of \haskell{MakeString} allows us to return to defining the Makefile constructs at the rule level. We realize the \haskell{Command} structure --- which captures semantics about those executed in a Makefile --- where a command itself is encoded as a \haskell{MakeString} to support variable expansion as provided by Make. We include a field in \haskell{Command} to capture whether to check the exit value of a command. The structure, \haskell{CommandOpts}, is expected to be used for flags that can be set together (through a list) indicating properties about the command's invocation. In this report we only provide a single constructor, \haskell{IgnoreReturnCode}, as that is the only ``flag" required in the Makefiles Drasil generates at present.

%\begin{tcolorbox}
%\begin{minted}{haskell}
%data Command = C MakeString [CommandOpts]
%
%data CommandOpts =
%  IgnoreReturnCode deriving Eq
%\end{minted}
%\end{tcolorbox}

The definitions for \haskell{mkCommand} and \haskell{mkCheckedCommand} differ in whether the \haskell{IgnoreReturnCode} flag is set in the \haskell{CommandOpts} field of the \haskell{Command}. 

We define \haskell{Rule} in a similar way to \haskell{Command}, including collections of \haskell{MakeString} with an argument specifying the type of target:

\begin{tcolorbox}
\begin{minted}{haskell}
type Target = MakeString
type Dependencies = [Target]

data Type = Abstract
  | File deriving Eq

data Rule = R Target Dependencies Type [Command]
\end{minted}
\end{tcolorbox}

The definitions of \haskell{mkFile} and \haskell{mkRule} follow from \haskell{Rule} and \haskell{Type}.

The design choices made thus far, including how Makefile rules are encoded, require us to deconstruct the \haskell{Rule}s to correctly create the Makefile. We must extract the ``operating system" variables from the \haskell{Rule}s and define them in the preamble of the Makefile. We must also extract \haskell{Rule}s that are \haskell{Abstract} to properly encode them as \bash{.PHONY}. Further, as much of the encoding of Makefile rules has changed, we no longer require specifying the ``type" of rule, such as \haskell{TeX} or \haskell{CCode}. The language combinators in \textit{drasil-build} are expressive enough to allow the ``types" to be encoded in the appropriate sub-packages.

%\begin{tcolorbox}
%\begin{minted}{haskell}
%printRule :: Rule -> Doc
%printRule (R t d _ c) = printTarget t d $+$ (printCmds c)
%
%printCmd :: Command -> Doc
%printCmd (C c opts) = text $
%  (if IgnoreReturnCode `elem` opts then "-" else "") ++ c
%\end{minted}
%\end{tcolorbox}
%
%where \haskell{printCmds} simply maps each \haskell{Rule} over \haskell{printCmd}.
%
%The function \haskell{printPhony} extracts all \haskell{Abstract} \haskell{Rule}s and generates a \makefile{.PHONY} rule:
%
%\begin{tcolorbox}
%\begin{minted}{haskell}
%printPhony :: [Rule] -> Doc
%printPhony = (<+>) (text ".PHONY:") . hsep .
%  map (\(R t _ _ _) -> text t) .
%  filter (\(R _ _ t _) -> t == Abstract)
%\end{minted}
%\end{tcolorbox}
%
%where \haskell{<+>} is a \haskell{Text.PrettyPrint} operator to concatenate two \haskell{Doc}s with a horizontal space between them, and \haskell{hsep} is the \haskell{mconcat} to \haskell{<+>}'s \haskell{mappend} from the \haskell{Monoid} typeclass.

%The other function of interest is \haskell{addCommonFeatures}, in the previous iteration of the makefile generator it simply included a hardcoded blob of text setting the executable extension to \texttt{.exe} and the removal binary to \bash{del} on Windows. With the support for operating system variables we are able to de-embed this chunk and include only defined operating system variables, where if none are defined, the preamble is omitted. We realize this change with:

% \begin{tcolorbox}
% \begin{minted}{haskell}
% addCommonFeatures :: [Rule] -> Doc -> Doc
% addCommonFeatures r m = osDefinitions (filter isOsVar $
%   uniqueVars $ concatMap extractVars r) $+$ m
% 
% osDefinitions :: [MVar] -> Doc
% osDefinitions [] = empty
% osDefinitions m = ...
% \end{minted}
% \end{tcolorbox}

% where the second argument to \haskell{addCommonFeatures} is the body of the makefile, \haskell{uniqueVars} deduplicates any variables with the same name, ensuring their definitions are consistent, and \haskell{osDefinition} constructs the preamble which has been mostly elided for the purposes of this report as it still contains nine lines of ``boilerplate" to properly define the OS variables.

The new Makefile generation language forces us to revisit and update the \haskell{RuleTransformer} instance for \haskell{DocSpec}. Due to effort invested to de-embed the \haskell{TeX} and \haskell{CCode} \haskell{Type}s from \textit{drasil-build}, the description of the Makefile rules includes more lines of code, but more accurately reflects the information \textit{drasil-printers} \textit{should} be encoding to describe how to build its generated\ \LaTeX\ files, in a more appropriate location too.

% Simplified code a bit to make consistent with "Before" definition
\begin{tcolorbox}
\begin{minted}{haskell}
instance RuleTransformer DocSpec where
  makeRule (DocSpec Website _) = []
  makeRule (DocSpec SRS f) = [
    mkRule (makeS "srs") [pdfName] [],
    mkFile pdfName [makeS $ f ++ ".tex"] $
      map ($ f) [lualatex, bibtex, lualatex, lualatex]] where
        lualatex = mkCheckedCommand .
          (+:+) (makeS "lualatex" +:+ mkFreeVar "TEXFLAGS") .
          makeS
        bibtex = mkCommand . (+:+)
          (makeS "bibtex" +:+ mkFreeVar "BIBTEXFLAGS") .
          makeS
        pdfName = makeS $ f ++ ".pdf"
\end{minted}
\end{tcolorbox}

%where \haskell{lualatex} and \haskell{bibtex} define a command template which is parameterized.

The preceding block of code describes a Makefile with two rules, one abstract and one generating a PDF. Generating a PDF is performed by executing four commands in sequence. The encoding describes, and generates, the exact same Makefile as before, except removes the hardcoded operating system (OS) definition preamble. The omission of the OS preamble is due to \haskell{DocSpec}'s Makefile definition including no ``operating system" variables and thus the superfluous preamble was removed by improvements introduced in \textit{drasil-build}.

\subsection{A Higher-Level Specification for \textit{drasil-code}}\label{bsDCode}

The separation of \textit{drasil-build} from \textit{drasil-printers} revealed some deep embedding regarding types of targets that spawned a large re-design of the Makefile specification infrastructure. The re-design culminated in a more powerful, robust, and extensible language that we saw used to specify the Makefile format for \haskell{DocSpec}. We began this investigation of Drasil's Makefile generation facilities to add Makefile generation support to \textit{drasil-code}, but we have yet to do that. Let us re-examine the desired generated Makefile format:

\begin{tcolorbox}[breakable, toprule at break=0pt, bottomrule at break=0pt]
\begin{minted}{makefile}
build: <binary name>

<binary name>: <generated files>
	<compiler> <compiler arguments>

run: build
	<interpreter> <binary name> $(RUNARGS)
\end{minted}
\end{tcolorbox}

With the \haskell{RuleTransformer} typeclass we should introduce a data structure able to encode both build and run information for a given language and its produced executable. \textit{drasil-code} separates the renderer for each language into its own file and data structure. With the clear separation of implementation languages, it would be logical for each language's implementation to describe \textit{how} to build and run its produced binary. The encoding of build knowledge within each language does not make sense with the constructs provided by \textit{drasil-build}, rather \textit{drasil-code} should provide an interface on top of \textit{drasil-build} for individual languages to express build configurations. If we plan to expose an abstract interface for individual languages, we should gather the features required to express these configurations for \CC, C\#, Java, and Python. 

\CC~is a compiled language. Makefiles contain an implicit variable \bash{CXX}, which specifies the path to the default \CC~compiler on a system. The \CC~compiler expects all \texttt{.cpp} files when compiling a concrete executable (i.e. not an object or an executable derived from object files). The \CC~compiler expects the \bash{-o} flag to indicate the name of the output program; failure to provide a name will result in the compiler default name, typically \texttt{a.out}, being used. On Windows, we are required to include the \texttt{.exe} suffix to satisfy convention. As for running a binary produced from a \CC~compiler, they are typically invoked on the command line as \bash{./<binary name>} with \bash{./} indicating a binary in the current directory.

Describing the compiler syntax required for C\# is a little more complicated. Microsoft (the developer of C\#) maintains a compiler for the language, \bash{csc}, which was only available on Windows until 2017~\cite{Roslyn}. For macOS and Linux the C\# compiler is Mono Project's \bash{mcs} compiler (prior to the open-sourcing and inclusion of \bash{csc} into Mono). The infrastructure hosting Drasil's continuous integration process only supplies packages of Mono that contain \bash{mcs}; therefore the compiler for C\# effectively changes based on the operating system the Makefile is invoked on. \bash{csc} is strict about argument ordering requiring an output name to be specified prior to the input files, whereas \bash{mcs} does not care about argument ordering. Both compilers require specifying all source files when building a binary. The programs created by both compilers are native binaries that can be invoked as \bash{./<binary_name>}. Due to the generated binaries being native, we must account for the binary extension.
% https://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc
% Is it valid I mention that about CSC and mono? As far as I'm aware CSC was only on Windows, until Microsoft acquired them in 2016 and it was included in CSC in 2017. And Roslyn compiler wasn't open sourced until 2014 (https://en.wikipedia.org/wiki/Roslyn_(compiler)) which supported building via their repo and bootstrapping from Mono, but it appears mono 5 is the first release with it.

Java has a universally available compiler: \bash{javac}. The compiler only requires specification of the file containing the \mintinline{java}{main} method if the code is formatted as a package. Further, Java automatically generates the name of the output file as \texttt{<inputname>.class} without requiring any command line arguments to do so. Finally, Java code is invoked through an interpreter \bash{java} with the form \bash{java <package>.<inputname>}, omitting the \texttt{.class} file extension.

The final language to examine is Python. Python is an interpreted language requiring no ahead-of-time preparation for the interpreter. As such, a build configuration is not applicable. Running a Python program is done by specifying the interpreter and the file intended to be the entry point: \bash{python <inputname>.py}.

With only two ``ways" to run the generated binaries, we will begin designing the implementation for the \bash{run} target. We begin with a structure encoding the type of artefact produced by building the generated code. We name the structure \haskell{RunType}. If the runnable artefact is interpreted, we ought to have a field to specify the interpreter itself. Putting these pieces together we have:

\begin{tcolorbox}
\begin{minted}{haskell}
type CommandFragment = MakeString

data RunType = Standalone
  | Interpreter CommandFragment
\end{minted}
\end{tcolorbox}

Separately we ought to encode the \textit{name} of the file to run. For Python this is the main source file; Java includes the package name before the name of the main file. We encode this into a \haskell{BuildName} structure. We provide three constructors: \haskell{BMain}, \haskell{BPack}, and \haskell{BWithExt}. \haskell{BMain} represents the name (excluding extension) of the main file. \haskell{BPack} constructs a \haskell{BuildName} prefixed with the name of the software \textit{package} --- package being the \textit{drasil-code} nomenclature for the name of the software implementation, from the example in \autoref{teExample} this would be ``Double." \haskell{BWithExt} describes a \haskell{BuildName} with an extension matching that of the language's source file extension, which describes the input to the \bash{python} interpreter.

For both \CC~and C\#, the generated binary will be the package name followed by any required OS file extensions. We refine \haskell{BuildName} to be:

\begin{tcolorbox}
\begin{minted}{haskell}
data BuildName = BMain
  | BPackName
  | BPack BuildName
  | BWithExt BuildName Ext

data Ext = CodeExt
  OtherExt MakeString
\end{minted}
\end{tcolorbox}

\haskell{BPackName} is a base case variant representing the package name. \haskell{Ext}'s \haskell{CodeExt} constructor renders the extension of a language's source files --- like for the Python \bash{run} command --- and the \haskell{OtherExt} constructor encodes an arbitrary extension.

We tie both \haskell{BuildName} and \haskell{RunType} together with \haskell{Runnable}, adding a smart constructor, \haskell{nativeBinary}, encoding the semantics to run a native binary.

\begin{tcolorbox}
\begin{minted}{haskell}
data Runnable = Runnable BuildName RunType

nativeBinary :: Runnable
nativeBinary = Runnable (BWithExt BPackName $ OtherExt $
  osClassDefault "TARGET_EXTENSION" ".exe" "") Standalone
\end{minted}
\end{tcolorbox}

\haskell{osClassDefault} encodes a variable with two possible values: one if the operating system invoking the Makefile is Windows, the second if the operating system ``class" is Unix (macOS or Linux).

We provide two convenience functions for languages that produce an interpreted runnable artefact:

\begin{tcolorbox}
\begin{minted}{haskell}
type InterpreterCommand = String

interp :: BuildName -> InterpreterCommand -> Runnable
interp r i = Runnable r $ Interpreter i

interpMM :: InterpreterCommand -> Runnable
interpMM = Runnable (BWithExt BMain CodeExt) . Interpreter
\end{minted}
\end{tcolorbox}

The language data structure, \haskell{Config}, is extended to include a field \linebreak\haskell{runnable :: Runnable}. \CC~and C\# use \haskell{nativeBinary}, while Java uses \haskell{interp (BPack BMain) "java"}, and Python's \haskell{runnable} definition is \linebreak\haskell{interpMM "python"}, where the ``MM" is short for ``main module."

The final step to generate a \bash{run} target for the code implementations is to create a data structure to instantiate as a \haskell{RuleTransformer}. We create a structure, \haskell{CodeHarness}, which bundles together a language configuration as well as an ancillary \textit{drasil-code} structure, providing access to information to correctly render the Makefile structure described previously.

% \begin{tcolorbox}
% \begin{minted}{haskell}
% data CodeHarness = Ch Config Package
% \end{minted}
% \end{tcolorbox}
% 
% where the contents of \haskell{Package} and \haskell{Code} get in to implementation details of \textit{drasil-code} that is unrelated to this report.

% Commented out since this doesn't really add anything.
% \begin{tcolorbox}
% \begin{minted}{haskell}
% instance RuleTransformer CodeHarness where
%   makeRule (Ch c m) = [
%     mkRule (makeS "run") [makeS "build"] [
%       mkCheckedCommand $
%         buildRunTarget (renderBuildName c m nm) ty +:+
%         mkFreeVar "RUNARGS"
%     ]
%   ] where
%     (Runnable nm ty) = runnable c
% \end{minted}
% \end{tcolorbox}
%
%where \haskell{buildRunTarget} and \haskell{runBuildName} translate \haskell{Runnable} and \haskell{BuildName} into a command for use in the makefile. The definitions have been elided as they are not particularly interesting.

A \bash{build} target is the piece remaining to complete the code implementation Makefile generation routines. We begin by examining the Java compiler input and output in detail. The compiler takes as input the path to the main Java source file. Drasil generates Java code in a package (folder) that indicates a grouping to the \bash{javac} compiler. From the example in \autoref{teExample}, the Java input would be \bash{javac Double/Control.java} where \bash{Control.java} contains the code entry point. The output would be \bash{Double/Control.class}. The argument passed to the Java interpreter for \autoref{teExample} is \bash{java Double.Control}. The difference between the file output by \bash{javac} and \bash{java} is the folder separator and whether an extension is included. \haskell{BuildName} already has the capability to describe the output path and run path specified, however, that would require two separate paths describing the same \textit{thing}. Instead, we specify an ancillary record for name rendering options, \haskell{NameOpts}, providing context on \textit{how} to render the name according to these differences:

\begin{tcolorbox}
\begin{minted}{haskell}
data NameOpts = NameOpts {
  packSep :: String,
  includeExt :: Bool
}

nameOpts :: NameOpts
nameOpts = NameOpts {
  packSep = "/",
  includeExt = True
}
\end{minted}
\end{tcolorbox}

\haskell{packSep} indicates the separator character between a package and an inner \haskell{BuildName}. We further define \haskell{nameOpts} as a default instantiation describing the semantics of how a package is translated to a file path using `/' as a separator character. We adapt \haskell{Runnable} to take a \haskell{NameOpts} and modify \haskell{interp} to take a \haskell{NameOpts} as an argument.

%\begin{tcolorbox}
%\begin{minted}{haskell}
%data Runnable = Runnable BuildName NameOpts RunType
%
%interp :: RunName -> NameOpts ->
%  InterpreterCommand -> Runnable
%interp r n i = Runnable r n $ Interpreter i
%\end{minted}
%\end{tcolorbox}

The \haskell{runnable} field in the Java language \haskell{Config} becomes:

\begin{tcolorbox}
\begin{minted}{haskell}
runnable = interp (BWithExt (BPack BMain) $ OtherExt $
  makeS ".class") jNameOpts "java"

jNameOpts :: NameOpts
jNameOpts = NameOpts {
  packSep = ".",
  includeExt = False
}
\end{minted}
\end{tcolorbox}

The name specified to \haskell{Runnable} can be the target specified for the \bash{build} rule as a dependency and ensure consistency between \bash{build} and \bash{run}. Switching to the input specified to the Java compiler, the compiler requires a single file; the file is the one containing the Java \mintinline{java}{main} method. \haskell{BuildName} already contains the constructors to properly encode \bash{<package>/<main>.java}. 

We shift to compiling \CC. \CC~requires all input source files to be specified to the compiler. To specify a meaningful name (i.e. not \bash{a.out}) we are required to include \bash{-o} on the command line as well. The command line we are targeting for Drasil's \CC~Makefiles is: \bash{$(CXX) <file1>.cpp <file2>.cpp ... -o ./<package>$(TARGET_EXTENSION)}. The output filename has already been encoded in the \haskell{Runnable} structure. The inputs are more complicated than the Java compiler. It would be inconvenient and illogical to manually specify each \CC~source file to the compiler. The language implementation is not even aware of all the generated files! To accommodate the different styles of file inputs required to the compiler, we introduce the notion of \haskell{BuildDependencies}. The structure itself is relatively simple containing two cases; one describing the single input file case required by the Java compiler. The other case is including all source files:

\begin{tcolorbox}
\begin{minted}{haskell}
data BuildDependencies = BcSource
  | BcSingle BuildName
\end{minted}
\end{tcolorbox}

We can encode compiler inputs and \haskell{Runnable} encodes the name of the output (if it is an output), yet we cannot describe the compiler command including flags in a reasonable manner leveraging the \haskell{BuildDependencies} structure we created. Solving the problem introduces a structure, \haskell{BuildConfig}, taking a \haskell{BuildDependencies} and a function taking a list of input files and an output file as arguments and returns a complete compile command.

\begin{tcolorbox}
\begin{minted}{haskell}
type BuildCommand = [CommandFragment]

data BuildConfig = BuildConfig ([CommandFragment] ->
  CommandFragment -> BuildCommand) BuildDependencies
\end{minted}
\end{tcolorbox}

The C\# compiler command is not that different from the \CC~compiler. The C\# compiler takes all source files as input and requires the first argument be the output name. The compiler command for C\# looks similar to: \bash{$(CSC) -out:<package>$(TARGET_EXTENSION) <file1>.cs <file2>.cs ...} \linebreak\haskell{BuildConfig} supports all the necessary constructors to properly capture the command.

We perform a similar implementation to \haskell{runnable} and add a new field \haskell{buildConfig :: Maybe BuildConfig} to \haskell{Config}.

To save space, we show all convenience functions and the four implementation language's \haskell{buildConfig} below:

\begin{tcolorbox}[breakable, toprule at break=0pt, bottomrule at break=0pt]
\begin{minted}{haskell}
buildAll :: ([CommandFragment] -> CommandFragment ->
  BuildCommand) -> Maybe BuildConfig
buildAll = Just . flip BuildConfig BcSource

buildSingle :: ([CommandFragment] -> CommandFragment ->
  BuildCommand) -> BuildName -> Maybe BuildConfig
buildSingle f = Just . BuildConfig f . BcSingle

cppCompiler :: CommandFragment
cppCompiler = mkImplicitVar "CXX"

-- C#
buildConfig = buildAll $ \i o ->
  [osClassDefault "CSC" "csc" "mcs",
  makeS "-out:" <> o] ++ i

-- C++
 buildConfig = buildAll $ \i o -> cppCompiler : i ++
   map makeS ["--std=c++11", "-o"] ++ [o]

-- Java
buildConfig = buildSingle (\i _ -> asFragment "javac" : i) $
  BPack BMain

-- Python
buildConfig = Nothing
\end{minted}
\end{tcolorbox}

\bash{--std=c++11} specifies to the \CC~compiler that we are using the \CC 11 language standard~\cite{CXX11}.

From examining of the commands required by different languages to compile them, we have devised a small language within \textit{drasil-code} to express compilation commands. We extend the definition of \haskell{CodeHarness} to include the structure that stores the generated code filenames and use it to produce a list of inputs if \haskell{BcSource} is specified. We further enhance the definition of \haskell{RuleTransformer}'s \haskell{makeRule} to generate two additional rules. One for \bash{build} and one for the output file created by building the program in a given language. The output file rule is only produced if \haskell{buildConfig} is present. If \haskell{buildConfig} is not present, \bash{build} is still generated but is simply a no-op.

%We further extend the implementation of \haskell{makeRule} for the \haskell{RuleTransformer} instance to generate the build rules using the knowledge we have encoded:

% \begin{tcolorbox}
% \begin{minted}{haskell}
% data CodeHarness = Ch Config Package Code
% 
% instance RuleTransformer CodeHarness where
%   makeRule (Ch c m co@(Code code)) = [
%     mkRule buildTarget (map (const $
%     	renderBuildName c m nameOpts nm) $ maybeToList $
%       buildConfig c) []
%     ] ++
%     maybe [] (\(BuildConfig comp bt) -> [
%     mkFile (renderBuildName c m nameOpts nm)
%       (map (makeS . fst) code) [
%       mkCheckedCommand $ foldr (+:+) mempty $
%         comp (getCompilerInput bt c m co) $
%         renderBuildName c m nameOpts nm
%       ]
%     ]) (buildConfig c) ++ [
%     mkRule (makeS "run") [buildTarget] [
%       mkCheckedCommand $
%         buildRunTarget (renderBuildName c m no nm) ty +:+
%         mkFreeVar "RUNARGS"
%       ]
%     ] where
%       (Runnable nm no ty) = runnable c
%       buildTarget = makeS "build"
% \end{minted}
% \end{tcolorbox}

%where \haskell{buildRunTarget}, \haskell{renderBuildName}, \haskell{buildTarget}, and \haskell{getCompilerInput} are functions which translate the structures we defined into \haskell{makeString} and \haskell{String} and have been elided as their definitions follow naturally from the structures.

We have concluded the infrastructure required to produce Makefiles for the generated code. The Makefiles generated for \autoref{teExample} can be found in \autoref{a:doubleMakefiles}. 

\subsection{Integrating the Generated Makefiles}\label{bsCodeImpl}

Makefiles being generated with the code allows us to return to the original purpose of adding a general Makefile target to compile all the implementations for all the examples, as well as enforce the generated code compiles on Travis to further improve the reliability and quality of Drasil. We follow a process similar to \autoref{bsTex}, however, we start at the step where we create a shell script. 

Unlike each bundled example containing an SRS in\ \LaTeX, not all examples generate code. If an example generates code, the code resides within the example's \bash{src} folder. Examples generating no code lack the \bash{src} folder, meaning the existence of \bash{src} can be used to detect whether code is generated. Further, individual examples may generate a subset of all possible languages. Each generated language implementation resides in its own folder within \bash{src}, meaning the central Drasil Makefile should be generic and enter any folder under \bash{src} and invoke the Makefile. The generated Makefiles take care of language implementation details (by design) allowing for easy extension of \textit{drasil-code} to generate a new language without requiring any modifications to the Drasil build system to accommodate compilation of the new generated language.

The shell script used to compile all languages for a given example is:

\begin{tcolorbox}
\begin{minted}{bash}
RET=0

if [ -d "$BUILD_FOLDER$EDIR/$EXAMPLE_CODE_SUBFOLDER" ]; then
  cd "$BUILD_FOLDER$EDIR/$EXAMPLE_CODE_SUBFOLDER"
  OLD_DIR=$(pwd)
  for d in */; do
    cd "$d"
    "$MAKE"
    RET=$(( $RET || $? ))
    cd "$OLD_DIR"
  done
fi
exit $RET
\end{minted}
\end{tcolorbox}

All ``free" variables in the shell script will be passed from the central Makefile and there is an omitted preamble (from the preceding snippet) that ensures all the variables are bound. 

We follow the target template created for \autoref{bsTex} and adapt it to code generation:

% Modified slightly to keep it simpler
\begin{tcolorbox}[breakable, toprule at break=0pt, bottomrule at break=0pt]
\begin{minted}{makefile}
CODE_E_SUFFIX = _code
CODE_EXAMPLES = $(addsuffix $(CODE_E_SUFFIX), $(EXAMPLES))

EXAMPLE_CODE_SUBFOLDER = src/

%$(CODE_E_SUFFIX): EXAMPLE=$(shell echo $* | tr a-z A-Z)
%$(CODE_E_SUFFIX): EDIR=$($(EXAMPLE)_DIR)
$(filter %$(CODE_E_SUFFIX), $(CODE_EXAMPLES)): \
  %$(CODE_E_SUFFIX): %$(GEN_E_SUFFIX)
	@EDIR=$(EDIR) BUILD_FOLDER=$(BUILD_FOLDER) \
	EXAMPLE_CODE_SUBFOLDER=$(EXAMPLE_CODE_SUBFOLDER) \
	MAKE="$(MAKE)" "$(SHELL)" \
	$(SCRIPT_FOLDER)code_build.sh

code: $(CODE_EXAMPLES)
\end{minted}
\end{tcolorbox}

Adding support for building the code on TravisCI is as simple as adding the command \bash{make code}. The addition of code building to TravisCI immediately uncovered several implementation problems in \textit{drasil-code} (which have since been remedied) and errors in the encoding of information in two examples (also resolved).

Achieving code compilation locally and on CI builds required two levels of infrastructure work, which improved the knowledge capture of the Makefile generator (\textit{drasil-build}). We encoded build and run information for languages within \textit{drasil-code} in an abstract but expressive way required for code compilation. The implementation of the \bash{code} target in the central Drasil Makefile reduced the effort to build generated code locally, and invoking the target for the first time immediately uncovered issues with the code Drasil generated.

\section{From Convenience to Code Caliber}\label{bsConclusion}
\autoref{bs} started with desiring a shortcut to compile the\ \LaTeX\ Drasil generates. A tangent on the path to realizing\ \LaTeX\ compilation resulted in a refactoring of the Drasil Makefile endowing it with build information and knowledge about the structure of Drasil, which were useful throughout the chapter in both the compactness of future rules and by providing scripts with variables about where to locate certain files and artefacts. Compiling\ \LaTeX\ led to attempting to compile the generated code. To realize generated code compilation, we designed and implemented \textit{drasil-build} along with designing a small interface for \textit{drasil-code} to express compiler command lines and targets. We leveraged the added Makefile targets in Drasil's continuous integration process to ensure changes to Drasil do not break the output of any artefacts.


\chapter{Embracing Continuous Integration}\label{contInt}
Until recently, Drasil has used TravisCI and continuous integration as a way to ensure changes to Drasil compile, the generated artefacts match the expected results, and to generate documentation from the Haskell code. \autoref{bs} improves the continuous integration process by extending it to include compilation of many generated artefacts. The CI improvements from \autoref{bs} were a side-effect of improving the usability of Drasil's Makefile for developers and users, they were not changes designed \textit{for} continuous integration. We further enhance Drasil's CI process with additions designed to primarily run in a continuous integration environment, in an effort to continue improving the quality of code Drasil accepts and automate away common repository tasks.

\section{Linting For More Standard Code}\label{bsHLint}

Continuing with the theme of increasing the quality of code contributed to the Drasil repository, we turn our attention to the code of Drasil itself. With various contributors to the Drasil codebase, each with a varying programming style, the codebase becomes an amalgamation of differing styles. With many contributors, there also comes differing levels of comfort and knowledge of Haskell. In the Drasil codebase there is an instance of the following lambda: \haskell{\(x, _) -> x}, which is simply a redefinition of \haskell{fst}, but with more characters and less clear. Another anti-pattern found within Drasil is code of the form \haskell{concat $ map f x}, as opposed to \haskell{concatMap f x}, which can allow the compiler to generate more efficient code. It would improve the legibility of Drasil's codebase to correct these types of sub-optimal expressions and further standardise the style of the code.

\textit{Linters} are tools that analyze the layout and constructs of code. A linter will suggest style improvements, code suggestions, and possibly warn about functions that have limitations, such as \haskell{head} and \haskell{tail}, which are partial functions and can cause runtime errors. Some linters may even point out redundant code, such as superfluous brackets. One linter for Haskell is HLint\footnote{\url{https://github.com/ndmitchell/hlint}}.

One feature of HLint is the ability to encode additional suggestions through a configuration file. One common gaffe within the Drasil codebase is \haskell{[a] ++ [b] ++ [c]}, where \haskell{a}, \haskell{b}, and \haskell{c} are all the same type. In HLint we can encode the suggestion as:

\begin{tcolorbox}
\begin{minted}{yaml}
- suggest: {lhs: "[x] ++ [y]", rhs: "[x, y]",
  name: Combine Lists}
\end{minted}
\end{tcolorbox}

The extensibility of HLint allows Drasil contributors to include custom hints for oddities individuals notice within the codebase.

HLint, run over the entire Drasil codebase, returns approximately 3500 warnings and suggestions. The most frequent suggestion is to remove redundant brackets, accounting for 1907; the second most frequent being 462 instances of functions not adhering to camelCase capitalization. One warning highlighted by HLint is the redefinition of \haskell{fst} as an anonymous function. The author and the Drasil repository maintainers evaluated each item and concluded that all warnings and suggestions provided by HLint are worth addressing.

With HLint's value demonstrated from the provided hints, it is worth incorporating it into Drasil's continuous integration process after all existing suggestions have been addressed. Correcting the suggested hints is rather tedious, mechanical, and time consuming; thus, a small working group was formed to quickly address the hints. The working group addressed the existing hints allowing for HLint to become a step in the continuous integration process.

The author of HLint maintains a script to download, install, and run the latest release of HLint. If we leverage the script within Drasil's continuous integration infrastructure we automatically ``update" to the latest release without any modifications or maintenance. One reason this may not be desired is due to bugs, or inclusion of new hints that are flagged within Drasil's codebase. The uncovering of new ill-practices within the codebase can be seen as a benefit. In the event a bug in HLint triggers a false failure, we modify the Drasil TravisCI configuration to use a previous version until a Drasil contributor manually verifies an update has addressed the false failure. Automatically updating the version of HLint removes the need for a human to be concerned with updating HLint or even what version the repository currently uses and if there is any reason why a specific version is being used. In the event of a false failure we can modify the configuration clearly detailing the reason for the version freeze within the commit message, allowing a future author to detect and reinstate automatic version updates with certainty that the reason for the freeze has been addressed.

\section{``Beep Boop" --- \textit{drasil-bot}}\label{bsBot}

All of the CI work being performed has added multiple new failure conditions to the continuous integration process. Prior to the additions we included, the continuous integration checks in order were: build, checking difference with known good copies (\bash{diff}ing stable), and building the documentation. The changes thus far update the checks to, in order: HLint, build, \bash{diff}ing stable, compile\ \LaTeX, compile code, and build documentation. We have doubled the number of checks performed on new contributions to Drasil. Each check may fail for \textit{some} reason.

Drasil's repository is hosted on GitHub~\cite{GitRepo}. TravisCI integrates with \linebreak GitHub to provide status checks on commits and pull requests indicating whether a given change or theoretical merge (of a pull request into the main Drasil codebase) pass all stages of the CI process, or if the change fails. Unfortunately, the information provided by TravisCI on GitHub is two-bit with statuses being: a build is in progress, all checks in a build succeeded, at least one check failed, or a non-build related error occurred. For individuals staging changes this is a fine process; they may be using CI to verify a change has not introduced unintended differences or the change may still be a work-in-progress. While pull requests are expected to be checked manually by the change's author, sometimes authors miss checks or are eager to get their changes into Drasil and do not perform adequate checks.

A side-effect of the CI status indicator on pull requests is occasionally reviewers notice a CI failure, investigate the CI logs, and add a comment to the pull request notifying the change author of the failure. Reviewers investigating others' build failures is a waste of time as authors should be attentive and self-sufficient in noticing and addressing build failures. We wish to add additional context to build failures giving reviewers immediate insight and loosely indicate to authors why their build has failed at a glance.

GitHub provides two interaction options that could be viable. The first is to comment of failed builds indicating the build stages which failed. A benefit of this approach is we can be more descriptive, attempt to extract ``reasons" from the build log, and the author is likely to be notified (depending on the author's notification settings). A drawback of comments is many people (including reviewers) would be notified devaluing notifications as the build failure should only be of interest to the author. Another disadvantage is the visual space taken by a comment and the non sequiturs that may be interspersed in a larger conversation.

The other approach is to use labels on pull requests. Labels are small ``tags" that appear alongside pull requests on the page enumerating all open pull requests and on the pull requests themselves. The advantages of labels are they are short and concise, they are a ``breadcrumb" for authors to investigate a specific section of the build log, non-intrusive, and more visible than comments. A disadvantage of labels is not being able to provide additional details along with not sending any notifications. Despite not sending notifications, labels are more visible as they can be seen from an overview page and not just in the pull request itself. Being visible from the overview page provides context to reviewers indicating the types of errors in a pull request before they even open the pull request page. Further, the labels are displayed right next to the two-bit status indicator (on the overview page) providing added context. While only speculation, failure reasons being apparent on the pull request overview page may help diagnose something such as a false positive HLint warning in a new HLint release, due to all pull request CI builds after a certain point failing due to HLint. We choose labels largely due to their unintrusive nature of not sending notifications. 

We begin by specifying the label behaviour on the pull requests. Labels added by the CI process should be clearly ``marked" as being related to a CI build. The CI process should update the labels based on changes to the pull request to reflect newer builds. Finally, the CI process should not affect any labels that are not ``managed" by the CI process. 

From an implementation perspective, the code should be run as a part the continuous integration process to avoid requiring additional infrastructure, such as a server. The implemented system should not affect the commands specified in the CI configuration, if anything the encoding of label names should be a part of the same command it represents. 

TravisCI's commands are executed using the Bourne-Again Shell (Bash)\footnote{\url{https://www.gnu.org/software/bash/}}. We intend to make use of the extensions the Bash shell provides. We describe a function \bash{ci_fstep} --- short for \textbf{CI F}ailable \textbf{Step} --- where the first argument is the label to add if a command fails. \bash{ci_fstep} takes a variable number of arguments allowing for ``wrapping" of regular commands, for example \bash{make code} becomes \bash{ci_fstep "CI: Code" make code}. The definition we have conceived for the encoding of labels in the CI configuration satisfies all the implementation requirements specified. We save the label specified to \bash{ci_fstep} in a file containing all labels \bash{ci_fstep} is called with, representing the set of ``managed labels." We execute the original command line, which has been encoded as a series of arguments, by passing the command to a spawned shell. The spawned shell is to ensure the invoked command does not overwrite any variables, an \bash{exit} does not exit the current shell, and output is printed to the current shell's standard out and standard error.

Launching a spawned shell as a part of \bash{ci_fstep} faces a slight hiccup. The TravisCI build environment sets a specific set of shell options --- some of which alter the syntax allowed in Bash scripts --- which are required to properly parse the functions Bash loads as part of its startup within the CI environment. Without the proper options to the spawned shell, the shell returns an error due to allowed syntax disparities when a startup script is run. Compounding this issue, the spawned shell does not contain the shell functions loaded into the current shell, which makes \bash{ci_fstep} inconsistent with a non-wrapped command, leaks implementation details, and prevents us from using convenience functions provided by TravisCI. To combat these issues when launching an inner shell, we add a new Bash function: \bash{ci_export_funcs}. The function is to be placed in the CI configuration and run before any of the build steps. The function will examine the features of the existing session and exfiltrate settings to a file that will be loaded in the spawned shell. We exfiltrate the functions exposed by the continuous integration environment. Further, we extract the options specified to the current shell and save them to another file. Within \bash{ci_fstep} we load the options and set them when launching the inner shell. We specify the first command executed within the launched shell will load the functions from the file we saved in \bash{ci_export_funcs}. 

The return code from a shell process is the return code of the last command launched within the shell. With the shell we launch containing two commands, the command to load the functions from the file and the command passed to \bash{ci_fstep}, resulting in the return code from the shell being that of the command of interest. A non-zero return code from the launched shell indicates a failure executing the command. In the event the exit code is non-zero, we write the label to another file denoting a set of ``failed steps."

With one file containing the set of labels representing failures for the current build and another containing the set of all labels the CI process manages, we must set them on the pull request on GitHub. The GitHub API include commands to create, add, and remove labels from a pull request~\cite{GraphQLAPI}\cite{RestAPI}. Using the interface provided by GitHub requires an account to interact through. As opposed to tying the label action to any particular contributor's personal account, we create a new account \textit{drasil-bot}, which is solely managed through automated processes. 

We use Python\footnote{\url{https://www.python.org}} to create a script that prepares the data stored in the files during the build process and communicate it to GitHub. We use Python due to its interpreted nature, it being a language Drasil can render code as (to not introduce too many languages to the Drasil codebase), and Python's \mintinline{python}{set} primitives. In the script we query the pull request (the ID is exposed by TravisCI as an environment variable) to gather a list of existing labels. We filter the labels to only include those indicated from the managed file (produced during the build process). From there we create two sets, one of labels to add to the pull request and another of labels to remove.

We use v4~\cite{GraphQLAPI} of the GitHub API to remove labels as v3~\cite{RestAPI} only allows removing labels one HTTP request at a time; v4's remove mutation takes a list of labels to remove. We use the v3 API to add labels to the pull request due to the interface taking a list of labels (as strings) with a side-effect being if a label does not exist it is automatically created within the repository; v4 requires a query to lookup labels, a mutation to create any labels that do not exist, and finally another mutation to add the labels to the pull request. GitHub's API (both versions) include forms of rate limiting to prevent abuse. We mix the two APIs to only use commands that GitHub treats at constant cost to avoid an unpredictable number of queries and tie our API use strictly to the number of times TravisCI builds Drasil within a given time frame.

One unexpected development while designing the upload script is TravisCI's isolation of build environments. While not surprising, the isolation of build environments coupled with the fact that CI builds are race-y makes the upload script vulnerable to race conditions. Take the following example as one such condition. A pull request is created, within a minute of creation the author realizes they have a lint error. The author addresses it and pushes a change to their pull request before two minutes has elapsed. TravisCI has created two builds: one for the original and one for the ``correct" code. If we add network unreliability to the build for the original pull request commit, we may experience a case where the newer commit's build is further along. If the newer build finishes first it would be a pass, no labels would be added to the pull request that are managed by the CI process. Then the second build finishes, there are failed steps, the upload script dutifully adds the labels to the pull request despite the build not being the freshest code. Although many things must happen for such an example to occur, if it did, that would be a confusing experience. In an effort to mitigate this issue, we leverage additional information returned when we query labels that exist on a pull request. A pull request returns the hash of the most recent commit. TravisCI exposes the commit it is currently building as an environment variable. The hash of a Git commit is just that; a seemingly random hexadecimal string, which is difficult to predict and changes any time a commit changes. When the script checks the labels on a pull request it also ensures the build commit is the most recent on the pull request, if it is not, it does not change the labels as there is another build running (or possibly finished). Even with this check the race condition still theoretically exists. If a commit is added to the pull request in the time when the script checks the hash and before it alters the labels then the issue could still theoretically occur. However, in practice, when a commit is added to a pull request it can take TravisCI up to thirty seconds to start a build and another two minutes before the build is executing any of the (failable) build steps we have specified. Completely eliminating this race condition would require running a dedicated label process on a dedicated server that performs internal ordering of label changes and maintains persistence of active builds and recent commits. The extravagance of such a solution to fix a perceived rare race condition for updating labels is not worth the hosting costs or maintenance due to the extraordinary alignment of events for the race condition to occur.

The addition of \textit{drasil-bot} maintaining Drasil's continuous integration labels has caused many pull requests to contain a label indicating the type of build failure at some point before being merged. Subjectively speaking, the author has found the feature useful when submitting pull requests. Further, one reviewer --- when asked about the labels --- noted they had internalized the CI labels as part of the review process. While only being a small change to the user interface contributors may see when attempting to have code merged into the Drasil codebase, it provides more context than GitHub's two-bit build status indicator and has had the unexpected benefit of working and providing build failure feedback when TravisCI fails (for unknown reasons) to communicate the final build status to GitHub (which has occurred at least five times since \textit{drasil-bot} was implemented).

\section{Generating Artefacts From Generated Artefacts From Generated Artefacts}\label{bsCD}

In \autoref{bsTex} and \autoref{bsCode} we ensured the artefacts generated by Drasil can be built. The artefacts Drasil generates are built during every CI build. At the end of the CI build the artefacts are effectively discarded, we \textit{do} nothing with the artefacts at all. What if we could use the products produced by the CI process in even a fraction of the builds? Drasil (as a project) does not provide means to view the generated artefacts without trawling the repository, and even then without building Drasil and building the artefacts produced. If we could automatically upload the artefacts generated during (successful) CI builds, we would have a form of gallery for prospective users and contributors to see results of Drasil without having to download and build the artefacts themselves. Further, it doubles as an advertising tool to demonstrate the state of Drasil and what is currently capable using the system. Finally, the latest stable artefacts being readily available lowers the effort required by contributors to verify any changes to artefacts, since they are not required to build multiple copies of an artefact to compare the current stable version and their modified version.

The artefacts that should be showcased include the PDF copies of the SRS document, since it is much more meaningful to display than a file of\ \LaTeX\ meant as an intermediary. The HTML SRS document should be included as well, perhaps represented in another format if the medium we choose for the gallery does not provide HTML support. Any code generated for the bundled examples should appear. The code is selected over a compiled binary as a binary is not likely to be meaningful to the ``average" viewer who may not understand enough about a subject area to produce a valid input or configuration.

Due to GitHub being the location of the Drasil repository, it would be logical to provide the gallery of artefacts as a website. A website would make the artefacts available to anyone who can access the Drasil repository, easily linked from the Drasil repository, and requires little effort to view (as in not requiring a viewer to download anything outside the webpage). A website could raise Drasil's reach, once search engines index it, making it an excellent way to raise awareness about the project.

GitHub provides a service called GitHub Pages\footnote{\url{https://pages.github.com}} allowing repositories to host a website for themselves. The websites GitHub Pages allows to be hosted are \textit{static} --- meaning they provide no server processing and only serve files as-is to the viewer. This is perfect for Drasil as we intend for the gallery to display static (albeit regularly updating) information. Updating a website hosted on GitHub Pages is referred to as a \textit{deploy}. Deploying to GitHub Pages is as simple as pushing a commit to the repository (i.e. Drasil) on the \texttt{gh-pages} branch. 

The design of the mechanism to perform the deploy should be compartmentalized to allow \textit{staging} --- where Drasil contributors can change \textit{what} is deployed and test it locally without deploying (committing) the changes --- while integrating into a shell script that can be invoked from TravisCI to perform the actual deploy step. 

For the deploy script, we automate the creation of a \texttt{deploy} folder that will stage all the files for deploy and can be safely ignored by Git, to avoid accidentally adding the folder. We follow by copying any PDFs, HTML documents, and CSS (styling for the HTML) into the \texttt{deploy} folder under the pattern \bash{<example>/srs/}. We should copy the code Drasil generates, but to properly display it we would have to either leverage \textit{some} existing solution to pretty-print the code or create one. There is a third option: TravisCI builds are triggered from commits to GitHub, Drasil contains a version of the generated code, GitHub contains a code viewer with pretty-printing, and Drasil's CI process contains a check to make sure the built code matches the stable code stored in the repository. If we tie deployment to a successful build then we are certain the \texttt{stable} folder in the repository accurately reflects the currently generated code. We can simply link to the files of the commit being built as opposed to reinventing the wheel.

To provide links to GitHub we must discern the path from the Git repository root to the folder that stores the source files for a particular implementation. \autoref{bsRefactorCI} designed the Makefile to be a store of build-related information allowing us to add a Makefile target to extract the path to the code folder for a particular example. After extracting the path to the implementation code folder, we concatenate it with the individual languages generated (for a given example) and create a file, \texttt{src}, in the folder of a given example with one path per implementation language per line. The static site generator will use these paths to generate GitHub links to the built commit. 

While we include artefacts the bundled examples produce, the continuous integration process builds documentation for the Drasil language and sub-packages as well as produces file dependency graphs for each sub-package of Drasil. These Drasil code derived artefacts are worth including on the generated website because they remove a task individual developers would be required to perform (building the artefacts) while also providing context and information about Drasil to prospective contributors. Adding both types of non-example artefacts only requires copying the directory where the artefacts are generated into the \texttt{deploy} folder.

The last artefact required for the website is to generate a web page to act as an index for the artefacts, something not yet done. We use the Hakyll\footnote{\url{https://jaspervdj.be/hakyll/}} static site generator to produce the web page. Hakyll works by instantiating HTML templates we design. Hakyll is implemented in Haskell --- leveraging Haskell's typesystem as a consequence --- and was selected in part due to its implementation language being the same as Drasil; thus, preventing a language barrier from hindering improvements to the web page from other Drasil contributors. Hakyll is similar to Drasil in the sense it contains a build phase that builds an executable that, when run, produces the artefacts we describe. At a high-level, Hakyll works by parsing HTML templates, evaluating conditional and loop constructs, and performing variable substitutions. HTML templates can embed other templates allowing for page composition where a header and footer may be defined in one template while another template only considers the ``content" of the page. 

We emphasize the traceability of autonomous web page updates through a footer containing the Git hash (and link to the commit), as well as a TravisCI build number and link to the Travis build that produced the current web page. If at any point a build goes awry, producing undesirable results, we provide the context a maintainer is likely to require to triage the problem. The link to the GitHub commit that generated the web page provides an avenue for viewers to locate the exact commit and codebase that produced the artefacts they are viewing. The rest of the web page is simplistic and displays a category of artefacts with a bullet list providing the name of the artefact and a link.

The organization of build artefacts within the \texttt{deploy} folder encodes a form of structure that the website generator will leverage to ``discover" properties such as number of bundled examples and their artefacts without knowing too much about Drasil. This design decouples the webstie from knowing how Drasil works and what it will generate. The deploy script acts as an extension of the build system, providing the glue that supplies knowledge about Drasil's artefact layout --- partially derived from the central Makefile --- while adapting its structure and layout for use by a completely automated process. Drasil's central Makefile containing pertinent information for builds is useful once again. We provide the Hakyll website generator with paths to various folders, indicating where to find certain artefact types within the \texttt{deploy} folder. 

TravisCI provides many environment variables useful for the website, such as the commit hash and build number for the current build. This information is used when building the website on CI, but is not available locally. To provide valid links and approximations of values such as Git hashes, which are not calculated until a commit occurs, we provide ``default" values and more generic links (like to the most recent Drasil commit and build) to enable testing of the generated website locally with minimal differences to what would be produced on CI. 

Most of the artefact-related information on the website is generated from the name and path of files within the \texttt{deploy} folder. The notable exception is the links to generated implementations for the examples. Examples with implementations include a file, \texttt{src}, in that example's folder within \texttt{deploy}. As previously mentioned, the contents of the file is one file path per line indicating the location within the Git repository to an implementation (in \textit{some} language) of a given example. The website generator finds this file and uses those paths to properly construct hyperlinks to the folders on GitHub.

One unexpected deficiency of Hakyll is the lack of support for \haskell{Maybe} values. We would like \haskell{Maybe} values because with Hakyll's default combinators we are required to split the \haskell{Maybe} type into two variables, such as \haskell{valExists} and \haskell{val}, to be able to use a value in both a conditional (to check for definedness) and as a variable substitution. Using two variables is less than ideal due to nothing constraining the values together. It is rather ad-hoc. We would like to check if a value exists before displaying the contents as we may include a preamble, or some boilerplate HTML, to prepare a section that would not exist otherwise. To address this, we define a function, \haskell{maybeField}, that properly encodes \haskell{Maybe} as values exposed to Hakyll's templating engine. \haskell{maybeField} addresses the deficiency by determining on variable lookup --- occurring both during variable substitution and conditional checks --- that a value is \haskell{Just}. In the event a value is \haskell{Nothing}, the function soft-fails (using the \haskell{Alternative} typeclass' \haskell{fail} function) to indicate undefined to the template engine. Hakyll conditionals treat undefinedness as a falsey result. If a value is \haskell{Nothing} and a substitution attempt is made outside of a conditional, the template instantiation will fail due to the undefined value; thus, ensuring the expected behaviour rather than simply expanding the variable to an empty string.

The rest of the generator is constructing small data structures to encode the knowledge extracted from the \texttt{deploy} folder's structure and is rather straightforward. With the website implementation being complete, we update the deploy script to copy the generated site file, \texttt{index.html}, to the \texttt{deploy} folder. We add central Makefile targets to invoke a staging of the deploy script, ensuring all artefacts are produced as well as feeding the deploy script variables related to build layout.

With all the pieces required for a CI deploy now being produced and located in the \texttt{deploy} folder, it is time to wrap the deploy script for use with TravisCI, to actually perform the deploy. One of the checks when running the CI deploy script is to ensure it is running on TravisCI. We check the environment by looking for certain environment variables provided by TravisCI, which usually begin with \bash{TRAVIS_}. Further, the deploy script ensures certain properties about the prospective deploy candidate, such as the type of build. We typically only deploy cron-type builds to limit the deploy amount to comply with GitHub Pages abuse rate limiting policies. The TravisCI deploy script clones the \textit{gh-pages} branch as the \texttt{deploy} folder, writes some metadata --- such as commit hash and build number --- to files within the \texttt{deploy} folder, before setting additional environment variables and transferring control to the local deploy script that performs much of the heavy lifting. By making the \textit{gh-pages} branch the \bash{deploy} folder, there is no additional file movement required after the deploy has been staged. The contents of the \bash{deploy} folder can be directly uploaded. The GitHub account created in \autoref{bsBot}, \textit{drasil-bot}, gains an additional task: it commits the deploy after the script completes running. The commit message generated for each deploy indicates the branch and commit hash that generated the artefacts. The commit message adds another place where the commit hash exists, making it very obvious the origin of the artefacts whether trawling the commits, the source, or viewing the web page. 

We enable the deploy on TravisCI to occur once per day with the latest code on the main branch (only if the code is newer than the code used for the previous deploy), provided it passes all CI tests. To add the deploy to CI, we are required to wrap the script in a small shim. The shim launches a nested shell with certain Bash options set because TravisCI treats deploys as a separate phase. The deploy phase does not provide the Bash functions previously defined and also supplies a different set of shell options to the invoked shell. The shim uses the options and functions gathered in \autoref{bsBot} to reuse existing tools within the TravisCI deploy script. 

In an effort to make deploys a transparent process, we check during pull request builds to see if the website generator or the local deploy script has changed. In the event either has changed, we do a staged deploy (as if it were local) as a means to ensure the changes have not negatively affected the generated web page or artefacts. As a part of the process, we emit the generated web page for reviewers and authors to use as a form of visual inspection for their changes. Unlike the artefacts Drasil generates, many moving parts can affect the exact values substituted into Hakyll templates making it a poor candidate for comparing against a stable version.

The web page hosts many artefacts the bundled examples produce as well as system information about Drasil. The website is generated automatically from what Drasil builds as part of its testing process. The current rendition of the website is located at \url{https://jacquescarette.github.io/Drasil} and contains artefacts no older than 24 hours from the most recent commit to the main branch in the repository. 

\section{Quality}\label{bsQuality}

The build system work from \autoref{bs} naturally evolved in \autoref{contInt} to focus on improving the continuous integration process. The first change to CI added HLint as an automated tool to ensure consistency of code as well as express code in a more efficient fashion. We leveraged all the build improvements to ensure the quality of code in Drasil improves and that new code meets a higher standard before being included. In an effort to manage the complexity of the CI process, we developed \textit{drasil-bot} to label pull requests with build failures, providing context to authors and reviewers without requiring all of them to read the log. Finally, we took the artefacts generated during the CI process and hosted them to improve the visibility of Drasil. The generated website demonstrates what Drasil is capable of producing while providing convenient compiled artefacts for contributors and prospective users alike.



% Before: https://github.com/JacquesCarette/Drasil/pull/1105
% drasil-build: https://github.com/JacquesCarette/Drasil/pull/1212
% Drasil-build better design: https://github.com/JacquesCarette/Drasil/pull/1227
% drasil-code Old-Style run target: https://github.com/JacquesCarette/Drasil/pull/1228
% Drasil-build Build Targets: https://github.com/JacquesCarette/Drasil/pull/1239
% Makefile building: https://github.com/JacquesCarette/Drasil/pull/1241/files
% Makefile Variables: https://github.com/JacquesCarette/Drasil/pull/1398
% HLint: https://github.com/JacquesCarette/Drasil/issues/1117
