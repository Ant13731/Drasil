\chapter{Introduction}\label{intro}
%\section{Problem}\label{iproblem}
% Why does Drasil exist?
% 	What is it?
Scientific Computing (SC) is a diverse domain of software development focused on using computers to aid in solving science and engineering problems. Mathematical models and algorithms are designed and implemented to calculate various properties about the modeled real-world systems, such as maximum load and failure rate. Some examples of scientific software are modeling the physics for a bridge, protein folding, and an algorithm for an ordinary differential equation solver.

Due to the important nature of SC software, SC focuses on correctness, consistency, and traceability, among other properties, to ensure high-quality software. In an effort to design software following the listed properties, SC software should include other deliverables besides the code implementation, such as a test plan to ensure the software's behaviour.

% 	Time
Ensuring the quality of (SC) software can be a time-intensive effort. Constructing all required -- or desired -- documentation, such as a high-level design document and test plan, can greatly increase the amount of work required. Any inconsistency found in any deliverable will require a reexamination of all deliverables to ensure the mistake did not propagate elsewhere. For example, a sign error in a requirements document may propagate into the code implementation and not be discovered until testing occurs. 

% 	Certification
Some scientific software, such as those that are involved in power generation, or are otherwise safety relevant, must pass a certification process prior to being used in real-world situations. Certification is an extensive process necessitating a requirements document, a high-level design document, the complete source code for the software, a test plan, and the testing results, to name some possible deliverables. Due to the rigor involved with software certification, it is an expensive process. Small inconsistencies between --- or within --- any of the provided items can result in a rejection. It becomes imperative for a software product and associated documentation to be pristine before entering the certification process.

Certified software rarely sees modification post-certification. Any software modifications tend to require a complete recertification of the system because the system-wide impact of an alteration is unknown. Due to the cost of applying for certification again, the time to proofread the existing documentation to ensure they maintain consistency in the modified version, and the scale of changes to the existing software, it does not make financial sense in many situations to attempt recertification. 

\section{Drasil}\label{idrasil}
% Introduce Drasil
To combat the difficulties of producing high-quality SC software, we look to Drasil~\cite{GitRepo}\cite{SzymczakEtAl2016}. Drasil is a framework of embedded domain-specific languages (eDSLs) used to \textit{describe} a software system. From the description of a software system, Drasil generates a requirements document, implementation code in four different imperative-style languages (\CC, C\#, Java, Python), and Doxygen comments for the generated code. All of the artefacts are derived from a single description of a software system. Drasil aims to be modular by-design to allow users to implement additional artefact types and document formats without requiring comprehensive changes to the core language.

Drasil addresses the difficulties of producing consistent SC software through the use of a single structure (\haskell{SystemInformation}) that provides a description of a software system. By only specifying information once, any documents generated must be consistent by-construction. Further, a change to the description will update all artefacts appropriately, reducing the burden incurred by modification. Due to Drasil's centralised knowledge, tasks that are tedious for humans, like constructing a table showing dependencies of requirements on assumptions, can be performed automatically during artefact generation. Through the process of ``faking" the rational design process~\cite{parnas1986rational}, Drasil reduces the tedious bookkeeping-type work required for certification through its artefact generation process.

% Example of reuse
\autoref{lst:iglassbr} contains a brief piece of code describing the name, or \textit{idea}, of a software system bundled with and elaborated in Drasil, named ``GlassBR." A \textit{commonIdea}, or \haskell{CI}, encodes the concept of a noun for use with Drasil. The first \\

\begin{listing}[H]
\begin{tcolorbox}
\begin{minted}{haskell}
glassBR :: CI
glassBR = commonIdeaWithDict "glassBR" (pn "GlassBR")
  "GlassBR" [idglass]
\end{minted}
\end{tcolorbox}
\caption{A Drasil \textit{chunk} representing the \textit{idea} of a software system ``GlassBR."}
\label{lst:iglassbr}
\end{listing}

\noindent argument applied to \haskell{commonIdeaWithDict} specifies a unique identifier, which is used internally within Drasil to perform database lookups during artefact construction. In the case of \haskell{glassBR}, the string \haskell{"GlassBR"} is a proper noun and specified as such using the \haskell{pn} smart constructor, comprising the second argument, or \textit{what} the idea is and the semantics related to displaying it. The third argument may be an abbreviation, or acronym, of the idea. The final argument is a list of domains that the idea belongs to for information categorisation purposes. The particular definition displayed in \autoref{lst:iglassbr} is further used to specify the name of generated software system. The GlassBR example bundled with Drasil generates a Software Requirements Specification (SRS) and implementation code for the system. Of the artefacts generated ---\ \LaTeX\ SRS, HTML SRS, \CC~implementation, C\# implementation, Java implementation, and Python implementation --- the \haskell{glassBR} definition specified above is responsible for 50 appearances of the string. Each SRS contains 18 instances of the phrase ``GlassBR," while the remaining 14 locations of the noun occur in the generated code; the Java implementation uses the idea to place all generated code inside the ``GlassBR" package accounting for nine instances, while the remaining five appear in generated Doxygen configurations. With Drasil, renaming software system is a trivial task requiring only one line of modification! Modifying the line in \autoref{lst:iglassbr} is more straightforward and predictable than manually attempting a ``find and replace" across many artefacts in many languages, and hoping for the best.
% Note: GlassBR numbers are those ignoring the Makefile (which didn't exist before I added them including the Doxygen targets, althrough we do include the doxygen numbers)


% How further reuse gives us drasil-data and software families.
Drasil's reusability facilities can be used beyond a single software product. Information, like that specified in \autoref{lst:iglassbr}, may be reused in other software products to form \textit{software families}. A software family is a related set of software products with design parameters modified. Drasil contains a software family as two related examples: one is a Solar Water Heating System (SWHS), which involves a Phase Change Material (PCM), the other is a modification of SWHS to remove the PCM, named ``NoPCM." NoPCM reuses large portions of SWHS --- such as the requirements, assumptions, and models --- by sharing constructs between both examples. ``Common" knowledge may be further refactored into \textit{drasil-data}, a sub-package of Drasil that contains common domain-specific concepts, such as the mathematical constant $\pi$ and Newton's Second Law of Motion as a physics concept.
% FIXME: Should I cite these two examples (and if so caseStudies, Drasil code or generated artefacts), GlassBR, and Newton's 2nd?

% Problems with Drasil
\section{Shortcomings}\label{iprobdrasil}
% DL (SRSDecl)
Drasil's emphasis on reuse provides an excellent basis to dissect and discern what knowledge is required to properly design and specify a software system. Unfortunately, some of Drasil's earliest efforts were focused on simply encoding information to display in a certain way within an SRS rather than to properly capture knowledge that is sufficiently described to be reusable. The result of the ad-hoc design is display-oriented facilities that do not provide the correct level of abstract encoding to reuse the information outside of a requirements document. Such design-oriented information does not truly embody the idea of reuse that Drasil strives to achieve, where knowledge may permeate all artefacts of a system described.

% CI, DL (Multiplate)
Due to the ad-hoc design, Drasil includes substandard code as the result of substandard design decisions, which ironically violates Drasil's own design goal for reuse. Early additions to Drasil based on existing features tended to be implemented using copy-paste rather than integrating and considering the new feature with the existing codebase. The result is swathes of duplicated code that vary in few situations and requires a higher maintenance effort to enact the same change across multiple pieces of copy-pasted code.

% DL
Further stemming from the ad-hoc design of early Drasil is a lack of consistency within sub-packages of the project. Part of early Drasil was heavy experimentation with language constructs and the way ideas were exposed to users. Sometimes an experimental change would be made to one facility and left that way without any further modifications. These modifications may have improved the language in terms of reusability or ease-of-use, however, complicated internal design by requiring multiple methods to interact with similar data. In one particular case, the implicit passing of data through a more general data structure was a desirable change, although only applied to one constructor. The other constructors duplicated data already available in a common database; thus, forcing authors to specify the same information twice while allowing room for error. The unique data constructor that retrieved the data required from the database was typically ignored while designing systems that interacted with it, resulting in last-minute hacks to ``make it work," forming a feedback loop of hacks. The feedback loop of hacks reached a point where the technical debt was too high and it became reasonably difficult to include items associated with the anomalous constructor in some derived data. The derived data simply omitted information ``belonging" to the anomalous constructor.

% DL (Traceability, others), BS
% FIXME: Next two paragraphs need another pass.
Much of the developmental effort for Drasil has been focused on improving what is generated. An oft ignored aspect of Drasil's development is the ease-of-use when attempting to encode knowledge in Drasil as well as the (in)convenience to describe artefacts and how they should use available information. A user would notice, when producing an example from scratch, the odd incantations needed to make certain pieces of artefact generation work correctly. When improvements are made to document generation, which displays information automatically derived from user-specified knowledge, the layout of the new information is not always a concern and seen as something to revisit. The deferral of correcting the layout and how the information is displayed leaves Drasil producing unappealing sections of documents, which are hard to read or interpret.

% BS cont
The build system of Drasil is ad-hoc and lacks developer attention as it does not immediately improve the artefacts generated. The build system for Drasil provides the bare minimum required to build the sub-packages and lightly test the artefacts generated by Drasil. Building any artefacts Drasil generates is a tedious process for a human, resulting in many instances where developers make changes that break the correctness of artefacts Drasil produces.

% Overview of What I Did
\section{Problems Addressed}\label{iplan}
With the shortcomings of Drasil in mind, \autoref{ci} examines a seemingly small issue encountered in \autoref{toyexample}. Through examining how the associated data is passed between sub-packages and functions, we discover a larger design problem resulting from an ad-hoc, early Drasil implementation. We conclude by unifying several related pieces of code and data structures, anticipating future development, in an attempt to reduce maintenance effort. \autoref{dl} addresses an inconsistent (but better) abandoned, experimental design that added an unexpected hurdle in the implementation of \autoref{ci}. During the course of addressing the hurdle, \autoref{dl} examines a wide range of boilerplate and awkward design, remediating each to realize a better design, more aligned with Drasil's design philosophies. Finally, \autoref{bs} begins by examining how to automate the tedious, repetitive, Drasil developer action of compiling the\ \LaTeX\ and generated code for the bundled examples. The task escalates in \autoref{contInt} producing a better testing process for potential changes to Drasil to improve code quality and consistency while reusing the generated artefacts to demonstrate the project to prospective users interested in Drasil. The end result of \autoref{contInt} is a test suite that analyses the Drasil codebase statically, the generated artefacts, and produces an archive of artefacts readily accessible online.
