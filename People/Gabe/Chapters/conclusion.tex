\chapter{Conclusion}\label{conclusion}
This report has discussed many improvements incorporated into Drasil. \autoref{ci} started with the goal of moving chunks that \textit{drasil-lang} knew too much about and ended by abstracting three chunk types that were essentially the same into \haskell{ConceptInstance}. The work done in \autoref{ci} occurred during a refinement pass of referencing in Drasil, allowing for our requirements of a deferred type lookup to be included in \haskell{RefProg}, the language for forming reference names. The work performed for \haskell{ConceptInstance}, and the associated infrastructure, allows for easy encoding of textual, description-based chunks. The benefit of \haskell{ConceptInstance} was demonstrated by adding goal statements to the SRS, requiring only five lines of code to adapt \haskell{ConceptInstance} for the use case. Future improvements could be made to \haskell{ConceptInstance} allowing for the capture of lists, providing more structure to the knowledge that can be encoded by \haskell{ConceptInstance}. 

\autoref{dl} began as an effort to provide more consistency for \haskell{DocDesc}, specification for the layout of an SRS, and deciding which comes first: the \haskell{ChunkDB} or \haskell{DocDesc}? The decision was made for \haskell{ChunkDB} to come first, resulting in \haskell{DocDesc} being derived from the information available in \haskell{ChunkDB}. To facilitate the derived nature of \haskell{DocDesc}, a new user-facing structure (\haskell{SRSDecl}) was added to declaratively specify the layout of the SRS. \haskell{DocDesc} became an elaborated version of \haskell{SRSDecl} used to hold chunks retrieved from \haskell{ChunkDB}. The introduction of \haskell{SRSDecl} ensures consistency as the user no longer specifies information to both \haskell{DocDesc} and \haskell{ChunkDB}, removing opportunities for consistency violations, while also simplifying the design of the specification language for SRS documents. With \haskell{DocDesc} being an elaborated version of the SRS, we used multiplate~\cite{multiplate} to provide a simple means to perform introspective passes to derive information from the elaborated SRS. Multiplate reduced the total number of lines for introspective passes by 127 and removed unwieldy boilerplate required by the previous pass mechanism. Implementing \haskell{SRSDecl} required moving user-required boilerplate into \textit{drasil-docLang} further providing consistency while removing up to 26 lines specified in every bundled Drasil example. We used the introduction of \haskell{SRSDecl} to ameliorate the traceability matrix generation, reducing boilerplate code required by the designer of a software system while making the display more flexible. The improvements to the traceability matrix produced more readable traceability matrices and removed more boilerplate required by users to generate them while also removing more opportunities for users to accidentally specify inconsistent matrices.

Further improvements could be made to \haskell{SRSDecl} by continuing to refine what is explicitly specified versus what is captured in \haskell{ChunkDB} and \haskell[breakanywhere, breakanywheresymbolpre=\textcolor{black}{-}]{SystemInformation}. This improvement would migrate the SRS to be a view of all information specified about a software system, rather than providing \haskell{SRSDecl} with either exclusive knowledge or manually repeating specified information within a system description. \textit{drasil-docLang} could be more thorough and automated in generating reference section material, such as the table of symbols, table of units, and table of acronyms, by leveraging the multiplate infrastructure put in place in \autoref{dlMultiplate}. In the future, multiplate could be implemented in other structures, such as \haskell{Contents}, to allow for other sub-packages to introspect data structures as needed. 

Improvements to the build system performed in \autoref{bs} refactored the Makefile to abstract many targets, reducing the length from 178 lines to 80 lines. The central Drasil Makefile encodes structural and build information about Drasil, which is used in various places within the build system. \autoref{bs} exposed new Makefile targets to build artefacts produced by the bundled Drasil examples. The new \bash{tex} and \bash{code} targets are used by the continuous integration process to ensure changes to Drasil do not break compilation of generated\ \LaTeX\ or code. The changes made in \autoref{bsTex} and \autoref{bsCode} ensure a certain quality of code is met in changes to Drasil through their inclusion in CI. The new targets lowered the effort to build artefacts, making it more convenient and less time consuming for contributors of Drasil to verify changes. To build the generated code, we were required to refactor Makefile generation in Drasil into an abstract sub-package: \textit{drasil-build}. We encoded \textit{how} to build code for each generated language, which required a moderate amount of infrastructure work to facilitate. The work performed in \autoref{bs} was immediately validated through the discovery of artfeact generation issues in Drasil, which have since been remedied.

Future work for the build system includes running the generated code. Drasil plans to generate a test plan as a new piece of documentation. The test plan could be used by CI to confirm the generated code meets the design parameters encoded by each example. 

\autoref{contInt} further restricted code allowed in Drasil sub-packages by using HLint to enforce a common style of code in the Drasil codebase. With all the checks the CI process performs we introduced \textit{drasil-bot} to provide context for failed builds on pull requests in an effort to reduce the time between build failures and corrections. With all the artefacts CI produces, we decided a portion of builds would produce a website with the most recent artefacts to both advertise Drasil and provide quick access to the latest artefacts for contributors to use as reference. The improvements to the continuous integration system raised the bar for code to be included in Drasil, improving the reliability of Drasil as a whole product. The checks, such as whether the\ \LaTeX\ and generated code compiles, ensures prospective users are unlikely to encounter situations where bundled examples produce incorrect output. HLint ensures the style of Drasil is consistent, reducing the instances of individual's stylistic preferences from appearing in the code. The inclusion of \textit{drasil-bot} provides additional feedback to pull request authors about problems with their code in a non-intrusive way. Finally, the generated website further lowers the barrier to viewing the artefacts Drasil produces as they are readily accessible and frequently updated. 

Future work building on \autoref{contInt} includes \textit{drasil-bot} commenting on pull requests providing a visual \bash{diff}, of the rendered documents, comparing the latest main branch documents and the changes in the pull request. The deploy website could be improved to provide more details about Drasil and the generated artefacts. One possible improvement is for each example to provide information about the \haskell{Choices} they select for code generation and the differences they make to the produced output. 

All of the changes to Drasil made in this report have aligned with Drasil's philosophies. Many changes reduced the number of times knowledge was repeated, either in bundled examples or within the structure of the code itself. We have reduced instances where inconsistencies could slip into the code, both within the examples and throughout the artefact generation process. We improved the reliability of the artefacts Drasil generates. Since the enhancement to CI, with the exception of accidental merge conflicts, both\ \LaTeX\ and generated code have not had build failures on the main branch. Finally, we have reduced the amount of boilerplate users are required to specify when encoding systems in Drasil. As evidence of this, we have included an updated version of Double from \autoref{teExample} in \autoref{a:modernDouble}. \autoref{a:modernDouble} is notably missing boilerplate originally required in \autoref{teExample}. We have improved all levels of Drasil, from the input users specify, to the output produced, to the quality of the code passing the standards put in place.
