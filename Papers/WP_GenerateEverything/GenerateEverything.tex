\documentclass[10pt,twoside,onecolumn,openany,letterpaper]{memoir}
\usepackage[paperwidth=8.50in, paperheight=11in]{geometry}
\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
%\usepackage{tgtermes}

\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[protrusion=true,expansion=true]{microtype}

% for inline lists
\usepackage[inline]{enumitem}
% for nice internal links
\usepackage{hyperref}

% set the margins
\setlrmarginsandblock{1in}{1in}{*}
\setulmarginsandblock{1in}{*}{1}
\checkandfixthelayout

\begin{document}

\title{Generate Everything White Paper}
%\orcid{0000-0001-8993-9804}
%\affiliation{\department{Computing and Software}
%  \institution{McMaster University}
%  \country{Canada}
%}
%\email{carette@mcmaster.ca}
\author{Jacques Carette \and Spencer Smith}
%\email{smiths@mcmaster.ca}

%\begin{abstract}
%\end{abstract}

%\keywords{code generation, document generation, knowledge capture,
%  software engineering, scientific software}

% set up math environment
\newtheorem{defn}{Definition}

\maketitle

\chapter{Introduction}
% What if we're doing it all wrong?

``Software'' is not uniform. To use the exact same process for
developping an embedded safety-critical piece of code (like that of
a pacemaker), the flight control software for an airplane, a one-off
script for moving some files around, and some amusing animations on
one's personal web site, is patently ridiculous.

The same is true in say, civil engineering: you don't need architects,
licensed engineers and a million permits to build a small shed in your
backyard, but you do need them to build a $100$ story skyscrapper.

Which brings us to our central topic: there are some kinds of software
where our current development methods \emph{are all wrong}. Our task
is to define exactly which type of software we have in mind, and then
derive an entirely different development methodology that is
customized to the special characteristics of that strict subset.

There are many properties of software that can be used for providing
a classification. Here we will focus on one particular ``axis'': how
\textbf{well understood} it is. The majority of the next section will
be devoted to explaining exactly what this means. Once that is set up,
we can then unravel some operational consequences: how the characteristics of
well understood softare lead to innovative methods of building such
software. As this might be perceived as too abstract, we give a very
concrete example. Of course, our ideas do not exist in a vacuum: we were
inspired by a number of connected ideas, and we then give credit where
credit is due. More than just ideas, there are also technologies that back
these ideas, some of which we're already using, others which lie in our
future, and we outline some of these as well.

\chapter{What is ``well understood'' Software?}\label{ch:wellUnderstood}

\begin{defn}
A software domain is \emph{well understood} if
\begin{enumerate}
\item the domain knowledge (DK) is codified,
\item the computational interpretation of the DK is clear,
\item the engineering of code to perform said computations is well
understood.
\end{enumerate}
\end{defn}

By \emph{codified}, we mean that the knowledge exists in standard form in
a variety of textbooks. For example, many domains of knowledge in engineering
use differential equations as models. Furthermore, the quantities of interest
are known, given standard names and standard units. In other words, there is
an established vocabulary and body of knowledge that is uncontroversial.

We can further refine these high level ideas as follows, where we use
the same numbering as above to indicate which part of the definition is
being directly refined, but where the refinement nevertheless should be
understood more holistically.
\begin{enumerate}
\item Models in the DK \emph{can be} written formally.
\item Models in the DK \emph{can be} turned into functional relations by
 existing mathematical steps.
\item Turning these functional relations into code is also an understood
 transformation.
\end{enumerate}
Perhaps the most important aspect of this refinement is that the last two
parts deeply involves \emph{choices}: What quantities are considered inputs,
outputs and parameters to make the model functional? There are also a host
of choices, including which programming language, but also software
architecture, data-structures, algorithms, etc, which are also part of
creating the code.

It is important to understand that \emph{well understood} does not imply
\emph{choice free}.  Writing a small script to move some files around can
be easily written as a Shell script, or in Python or in Haskell, depending on
the author's style. In all cases, assuming the author chooses a language
in which they are fluent, the job will be entirely straightforward.

Lest our reader gets misled into thinking that code is the only artifact
that matters, we should explicitly refine our definition in a different
direction, equally important.
\begin{enumerate}
\item The meaning of the models is understood at a human-pedagogical
level, i.e. it is explainable.
\item Combining models is also explainable. Thus the \emph{transformers}
we mentioned before simultaneously operate on mathematical representations
and on explanations. This requires that English descriptions also be
captured in the same manner as the formal-mathematical knowledge.
\item Similarly, the \emph{transformers} the arise from making software
oriented decisions requires that they be captured with a similar mechanism,
including English explanations as well.
\end{enumerate}

We dub these \emph{triform theories}, as a nod to \emph{biform theories}%
\cite{Farmer}. The idea is that we couple 
\begin{enumerate*}
\item an axiomatic description,
\item a computational description, and
\item an English description
\end{enumerate*}
of a concept.

It is important to notice that there are various kinds of choices
embedded in the different kinds of knowledge. They can show up simply as
\emph{parameters}, for example the gravity constant associated to a planet.
This also shows up as different transformers, for example turning
$F - m\cdot a = 0$ into $F\left(m, a\right) = m\cdot a$, i.e. from a 
conservation law into a computation. Note that, for motion computation, that
same conservation law is often rewritten as $a\left(m,F\right) = F/m$ as
part of solving $x = \ddot{a}$ to obtain a position as a function of time.
And we also get choices of phrasing, which are equivalent but may be more
adequate in context, for example.

\chapter{How would you go building that?}\label{ch:process}

So what would be a reasonable process for building a piece of software
assuming some kind of infrastructure exists for recording the kind of
knowledge outline in~\autoref{ch:wellUnderstood}

\chapter{Example}\label{ch:example}

\chapter{Connected Ideas}\label{ch:ideas}

\chapter{Some Useful Technologies}\label{ch:techniques}

\end{document}

Good quotes:
\begin{itemize}
\item metaprograms are just programs
\item models outside an integrated toolchain are insufficiently useful
\end{itemize}

