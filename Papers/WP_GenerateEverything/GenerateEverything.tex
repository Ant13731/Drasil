\documentclass[10pt,twoside,onecolumn,openany,letterpaper]{memoir}
%\usepackage{createspace}
%\usepackage[size=pocket,noicc]{createspace}
\usepackage[paperwidth=7.50in, paperheight=10in]{geometry}
\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
%\usepackage{tgtermes}

\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[protrusion=true,expansion=true]{microtype}

\begin{document}

\title{Generate Everything White Paper}
%\orcid{0000-0001-8993-9804}
%\affiliation{\department{Computing and Software}
%  \institution{McMaster University}
%  \country{Canada}
%}
%\email{carette@mcmaster.ca}
\author{Jacques Carette \and Spencer Smith}
%\email{smiths@mcmaster.ca}

%\begin{abstract}
%\end{abstract}

%\keywords{code generation, document generation, knowledge capture,
%  software engineering, scientific software}

\maketitle

\chapter{Introduction}
% What if we're doing it all wrong?

``Software'' is not uniform. To use the exact same process for
developping an embedded safety-critical piece of code (like that of
a pacemaker), the flight control software for an airplane, a one-off
script for moving some files around, and some amusing animations on
one's personal web site, is patently ridiculous.

The same is true in say, civil engineering: you don't need architects,
licensed engineers and a million permits to build a small shed in your
backyard, but you do need them to build a $100$ story skyscrapper.

Which brings us to our central topic: there are some kinds of software
where our current development methods \emph{are all wrong}. Our task
is to define exactly which type of software we have in mind, and then
derive an entirely different development methodology that is
customized to the special characteristics of that strict subset.

There are many properties of software that can be used for providing
a classification. Here we will focus on one particular ``axis'': how
\textbf{well understood} it is. The majority of the next section will
be devoted to explaining exactly what this means. Once that is set up,
we can then unravel some operational consequences: how the characteristics of
well understood softare lead to innovative methods of building such
software. As this might be perceived as too abstract, we give a very
concrete example. Of course, our ideas do not exist in a vacuum: we were
inspired by a number of connected ideas, and we then give credit where
credit is due. More than just ideas, there are also technologies that back
these ideas, some of which we're already using, others which lie in our
future, and we outline some of these as well.

\chapter{What is ``well understood'' Software?}
\chapter{How would you go building that?}
\chapter{Example}
\chapter{Connected Ideas}
\chapter{Some Useful Technologies}

\end{document}

Good quotes:
\begin{itemize}
\item metaprograms are just programs
\item models outside an integrated toolchain are insufficiently useful
\end{itemize}

