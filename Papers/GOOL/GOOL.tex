%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\begin{document}

%% Title information
\title{GOOL: A Generic Object-Oriented Language}         %% [Short 
%%Title] is optional;
                                        %% when present, will be used in
%                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Brooks MacLachlan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department of Computing and Software}              %% \department 
  %%is recommended
  \institution{McMaster University}            %% \institution is required
  \streetaddress{1280 Main Street West}
  \city{Hamilton}
  \state{Ontario}
  \postcode{L8S 4L8}
  \country{Canada}                    %% \country is recommended
}
\email{maclachb@mcmaster.ca}          %% \email is recommended

\author{Jacques Carette}
%\authornote{with author1 note}          %% \authornote is optional;
%% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
	\position{Position1}
	\department{Department of Computing and Software}              %% 
	%%\department is recommended
	\institution{McMaster University}            %% \institution is required
	\streetaddress{1280 Main Street West}
	\city{Hamilton}
	\state{Ontario}
	\postcode{L8S 4L8}
	\country{Canada}                    %% \country is recommended
}
\email{carette@mcmaster.ca}          %% \email is recommended

\author{Spencer Smith}
%\authornote{with author1 note}          %% \authornote is optional;
%% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
	\position{Position1}
	\department{Department of Computing and Software}              %% 
	%%\department is recommended
	\institution{McMaster University}            %% \institution is required
	\streetaddress{1280 Main Street West}
	\city{Hamilton}
	\state{Ontario}
	\postcode{L8S 4L8}
	\country{Canada}                    %% \country is recommended
}
\email{smiths@mcmaster.ca}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Given a task, before writing any code a programmer must select a programming 
language to use. Whatever they may base their choice upon, almost any
programming language will work. While a program may be more difficult to
express in one language over another, it should at least be possible to write
the program in either language. Just as the same sentence can be translated to
any spoken language, the same program can be written in any programming
language. Though they will accomplish the same tasks semantically, the
expressions of a program in different programming languages can appear
substantially different due to the unique syntax of each language. Within a
single programming language paradigm, such as object-oriented (OO) programming,
these differences should not be so extreme. OO programs, no matter the
language, share certain structural properties. They are built from variables,
methods, classes, and objects. Some OO languages even have very similar syntax.
But however similar they may be, no two programming languages are identical.

If a programmer wishes to write a program that will integrate into 
existing systems written in different languages, they will likely need to 
write a different version of the program for each. This 
requires investing the time to learn the idiosyncrasies of each language and 
give attention to the operational details where languages differ. Ultimately, 
the code they write will likely be marred by influences of the language they 
know best. They may consistently use techniques that they are familiar with 
from one language, while unaware that the language in which they are currently 
writing offers a better or cleaner way of doing the same task 
\cite{scholtz1990learning, alexandron2012effect}. Besides this 
likelihood of writing sub-optimal code, repeatedly writing the same program in 
different languages is entirely inefficient. 
Languages in the same paradigm have many similarities, and there is an 
excellent opportunity to take advantage of these similarities to improve the
efficiency of writing code. If a program could be written in one language and
automatically translated to any other language in the same paradigm, this would
greatly facilitate program reuse. Directly translating between existing 
OO languages will not always be possible because some languages 
require more information than others. A dynamically typed language like Python, 
for instance, cannot be straightforwardly translated to a statically typed 
language like Java, because additional type information would need to be 
provided. But if there was a language that contained all of the information 
that any of the other OO languages would need, it could be used as the source 
language for translation. This source language should also be completely 
language-agnostic, free of any of the idiosyncratic ``noise'' required by
specific languages. In addition, a translator for such a language would not be 
subject to the influences of any one target language when translating to a 
different target language; the code resulting from the translation should be 
well-suited to the target language.

The similarities between OO programs do not end with syntax and structural 
components. Additionally, there are tasks and patterns commonly performed by OO
programs in any language, from simple tasks like splitting a string or 
patterns like defining functions on inputs to produce outputs, to higher-level 
design patterns like those described in \cite{gamma1995design}. A language 
that provided abstractions for these tasks and patterns would make the process 
of writing OO code even easier.

A Domain-Specific Language (DSL) is a high-level programming language with 
syntax tailored to a specific domain \cite{mernik2005and}. DSLs allow domain 
experts 
to write code without having to concern themselves with the syntactical and
operational requirements of general-purpose programming languages. A DSL
abstracts over the details of the code, providing notation for a user to
specify domain-specific knowledge in a natural manner. DSL code is typically
compiled to a more traditional target language. Abstracting over code details
and compiling into traditional OO languages is exactly what we want our source
OO language to do. The code details to abstract over in this case include both
the operational details of using a specific language as well as the higher-level
patterns that commonly show up in OO programs. So the source language we are
looking for is just a DSL in the domain of OO programming languages!

There are DSLs already for generating code in multiple languages, and these 
will be discussed further in Section \ref{related}, but none of these have the 
combination of features we require. We should be able to generate OO code for 
any purpose, rather than being limited to a narrow domain of application. The 
generated code should be human-readable, so that it can be used in applications 
where understandability of the code is important. The DSL should generate 
idiomatic code. That is, code generated in each target language should be 
expressed naturally given the features and capabilities of that language. 
Finally, the DSL should provide facilities for generating code adhering to 
common high-level OO patterns. 

We have developed a Generic Object-Oriented Language (GOOL), proving that such 
a language indeed exists. GOOL is a DSL embedded in Haskell that can currently
generate OO code in Python, Java, C\#, and C++. Theoretically, any OO language 
could be added as a target language for GOOL. This paper presents GOOL, 
starting with the syntax of the language in Section \ref{syntax}. Section 
\ref{implementation} describes how GOOL is implemented. GOOL provides some 
higher-level functions for convenient generation of code following commonly 
used patterns, examples of which are presented in Section \ref{patterns}. We 
close with a discussion of related work in Section \ref{related}, plans for 
future improvements in Section \ref{future}, and conclusions in Section 
\ref{conclusions}.

\section{GOOL Syntax} \label{syntax}
\section{GOOL Implementation} \label{implementation}
\section{Higher-level GOOL functions} \label{patterns}
\section{Related Work} \label{related}
Haxe is a general-purpose multi-paradigm language and cross-platform compiler. 
It compiles to all of the languages GOOL does, in addition to many others. 
However, it does not offer the high-level abstractions GOOL provides 
\cite{Haxe} (better reference?). Also, the generated source code is not very 
readable as Haxe generates a lot of ``noise'' and strips comments from the 
original Haxe source code.

Protokit's 2nd version is a DSL and code generator for Java and C++, where the 
generator is designed to be capable of producing general-purpose imperative or 
object-oriented code. The Protokit generator is model-driven and uses a final 
``output model'' from which actual code can be trivially generated. Since the 
``output model'' was so similar to the generated code, it presented challenges 
with regards to semantic, conventional, and library-related differences between 
the target language \cite{kovesdan2017multi}. GOOL's finally-tagless approach 
and syntax for high-level tasks, on the other hand, helped it overcome 
differences between target languages.

ThingML \cite{harrand2016thingml} is a DSL for model-driven engineering 
targeting C, C++, Java, and 
JavaScript. While it can be used in a broad range of application domains, they 
all fall under the umbrella domain of distributed reactive systems, and so it 
is not quite a general-purpose DSL, unlike GOOL. ThingML's modelling-related 
syntax and abstractions are a contrast to GOOL's object-oriented syntax and 
abstractions. The generated code lacks some of the pretty-printing provided by 
GOOL, specifically indentation, which detracts from the readability.

IBM developed a DSL for automatic generation of OO code based on design 
patterns \cite{budinsky1996automatic}. Their DSL was in the form of a visual 
user interface rather than a programming language, and could only generate code 
that followed a design pattern. It could not generate any general-purpose code.

There are many examples of DSLs with multiple OO target languages but for a 
more restricted domain. Google protocol buffers is a DSL for serializing 
structured data, which can then be compiled into Java, Python, Objective C, and 
C++ \cite{Protobuf}. Thrift is a Facebook-developed tool for generating code in 
multiple languages and even multiple paradigms based on language-neutral 
descriptions of data types and interfaces \cite{slee2007thrift}. Clearwater is 
an approach for implementing DSLs with multiple target languages for components 
of distributed systems \cite{swint2005clearwater}. The Time Weaver tool uses a 
multi-language code generator to generate ``glue'' code for real-time embedded 
systems \cite{de2004glue}. The domain of mobile 
applications is host to a bevy of DSLs with multiple target languages, of which 
MobDSL \cite{kramer2010mobdsl} and XIS-Mobile \cite{ribeiro2014xis} are two 
examples. Conjure is a DSL for generating APIs. It reads YML descriptions of 
APIs and can generate code in Java, TypeScript, Python, and Rust 
\cite{Conjure}. All of these are examples of multi-language code generation, 
but none of them generate general-purpose code like GOOL does.

\section{Future Work} \label{future}
\section{Conclusion} \label{conclusions}


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
\bibliography{References}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
