%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{listings}

\begin{document}

%% Title information
\title{GOOL: A Generic Object-Oriented Language}         %% [Short 
%%Title] is optional;
                                        %% when present, will be used in
%                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Brooks MacLachlan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department of Computing and Software}              %% \department 
  %%is recommended
  \institution{McMaster University}            %% \institution is required
  \streetaddress{1280 Main Street West}
  \city{Hamilton}
  \state{Ontario}
  \postcode{L8S 4L8}
  \country{Canada}                    %% \country is recommended
}
\email{maclachb@mcmaster.ca}          %% \email is recommended

\author{Jacques Carette}
%\authornote{with author1 note}          %% \authornote is optional;
%% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
	\position{Position1}
	\department{Department of Computing and Software}              %% 
	%%\department is recommended
	\institution{McMaster University}            %% \institution is required
	\streetaddress{1280 Main Street West}
	\city{Hamilton}
	\state{Ontario}
	\postcode{L8S 4L8}
	\country{Canada}                    %% \country is recommended
}
\email{carette@mcmaster.ca}          %% \email is recommended

\author{Spencer Smith}
%\authornote{with author1 note}          %% \authornote is optional;
%% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
	\position{Position1}
	\department{Department of Computing and Software}              %% 
	%%\department is recommended
	\institution{McMaster University}            %% \institution is required
	\streetaddress{1280 Main Street West}
	\city{Hamilton}
	\state{Ontario}
	\postcode{L8S 4L8}
	\country{Canada}                    %% \country is recommended
}
\email{smiths@mcmaster.ca}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Given a task, before writing any code a programmer must select a programming 
language to use. Whatever they may base their choice upon, almost any
programming language will work. While a program may be more difficult to
express in one language over another, it should at least be possible to write
the program in either language. Just as the same sentence can be translated to
any spoken language, the same program can be written in any programming
language. Though they will accomplish the same tasks, the
expressions of a program in different programming languages can appear
substantially different due to the unique syntax of each language. Within a
single language paradigm, such as object-oriented (OO),
these differences should not be as extreme -- at least the global structuring
mechanisms and the local idioms will be shared.  Mainstream OO languages
generally contain (mutable) variables, methods, classes, objects and a core
imperative set of primitives. Some OO languages even have very similar syntax
(such as Java and C\# say).

When faced with the task to write a program meant to fit into multiple existing
infrastructure, which might be written in different languages, frequently that
entails writing different versions of the program, one for each. While not
necessarily difficult, it nevertheless
requires investing the time to learn the idiosyncrasies of each language and 
pay attention to the operational details where languages differ. Ultimately, 
the code will likely be marred by influences of the language the programmer 
knows best. They may consistently use techniques that they are familiar with 
from one language, while unaware that the language in which they are currently 
writing offers a better or cleaner way of doing the same task 
\cite{scholtz1990learning, alexandron2012effect}. Besides this 
likelihood of writing sub-optimal code, repeatedly writing the same program in 
different languages is entirely inefficient, both as an up-front development cost,
and even more so for maintenance.

Since languages from the same paradigm share many semantic similarities,
it is tempting to try to leverage this; perhaps the program could be written in
one language and
automatically translated to the others?  But a direct translation is often
difficult, as different languages require the programmer to provide different
levels of information, even to achieve the same taks.  For example, a dynamically
typed language like Python
cannot be straightforwardly translated to a statically typed 
language like Java, as additional type information generally needs to be 
provided\footnote{Type inference for Python notwithstanding}.

What if, instead, there was a single meta-language which was designed to
contain the common semantic concepts of a number of OO languages, encoded
in such a way that all the necessary information for translation was always
present?  This source language could be made to be agnostic about what
eventual target language was used -- free of the idiosyncratic details of
any given language.  This would be quite the boon for the translator.
In fact, we could try to go even further, and attempt to teach the translator
about idiomatic patterns of each target language.

Why would this even be possible? There are commonly performed tasks and
patterns of OO solutions, from idioms to architecture patterns, as outlined
in~\cite{gamma1995design}. A meta-language 
that provided abstractions for these tasks and patterns would make the process 
of writing OO code even easier.

But is this even feasible? In some sense, this is already old hat: most
modern compilers have a single internal Intermediate Representation (IR)
which is used to target multiple processors. Compilers can generate
human-readable symbolic assembly code for a large family of CPUs. But this
is not quite the same as generating human-readable, idiomatic high-level
languages.

There is another area where something like this has been looked at:
the production of high-level code from Domain-Specific Languages (DSL).
A DSL is a high-level programming language with syntax and semantics tailored
to a specific domain \cite{mernik2005and}. DSLs allow domain experts 
to write code without having to concern themselves with the details of
General-Purpose programming Languages (GPL). A DSL
abstracts over the details of the code, providing notation for a user to
specify domain-specific knowledge in a natural manner. Such DSL code is typically
translated to a GPL for execution. Abstracting over code details
and compiling into traditional OO languages is exactly what we want to do!
The details to abstract over include both syntactic and operational details of
any specific language, but also higher-level idioms in common use.  Thus
the language we are looking for
is just a DSL in the domain of OO programming languages!

There are some DSLs that already generate code in multiple languages, to be
further discussed in Section \ref{related}, but none of them have the 
combination of features we require. We are indeed trying to do something odd:
writing a ``DSL'' for what is essentially the domain of OO GPLs. Furthermore,
we have additional requirements:
\begin{enumerate}
\item The generated code should be human-readable,
\item The generated code should be idiomatic,
\item The generated code should be documented,
\item The generator should allow one to express common OO patterns.
\end{enumerate}

We have developed a Generic Object-Oriented Language (GOOL), demonstrating
that all these requirements can be met.  GOOL is a DSL embedded in Haskell that
can currently generate code in Python, Java, C\#, and C++%
\footnote{and is close to generating Lua and Objective-C, but those backends
have fallen into disuse}. Others could be added, with the implementation
effort being commensurate to their (semantic) distance to the languages
already supported.

First we present the high-level requirements for such an endeavour, in
Section~\ref{sec:req}.  To be able to give illustrated examples, we
next show the syntax of GOOL in Section~\ref{syntax}. The details of
the implementations, namely the internal representation and the
family of pretty-printers, is in Section~\ref{implementation}.
Common patterns are illustrated in Section~\ref{patterns}.  We 
close with a discussion of related work in Section \ref{related}, plans for 
future improvements in Section \ref{future}, and conclusions in Section 
\ref{conclusions}.

\section{Requirements} \label{sec:req}

One might not expect a DSL to prioritize generation of human-readable, 
idiomatic, or documented code. After all, the main purpose of a DSL is to allow 
the user of the DSL --- who is probably a domain expert but not a programming 
expert --- to avoid having to write GPL code, so why would they want to look at 
the generated GPL code? For programs written in most DSLs, the generated code 
is not itself the goal. The goal is to do something, and the form of the 
generated code is unimportant, as long as running it achieves that goal. In 
this respect, GOOL differs from most DSLs. Since the domain of GOOL is OO 
programming, the user of GOOL is expected to have some programming expertise. 
In a sense, GOOL is both a GPL and a DSL. GOOL's main purpose, rather than 
allowing the user to not have to write GPL code, is to allow the user to not 
have to write GPL code in multiple languages. As with other DSLs, completing 
some required task will certainly be a goal of a program written in GOOL. But 
since GOOL is general-purpose, we cannot assume that the generated code will 
not be an additional goal unto itself. For example, if it is to be integrated 
into an existing system, other programmers working on the system may need to 
look at and understand the code and how it impacts their own tasks. Or perhaps 
the generated code is a library, intended to be used by any project who sees a 
need for it.

In light of cases like these, the importance of our requirements for GOOL to 
generate human-readable, idiomatic, and documented code should be clear. These 
all contribute to understandability of the generated code. Documentation can 
explain code such that those using a program or library can do so quickly, 
without even having to look at the code. Documentation may take the form of 
comments added ad-hoc throughout the code, or more formal, structured comments 
that can be compiled into PDF or HTML documents using a tool like Doxygen. 
Documentation cannot be guaranteed to provide all of the information a user of 
the generated code may need, however, which is why generating human-readable 
code is still important. 

Details not revealed by the documentation should be 
discernible by examining and understanding the code. Readable code is also 
important when it comes to debugging. Being unable to understand parts of a 
system would make diagnosing bugs very difficult. Pretty-printing and reducing 
complexity are effective ways to enhance code readability 
\cite{buse2009learning}. Some DSLs complicate generated code by generating it 
into a custom framework, but GOOL must avoid this to retain readability. 

It should be noted that our requirements for the generated code to be 
documented and readable only hold if the code written in GOOL is documented and 
readable. Inevitably, a user will be able to write undocumented or overly 
complex code if they choose to do so. Our requirement is that GOOL at least 
offers a way to document the code, does not strip away code comments, 
pretty-prints the generated code, and does not introduce more complexity than 
required to meet the GOOL specification.

The importance of generating idiomatic code is perhaps not as obvious as 
readable and documented code. Consider a project written entirely in one 
language. If it uses generated code from GOOL and the code is non-idiomatic, it 
will be inconsistent with the rest of the code base and less understandable, 
both because it would be more complicated than it needs to be and because it 
would not be expressed naturally in the target language, not using the idioms 
with which the developers would be most familiar.

Our last requirement is altogether different from the others, but is 
typical of DSLs: GOOL should abstract over common OO patterns, allowing them to 
be expressed naturally. The patterns in question could abstract over 
small-scale idioms or could be larger-scale OO design patterns. While the 
motivation for this requirement is partly to make it even more efficient to 
write code in GOOL than in any of its target languages, there is more to it 
than that. This requirement is also necessary to make GOOL truly 
language-agnostic and to generate idiomatic code. This fact will be 
demonstrated with the examples of patterns shown in Section \ref{patterns}, but 
to understand why abstractions over patterns are needed, consider Python's 
ability to return multiple values with a single return statement. Other OO 
languages do not allow this, so either GOOL could also disallow it or GOOL 
could provide syntax for it but throw an error if it was used when targeting 
one of the languages that does not support it. In the first case, if a user of
GOOL wanted to return multiple values and target Python, they would have to 
work around the lack of a multiple-value return statement and the generated 
code would therefore be non-idiomatic. But in the second case, if the user 
wanted to target both Python and a language that does not support 
multiple-value return statements, the GOOL code would have to be different when 
targeting Python than when targeting the other language, so GOOL would not be 
truly language-agnostic. The higher-level pattern that would require a 
multiple-value return statement is a function with multiple outputs. If GOOL
abstracted over that pattern and provided syntax for defining multiple-output 
functions, the code generator can generate a multiple-value return statement in 
Python and something different in the other language. In this way, the same 
GOOL code can truly be compiled into idiomatic code in any target language.

\section{GOOL Syntax} \label{syntax}

GOOL's syntax was designed to be similar to OO languages while also providing 
useful abstractions. Basic types in GOOL are \verb|bool| for Booleans, 
\verb|int| for integers, \verb|float| for doubles, \verb|char| 
for characters, \verb|string| for strings, \verb|infile| for a file 
in read mode, and \verb|outfile| for a file in write mode. Lists can be 
specified with \verb|listType|. For example, \verb|listType int| 
specifies a list of integers. Types of objects are specified using 
\verb|obj| followed by the class name, so \verb|obj "FooClass"| is the type of 
an object of a class called ``FooClass''. 

Variables are specified with \verb|var| followed by the variable name and type. 
For example, \verb|var "ages" (listType int)| defines a variable called 
``ages'' that is a list of integers. GOOL offers a shortcut for defining 
list-type variables with \verb|listVar|, so the ``ages'' variable could 
alternatively be specified by \verb|listVar "ages" int|. Since GOOL is embedded 
in Haskell, such a variable definition can be assigned as the value of a 
Haskell function:
\begin{lstlisting}
ages = listVar "ages" int
\end{lstlisting}
Then, in future code the variable can be referred to simply by \verb|ages|. 
Other keywords for specifying variables include \verb|extVar| for variables 
from external libraries, \verb|classVar| for accessing variables from a class, 
\verb|objVar| for accessing variables from an object, and \verb|self| for 
referring to an object in its own class definition, equivalent to \verb|self| 
in Python or \verb|this| in Java. The infix operator \verb|$->| is an 
alternative to the \verb|objVar| keyword.

Unlike in most OO languages, the syntax of GOOL distinguishes a variable from 
its value. To actually use the value of the \verb|ages| variable defined above, 
one must write \verb|valueOf ages|. This highlights another goal in developing 
the syntax of GOOL. We did not want to simply look at the syntax of existing OO 
languages and develop a parallel syntax for GOOL. Instead, we considered 
semantics, and aimed to provide different syntax for semantically different 
tasks. In most languages, writing a variable's name is the syntax both for 
referring to the variable as a variable and referring to the variable's value, 
but since these are semantically different tasks, GOOL provides different 
syntax for each. Having distinguishing syntax for semantically distinguishable 
tasks enables stricter typing and higher-level syntax that translates to more 
idiomatic code, which will become apparent in future sections of this paper.

Literal values can be referred to by \verb|litTrue|, \verb|litFalse|, 
\verb|litInt|, \verb|litFloat|, \verb|litChar|, and \verb|litString|. Similar 
to those seen in most programming languages, GOOL provides many unary prefix 
operators and binary infix operators for defining expressions. In GOOL, each 
operator is prefixed with an additional symbol based on type. Operators that 
return Booleans are prefixed by a \verb|?|, for example \verb|?!| is used for 
negation, \verb|?&&| for conjunction, \verb|?||| for disjunction, and
\verb|?==| for equality. Operators on numeric values are prefixed by \verb|#|, 
such as \verb|#~| for negation, \verb|#/^| for square root, \verb|#|| for 
absolute value, \verb|#%| for modulus, and \verb|#^| for exponentiation. Any 
other operators are prefixed by \verb|$|, such as the previously mentioned 
\verb|$->| operator for accessing a variable from an object.

A conditional value can be specified with the keyword \verb|inlineIf| followed 
by the condition, the value if the condition is true, and the value if the 
condition is false. For example, given a Boolean-type variable \verb|a|, the 
following conditional value can be constructed:
\begin{lstlisting}
inlineIf (valueOf a) 
  (litString "a is true") 
  (litString "a is false")
\end{lstlisting}
Note that since this is really just Haskell, values can extend across multiple 
lines as long as subsequent lines are indented.

Function application can be done with the keyword \verb|funcApp| followed by 
the function name, return type, and values to pass as parameters. Assuming one 
has defined a function ``add'' for adding two integers, it could be called like 
so:
\begin{lstlisting}
funcApp "add" int [litInt 5, litInt 4]
\end{lstlisting}
Other keywords for function application are \verb|extFuncApp| for when the 
function comes from an external library, \verb|newObj| and \verb|extNewObj| 
for calling an object constructor, and \\
\verb|objMethodCall| for calling a method on an object. \verb|selfFuncApp| and 
\verb|objMethodCallNoParams| are two shortcuts for the common cases when a 
method is being called on \verb|self| or when the method takes no parameters. 

If Haskell function \verb|foo| has been defined as GOOL variable 
\verb|var "foo" int|, a GOOL statement declaring the variable would be
\verb|varDec foo|. To declare and define the variable at the same time,
\verb|varDecDef foo (litInt 5)| can be used. Or to define the variable when it
has already been declared, \verb|assign foo (litInt 5)| can be used. Other GOOL 
keywords for declarations and definitions are \verb|constDecDef| for declaring 
and defining constants, \verb|listDec| and \verb|listDecDef| for declaring and 
defining lists, and \verb|objDecDef| for declaring and defining objects. 
\verb|objDecNew| is a shortcut for the common case where an object constructor 
is called to define an object, and \verb|objDecNewNoParams| is a further 
shortcut for when the constructor takes no parameters.

Infix and suffix operators for assignments, as seen in most programming 
languages, are also offered by GOOL. These are all prefixed with \verb|&|. 
Instead of \verb|assign a (litInt 5)|, an assignment can be written as 
\verb|a &= litInt 5|, which looks more like traditional programming languages. 
The other assignment operators are \verb|&+=| for adding a value to a variable, 
\verb|&++| for adding 1 to a variable, \verb|&-=| for subtracting a value 
from a variable, and \verb|&~-| for subtracting 1 from a variable 
(Unfortunately, the more intuitive \verb|&--| could not be used because 
\verb|--| initiates a comment in Haskell).

Other simple statements in GOOL include \verb|break| and \verb|continue|, 
\verb|returnState| followed by a value to return, \verb|throw| followed by an 
error message to throw, \verb|free| followed by a variable to free from
memory, and \verb|comment| followed by a string to be displayed as a 
single-line comment.

GOOL statements can be grouped together into blocks by specifying a list of 
statements after the \verb|block| keyword. A GOOL body can then be made by 
specifying a list of blocks after the \verb|body| keyword. A body can be used 
as a function body, conditional body, loop body, or similar. The purpose of 
blocks as an intermediate structure between statement and body is to allow for 
more organized, readable generated code. For example, the generator can choose 
to insert a blank line between blocks so lines of code related to the same task 
are visually grouped together. However, for the case where there is no need for 
distinct blocks in a body, the body can be made directly from a list of 
statements with \verb|bodyFromStatements| or even from a single statement with 
\verb|oneLiner|. 
 
As alluded to before, bodies can be used in more complex statements like 
conditionals and loops. An if-then-else statement can be written in GOOL as 
\verb|ifCond| followed by a list of condition-body pairs and then a final body 
for the else. An example is shown below.
\begin{lstlisting}
ifCond [
  (foo ?> litInt 0, oneLiner (
    printStrLn "foo is positive")),
  (foo ?< litInt 0, oneLiner (
    printStrLn "foo is negative"))] 
  (oneLiner $ printStrLn "foo is zero")
\end{lstlisting}
\verb|ifNoElse| can be used in place of \verb|ifCond| for when there is no else 
condition. GOOL also supports \verb|switch| statements. A for-loop can be 
written in GOOL as \verb|for| followed by a statement to 
initialize the loop variable, a condition, a statement to update the loop 
variable, and a body. GOOL also offers \verb|forRange| loops, which are given a 
starting value, ending value, and step size, as well as \verb|forEach| loops. 
The following examples assume variable \verb|age| and \verb|ages| and body 
\verb|loopBody| have already been defined:
\begin{lstlisting}
for (varDecDef age (litInt 0)) 
  (age < litInt 10) (age &++) loopBody
forRange age (litInt 0) (litInt 9) 
  (litInt 1) loopBody
forEach age ages loopBody
\end{lstlisting}
While-loops are also available, using keyword \verb|while| followed by the 
condition and body. Finally, GOOL offers try-catch statements, which are 
written as \verb|tryCatch| followed by a body to try and a body for when an 
exception is caught.

A function in GOOL is specified by \verb|function| followed by the function 
name, scope, either static or dynamic binding, type, list of parameters, and 
body. Methods are defined similarly, using the \verb|method| keyword, with the 
only other difference from functions being that the name of the class 
containing the method must be specified. Parameters are built from variables, 
using \verb|param| or \verb|pointerParam|. The ``add'' function called in 
an earlier example can thus be defined like so, assuming variables ``num1'' and 
``num2'' have been defined:
\begin{lstlisting}
function "add" public dynamic_ int 
  [param num1, param num2] 
  (oneLiner (returnState (num1 #+ num2)))
\end{lstlisting}
The  \verb|pubMethod| and \verb|privMethod| shortcuts can be used for public 
dynamic methods and private dynamic methods, respectively. \verb|mainFunction| 
followed by a body defines the main function of a program. A documented 
function can be generated with \verb|docFunc| followed by a brief function 
description, a list of parameter descriptions, a description of what is 
returned (if applicable), and lastly the function itself. A documented function 
will have comments in Doxygen-style, and GOOL offers further support for 
compiling Doxygen documentation, to be discussed at the end of this section.

Classes are defined with \verb|buildClass| followed by the class name, name of 
the parent class (if applicable), scope, list of state variables, and list of 
methods. State variables can be built by \verb|stateVar| followed by an 
integer, scope, static or dynamic binding, and the variable itself. The integer 
is a measure of delete priority. \verb|constVar| can be used for constant state 
variables. Shortcuts for state variables include \verb|privMVar| for private 
dynamic, \verb|pubMVar| for public dynamic, and \verb|pubGVar| for public 
static variables. Assuming variables ``var1'' and ``var2'' and methods ``mth1'' 
and ``mth2'' have been defined, a class containing them all can be defined as:
\begin{lstlisting}
buildClass "FooClass" Nothing public 
  [pubMVar 0 var1, privMVar 0 var2] 
  [mth1, mth2]
\end{lstlisting}
``Nothing'' indicates that this class does not have a parent. \verb|privClass| 
and \verb|pubClass| are shortcuts for private and public classes, respectively. 
Classes can be documented using \verb|docClass| followed by a description of 
the class then the class itself. Like with functions, the documentation will be 
in Doxygen-style.

Functions and classes can be grouped together into a GOOL module using 
\verb|buildModule|, followed by the module name, a list of libraries to import, 
the list of functions, and the list of classes. Passing a module to 
\verb|fileDoc| will put the finishing touches on the generated file, such as 
imports of standard libraries and preprocessor guards for C++ header files. 
\begin{lstlisting}
fileDoc $ buildModule "mod1" ["library1"] 
  [func1, func2] [class1, class2] 
\end{lstlisting}
Documenting a file with a Doxygen-style file header can be done with 
\verb|docMod| followed by a file description, list of author names, date 
string, and then the file, specified in GOOL,  to document.

Finally, at the top of the GOOL hierarchy are programs, auxiliary files, and 
packages. A program is constructed by passing a program name and list of files 
to \verb|prog|. Then a program and a list of auxiliary files can be passed to 
\verb|package| to create a complete package, specified in GOOL. Auxiliary files 
are non-OO code files that augment the OO program. For example, a Doxygen 
configuration file is an auxiliary file that can be specified using the 
\verb|doxConfig| keyword, and a makefile is another auxiliary file that can be 
specified with the \verb|makefile| keyword. One of the parameters to the 
\verb|makefile| keyword will toggle generation of a \verb|make doc| rule, which 
will compile the Doxygen documentation with the generated Doxygen configuration 
file.

Syntax for higher-level patterns will be discussed in Section \ref{patterns}.

\section{GOOL Implementation} \label{implementation}

GOOL is embedded in Haskell in the finally-tagless style originally described 
in \cite{carette2009finally}. In finally-tagless style, the internal 
representation of an embedded DSL is a group of functions defined in the host 
language, rather than the more traditional use of data constructors to build an 
interpretable abstract syntax tree (AST) for the DSL. Whereas an AST of data 
constructors must have a separately-defined interpreter, the functions 
themselves in finally-tagless compose to form the interpreter; the definitions 
of the functions describe how each is interpreted. Thus, the GOOL ``keywords'' 
referred to in the previous section were really Haskell functions that, when 
resolved, yield representations of the code to be generated. 

Finally-tagless facilitates development of a family of interpreters for a DSL 
by having the functions act on representations, where a type class in Haskell 
is used to abstract over the representation. The authors of 
\cite{carette2009finally} coined the term ``symantic'' to describe such a type 
class, because the interface of the type class defines the syntax of the DSL 
and the instances of the type class define the semantics. A separate type class 
instance is written for each representation, each corresponding to one member 
in the family of interpreters. This suits GOOL's needs nicely, for GOOL 
requires multiple interpreters (one for each target language) of the same 
language (GOOL).

GOOL is a collection of these "symantic" type classes and instances. For 
organizational purposes, the functions comprising GOOL's syntax are split 
across many type classes, roughly based on the internal types upon which the 
functions act. GOOL's internal types correspond to the types of code being 
represented, not the types of the values in the target languages, though adding 
value-types to GOOL's type system is planned for the future, discussed further 
in Section \ref{future}. Examples of internal types in GOOL, then, are 
\verb|Variable|, \verb|Value|, \verb|Type|, \verb|Scope|, \verb|Statement|, 
\verb|Method|, \verb|Class|, \verb|Module|, and \verb|Program|. A 
\verb|Statement| in GOOL, for example, is a representation of a piece of code 
that is a statement. Below is an excerpt of GOOL's definition for the 
\verb|VariableSym| type class; that is, the type class containing functions for 
defining variables in GOOL.
\begin{lstlisting}
class (TypeSym repr) 
  => VariableSym repr where
    type Variable repr
    var :: Label -> repr (Type repr) 
             -> repr (Variable repr)
\end{lstlisting}
Since variables have types, a type for representing variables must also know 
how to represent types, thus we constrain our \verb|repr| type variable to be 
an instance of \verb|TypeSym|, the symantic type class containing functions for 
representing types, like the \verb|int|, \verb|float|, \verb|string|, and 
\verb|listType| functions described in Section \ref{syntax}. 

The types used in the signatures of GOOL's functions have the general form 
\verb|repr| \verb|(X repr)| for some type \verb|X|, examples of which can be 
seen in the type signature for \verb|var|. To understand these types, first 
remember that we will write different instances of this type class for each 
different language GOOL targets. That means the \verb|repr| type variable will 
be instantiated with a type that represents code in a specific target language. 
In the \verb|repr| \verb|(X repr)| types, the type variable \verb|repr| appears 
twice because there are two layers of abstraction: abstraction over the target 
language, handled by the outer \verb|repr|, and abstraction over the underlying 
types to which GOOL's types map, handled by the inner \verb|repr|.

This abstraction over the underlying types that GOOL's types represent happens 
because \verb|X repr| is a type family. The first line of the body of the 
\verb|VariableSym| typeclass is \verb|type| \verb|Variable| \verb|repr|. This 
line declares the type family \verb|Variable| \verb|repr|. Since the type is 
parameterized by \verb|repr|, each instance we write of this typeclass can 
define the \verb|Variable| family member differently. Usually different 
renderers will use the same underlying type for a given GOOL type, but the 
ability to change it on a per-target-language basis is useful for when a 
language requires storing more or less information than others.

The type signature for the \verb|var| function says that \verb|var| takes a 
label and a representation of a type and yields a representation of a variable. 
This should not be surprising given how we used \verb|var| to define variables 
like \verb|var| \verb|"foo"| \verb|int| in Section \ref{syntax}. \verb|Label| 
is simply a Haskell type synonym for \verb|String|. 

Shown below is the instance of the type class excerpt shown above for 
generating Java code. 
\begin{lstlisting}
instance VariableSym JavaCode where
  type Variable JavaCode = VarData
  var = varD
\end{lstlisting}
We have instantiated \verb|repr| as \verb|JavaCode|, which is a monad defined 
as:
\begin{lstlisting}
newtype JavaCode a = JC {unJC :: a}
\end{lstlisting}
\verb|unJC| extracts the underlying value from a value wrapped in 
\verb|JavaCode|. Calling \verb|unJC| on a program written in GOOL allows 
Haskell to infer that the \verb|repr| in the GOOL program should be concretized 
as \verb|JavaCode| and to resolve the functions using the definitions from the 
\verb|JavaCode| instances of the type classes, thereby generating Java code.

The second line of the instance states that the underlying type for 
\verb|Variable|s in Java is \verb|VarData|, which is a record that holds data 
about the variable to be used later. The definition of \verb|VarData| is shown 
below.
\begin{lstlisting}
data VarData = VarD {
  varBind :: Binding, 
  varName :: String, 
  varType :: TypeData, 
  varDoc :: Doc}
\end{lstlisting}
Stored in the \verb|VarData| structure is a variable's binding, either 
\verb|Static| or \verb|Dynamic|, the name of the variable as a \verb|String|, 
the type as a \verb|TypeData| structure, which is the underlying type for 
\verb|Type|s in GOOL for Java, and how the variable should appear in the 
generated code, represented as a \verb|Doc|. \verb|Doc| comes from the 
\verb|Text.PrettyPrint.HughesPJ| Haskell package and represents formatted text. 
In common between all of GOOL's underlying data structures is that they each 
contain a \verb|Doc|. For some types, like a \verb|Block|, the underlying type 
is in fact nothing more than a \verb|Doc|. The \verb|Program|-level \verb|Doc|s 
are ultimately what will be printed to files to generate code. Keeping in mind 
that a \verb|VarData| structure will usually be wrapped in a \verb|repr|, such 
as \verb|JavaCode|, the pieces of the wrapped \verb|VarData| can be accessed in 
one of two ways. The first way is to use Haskell's \verb|fmap| in combination 
with the built-in accessor functions for \verb|VarData|. For example, 
\verb|fmap| \verb|varDoc| will take a \verb|VarData| and return a 
\verb|JavaCode| \verb|Doc|. Functions on \verb|Doc|s can then be lifted to work 
on \verb|JavaCode| \verb|Doc|s using Haskell's \verb|liftA| family of 
functions. This method only works if the \verb|Variable| \verb|repr| is known 
to be equivalent to \verb|VarData|, though. That is, it works in the context of 
\verb|JavaCode| but not in a generic \verb|repr| context. For when one needs to 
access a piece of \verb|VarData| while in a generic \verb|repr| context, GOOL 
offers its own ``symantic'' accessor functions. For example, \verb|variableDoc| 
is part of the \verb|VariableSym| type class, with signature:
\begin{lstlisting}
variableDoc :: repr (Variable repr) 
                 -> Doc
\end{lstlisting}
and definition for the \verb|JavaCode| instance:
\begin{lstlisting}
variableDoc = varDoc . unJC
\end{lstlisting}
Since \verb|variableDoc| is part of the type class, it can be used in a generic 
\verb|repr| context, and since its definition is in an instance of the type 
class where \verb|Variable| \verb|repr| is known to resolve to \verb|VarData|, 
it can be defined simply by calling the \verb|varDoc| accessor on the unwrapped 
\verb|VarData|. GOOL offers many functions similar to \verb|variableDoc|, for 
accessing the other pieces of \verb|VarData| and for accessing the pieces of 
the underlying data structures for other internal GOOL types.
\section{Higher-level GOOL functions} \label{patterns}
- simple examples: log, sin, etc.  , args \\
- bigger examples: print, listAppend, listSize \\
- even bigger examples: listSlice, inOutFunc, inOutCall, getMethod, setMethod \\
- design patterns: runStrategy, checkState, addObserver, initObserverList \\
- auxiliary files
\section{Related Work} \label{related}

We divide the Related Work into the following categories
\begin{itemize}
\item cat 1
\item cat 2
\item cat 3
\end{itemize}
which we present in turn.

Haxe is a general-purpose multi-paradigm language and cross-platform compiler. 
It compiles to all of the languages GOOL does, in addition to many others. 
However, it does not offer the high-level abstractions GOOL provides 
\cite{Haxe} (better reference?). Also, the generated source code is not very 
readable as Haxe generates a lot of ``noise'' and strips comments from the 
original Haxe source code.

Protokit's 2nd version is a DSL and code generator for Java and C++, where the 
generator is designed to be capable of producing general-purpose imperative or 
object-oriented code. The Protokit generator is model-driven and uses a final 
``output model'' from which actual code can be trivially generated. Since the 
``output model'' was so similar to the generated code, it presented challenges 
with regards to semantic, conventional, and library-related differences between 
the target language \cite{kovesdan2017multi}. GOOL's finally-tagless approach 
and syntax for high-level tasks, on the other hand, helped it overcome 
differences between target languages.

ThingML \cite{harrand2016thingml} is a DSL for model-driven engineering 
targeting C, C++, Java, and 
JavaScript. While it can be used in a broad range of application domains, they 
all fall under the umbrella domain of distributed reactive systems, and so it 
is not quite a general-purpose DSL, unlike GOOL. ThingML's modelling-related 
syntax and abstractions are a contrast to GOOL's object-oriented syntax and 
abstractions. The generated code lacks some of the pretty-printing provided by 
GOOL, specifically indentation, which detracts from the readability.

IBM developed a DSL for automatic generation of OO code based on design 
patterns \cite{budinsky1996automatic}. Their DSL was in the form of a visual 
user interface rather than a programming language, and could only generate code 
that followed a design pattern. It could not generate any general-purpose code.

There are many examples of DSLs with multiple OO target languages but for a 
more restricted domain. Google protocol buffers is a DSL for serializing 
structured data, which can then be compiled into Java, Python, Objective C, and 
C++ \cite{Protobuf}. Thrift is a Facebook-developed tool for generating code in 
multiple languages and even multiple paradigms based on language-neutral 
descriptions of data types and interfaces \cite{slee2007thrift}. Clearwater is 
an approach for implementing DSLs with multiple target languages for components 
of distributed systems \cite{swint2005clearwater}. The Time Weaver tool uses a 
multi-language code generator to generate ``glue'' code for real-time embedded 
systems \cite{de2004glue}. The domain of mobile 
applications is host to a bevy of DSLs with multiple target languages, of which 
MobDSL \cite{kramer2010mobdsl} and XIS-Mobile \cite{ribeiro2014xis} are two 
examples. Conjure is a DSL for generating APIs. It reads YML descriptions of 
APIs and can generate code in Java, TypeScript, Python, and Rust 
\cite{Conjure}. All of these are examples of multi-language code generation, 
but none of them generate general-purpose code like GOOL does.

\section{Future Work} \label{future}
\section{Conclusion} \label{conclusions}


%% Acknowledgments
%\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
%\end{acks}


%% Bibliography
\bibliography{References}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
