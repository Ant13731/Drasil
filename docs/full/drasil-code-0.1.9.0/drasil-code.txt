-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Code SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-code
@version 0.1.9.0


-- | Defines chunk types for use in code generation.
module Language.Drasil.Chunk.Code
class CodeIdea c
codeName :: CodeIdea c => c -> String
codeChunk :: CodeIdea c => c -> CodeChunk
data CodeChunk
CodeC :: QuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> QuantityDict
[kind] :: CodeChunk -> VarOrFunc
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc
obv :: Lens' CodeVarChunk (Maybe CodeChunk)

-- | Construct a CodeVarChunk from a Quantity
quantvar :: (Quantity c, MayHaveUnit c) => c -> CodeVarChunk

-- | Construct a CodeFuncChunk from a Quantity
quantfunc :: (Quantity c, MayHaveUnit c) => c -> CodeFuncChunk
ccObjVar :: CodeVarChunk -> CodeVarChunk -> CodeVarChunk

-- | Get a list of CodeChunks from an equation
codevars :: Expr -> ChunkDB -> [CodeVarChunk]

-- | Get a list of CodeChunks from an equation (no functions)
codevars' :: Expr -> ChunkDB -> [CodeVarChunk]
funcResolve :: ChunkDB -> UID -> CodeFuncChunk
varResolve :: ChunkDB -> UID -> CodeVarChunk
listToArray :: CodeVarChunk -> CodeVarChunk
type ConstraintMap = Map UID [Constraint]
constraintMap :: (HasUID c, Constrained c) => [c] -> ConstraintMap
physLookup :: HasUID q => ConstraintMap -> q -> (q, [Constraint])
sfwrLookup :: HasUID q => ConstraintMap -> q -> (q, [Constraint])
programName :: CommonIdea c => c -> String
funcPrefix :: String
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.Callable Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Chunk.Code.CodeIdea Language.Drasil.Chunk.Code.CodeFuncChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Code.CodeFuncChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Chunk.Code.CodeIdea Language.Drasil.Chunk.Code.CodeVarChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Code.CodeVarChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Chunk.Code.CodeIdea Language.Drasil.Chunk.Code.CodeChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Code.CodeChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Code.CodeChunk

module Language.Drasil.Chunk.Parameter
data PassBy
Val :: PassBy
Ref :: PassBy
data ParameterChunk
PC :: CodeChunk -> PassBy -> ParameterChunk
[_pcc] :: ParameterChunk -> CodeChunk
[passBy] :: ParameterChunk -> PassBy

-- | Automatically chooses PassBy based on Space (Vectors and Actors passed
--   by reference)
pcAuto :: CodeIdea c => c -> ParameterChunk
pcVal :: CodeIdea c => c -> ParameterChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Chunk.Code.CodeIdea Language.Drasil.Chunk.Parameter.ParameterChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Parameter.ParameterChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Parameter.ParameterChunk


-- | Defines the <a>Code</a> data type
module Language.Drasil.Code.Code

-- | Represents the generated code as a list of file names and rendered
--   code pairs
newtype Code
Code :: [(FilePath, Doc)] -> Code
[unCode] :: Code -> [(FilePath, Doc)]
spaceToCodeType :: Space -> [CodeType]


-- | Defines QuantityDicts needed in the code generation stage.
module Language.Drasil.Code.CodeQuantityDicts
inFileName :: QuantityDict
inParams :: QuantityDict
consts :: QuantityDict

module Language.Drasil.Code.DataDesc
type DataItem = CodeVarChunk
data DataDesc'
DD :: Data' -> Delimiter -> DataDesc' -> DataDesc'
End :: Data' -> DataDesc'
data Data'
Datum :: DataItem' -> Data'
Data :: NonEmpty DataItem' -> Integer -> Delimiter -> Data'
Junk :: Data'
data DataItem'
DI :: CodeVarChunk -> [Delimiter] -> DataItem'
type Delimiter = String
dataDesc :: [Data'] -> Delimiter -> DataDesc'
singleton' :: CodeVarChunk -> Data'
list :: CodeVarChunk -> [Delimiter] -> Data'
interwovenLists :: [DataItem'] -> Integer -> Delimiter -> Data'
junk :: Data'
type DataDesc = [Data]
type Delim = Char
data Data
Singleton :: DataItem -> Data
JunkData :: Data
Line :: LinePattern -> Delim -> Data
Lines :: LinePattern -> Maybe Integer -> Delim -> Data
data LinePattern
Straight :: [DataItem] -> LinePattern
Repeat :: [DataItem] -> LinePattern
singleton :: DataItem -> Data
junkLine :: Data
singleLine :: LinePattern -> Delim -> Data
multiLine :: LinePattern -> Delim -> Data
multiLine' :: LinePattern -> Integer -> Delim -> Data
straight :: [DataItem] -> LinePattern
repeated :: [DataItem] -> LinePattern
isJunk :: Data -> Bool
isLine :: Data -> Bool
isLines :: Data -> Bool
getInputs :: DataDesc -> [DataItem]
getDataInputs :: Data -> [DataItem]
getPatternInputs :: LinePattern -> [DataItem]

module Language.Drasil.Code.Imperative.Build.AST
type CommandFragment = MakeString
data BuildName
BMain :: BuildName
BPackName :: BuildName
BPack :: BuildName -> BuildName
BWithExt :: BuildName -> Ext -> BuildName
data Ext
CodeExt :: Ext
OtherExt :: MakeString -> Ext
data BuildDependencies
BcSource :: BuildDependencies
BcSingle :: BuildName -> BuildDependencies
data BuildConfig
BuildConfig :: ([CommandFragment] -> CommandFragment -> CommandFragment -> [BuildCommand]) -> Maybe BuildName -> Maybe BuildName -> BuildDependencies -> BuildConfig
data RunType
Standalone :: RunType
Interpreter :: [CommandFragment] -> RunType
data Runnable
Runnable :: BuildName -> NameOpts -> RunType -> Runnable
data DocConfig
DocConfig :: Dependencies -> [Command] -> DocConfig
data NameOpts
NameOpts :: String -> Bool -> NameOpts
[packSep] :: NameOpts -> String
[includeExt] :: NameOpts -> Bool
nameOpts :: NameOpts
type BuildCommand = [CommandFragment]
type InterpreterCommand = String
type InterpreterOption = String
asFragment :: String -> CommandFragment
osClassDefault :: String -> String -> String -> CommandFragment
buildAll :: ([CommandFragment] -> CommandFragment -> [BuildCommand]) -> BuildName -> Maybe BuildConfig
buildAllAdditionalName :: ([CommandFragment] -> CommandFragment -> CommandFragment -> [BuildCommand]) -> BuildName -> BuildName -> Maybe BuildConfig
buildSingle :: ([CommandFragment] -> CommandFragment -> [BuildCommand]) -> BuildName -> BuildName -> Maybe BuildConfig
nativeBinary :: Maybe Runnable
executable :: BuildName
sharedLibrary :: BuildName
interp :: BuildName -> NameOpts -> InterpreterCommand -> [InterpreterOption] -> Maybe Runnable
interpMM :: InterpreterCommand -> Maybe Runnable
mainModule :: BuildName
mainModuleFile :: BuildName
inCodePackage :: BuildName -> BuildName
withExt :: BuildName -> String -> BuildName
cCompiler :: CommandFragment
cppCompiler :: CommandFragment
doxygenDocConfig :: FilePath -> DocConfig

module Language.Drasil.Code.Imperative.Build.Import
makeBuild :: Maybe DocConfig -> Maybe BuildConfig -> Maybe Runnable -> GOOLState -> ProgData -> Doc
instance Build.Drasil.Make.Import.RuleTransformer Language.Drasil.Code.Imperative.Build.Import.CodeHarness


-- | Defines the underlying data types used in the package extension.
module Language.Drasil.Code.Imperative.GOOL.Data
data AuxData
ad :: FilePath -> Doc -> AuxData
data PackData
packD :: ProgData -> [AuxData] -> PackData


-- | Contains the high-level functionality to create <a>Code</a> and then
--   produce the actual generated code files
module Language.Drasil.Code.CodeGeneration

-- | Takes code
makeCode :: [FileData] -> [AuxData] -> Code

-- | Creates the requested <a>Code</a> by producing files
createCodeFiles :: Code -> IO ()

module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer
doxConfigName :: String
makefileName :: String
sampleInputName :: String
readMeName :: String


-- | Defines functions for reading values from a file corresponding to a
--   DataDesc
module Language.Drasil.Code.Imperative.ReadInput

-- | Defines the DataDesc for the file containing a sample data set, which
--   a user must supply if they want to generate a sample input file.
sampleInputDD :: [CodeVarChunk] -> DataDesc'

-- | Reads data from a file and converts the values to Exprs. The file must
--   be formatted according to the DataDesc passed as a parameter.
readWithDataDesc :: FilePath -> DataDesc' -> IO [Expr]

module Language.Drasil.Code.Imperative.WriteInput
makeInputFile :: ChunkDB -> DataDesc -> [Expr] -> Doc


-- | Defines an enumerated type of target languages for code generation.
module Language.Drasil.Code.Lang
data Lang
Cpp :: Lang
CSharp :: Lang
Java :: Lang
Python :: Lang
Swift :: Lang
instance GHC.Show.Show Language.Drasil.Code.Lang.Lang
instance GHC.Classes.Eq Language.Drasil.Code.Lang.Lang

module Language.Drasil.CodeExpr

-- | Constructs an Expr for actor creation (constructor call)
new :: (Callable f, HasUID f, CodeIdea f) => f -> [Expr] -> Expr

-- | Constructs an Expr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [Expr] -> [(a, Expr)] -> Expr

-- | Constructs an Expr for actor messaging (method call)
message :: (Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [Expr] -> Expr

-- | Constructs an Expr for actor messaging (method call) that uses named
--   arguments
msgWithNamedArgs :: (Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [Expr] -> [(a, Expr)] -> Expr

-- | Constructs an Expr representing the field of an actor
field :: CodeVarChunk -> CodeVarChunk -> Expr


-- | Defines a structure to contain scientifically-relevant information
--   about an ODE.
module Language.Drasil.Data.ODEInfo
data ODEInfo
ODEInfo :: CodeVarChunk -> CodeVarChunk -> [CodeVarChunk] -> Expr -> Expr -> Expr -> [Expr] -> ODEOptions -> ODEInfo
[indepVar] :: ODEInfo -> CodeVarChunk
[depVar] :: ODEInfo -> CodeVarChunk
[otherVars] :: ODEInfo -> [CodeVarChunk]
[tInit] :: ODEInfo -> Expr
[tFinal] :: ODEInfo -> Expr
[initVal] :: ODEInfo -> Expr
[odeSyst] :: ODEInfo -> [Expr]
[odeOpts] :: ODEInfo -> ODEOptions
odeInfo :: CodeVarChunk -> CodeVarChunk -> [CodeVarChunk] -> Expr -> Expr -> Expr -> [Expr] -> ODEOptions -> ODEInfo
data ODEOptions
ODEOpts :: ODEMethod -> Expr -> Expr -> Expr -> Expr -> ODEOptions
[solveMethod] :: ODEOptions -> ODEMethod
[absTol] :: ODEOptions -> Expr
[relTol] :: ODEOptions -> Expr
[stepSize] :: ODEOptions -> Expr
[initValFstOrd] :: ODEOptions -> Expr
odeOptions :: ODEMethod -> Expr -> Expr -> Expr -> Expr -> ODEOptions
data ODEMethod
RK45 :: ODEMethod
BDF :: ODEMethod
Adams :: ODEMethod

module Language.Drasil.Chunk.CodeDefinition
data CodeDefinition
data DefinitionType
Definition :: DefinitionType
ODE :: DefinitionType
qtoc :: (Quantity q, DefiningExpr q, MayHaveUnit q) => q -> CodeDefinition
qtov :: QDefinition -> CodeDefinition
odeDef :: ODEInfo -> CodeDefinition
auxExprs :: Lens' CodeDefinition [Expr]
defType :: Lens' CodeDefinition DefinitionType
codeEquat :: CodeDefinition -> Expr
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Chunk.Code.CodeIdea Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeDefinition.CodeDefinition
instance Language.Drasil.Classes.DefiningExpr Language.Drasil.Chunk.CodeDefinition.CodeDefinition


-- | Defines an AST for defining Modules
module Language.Drasil.Mod
data Class
ClassDef :: Name -> Maybe Name -> Description -> [StateVariable] -> [Func] -> Class
[className] :: Class -> Name
[implements] :: Class -> Maybe Name
[classDesc] :: Class -> Description
[stateVars] :: Class -> [StateVariable]
[methods] :: Class -> [Func]
data StateVariable
SV :: ScopeTag -> CodeVarChunk -> StateVariable
[svScope] :: StateVariable -> ScopeTag
[stVar] :: StateVariable -> CodeVarChunk
data Func
FDef :: FuncDef -> Func
FData :: FuncData -> Func
data FuncData
[FuncData] :: Name -> Description -> DataDesc -> FuncData
data FuncDef
[FuncDef] :: Name -> Description -> [ParameterChunk] -> Space -> Maybe Description -> [FuncStmt] -> FuncDef
[CtorDef] :: Name -> Description -> [ParameterChunk] -> [Initializer] -> [FuncStmt] -> FuncDef
data FuncStmt
[FAsg] :: CodeVarChunk -> Expr -> FuncStmt
[FAsgIndex] :: CodeVarChunk -> Integer -> Expr -> FuncStmt
[FFor] :: CodeVarChunk -> Expr -> [FuncStmt] -> FuncStmt
[FForEach] :: CodeVarChunk -> Expr -> [FuncStmt] -> FuncStmt
[FWhile] :: Expr -> [FuncStmt] -> FuncStmt
[FCond] :: Expr -> [FuncStmt] -> [FuncStmt] -> FuncStmt
[FRet] :: Expr -> FuncStmt
[FThrow] :: String -> FuncStmt
[FTry] :: [FuncStmt] -> [FuncStmt] -> FuncStmt
[FContinue] :: FuncStmt
[FDecDef] :: CodeVarChunk -> Expr -> FuncStmt
[FFuncDef] :: CodeFuncChunk -> [ParameterChunk] -> [FuncStmt] -> FuncStmt
[FVal] :: Expr -> FuncStmt
[FMulti] :: [FuncStmt] -> FuncStmt
[FAppend] :: Expr -> Expr -> FuncStmt
type Initializer = (CodeVarChunk, Expr)
data Mod
Mod :: Name -> Description -> [Import] -> [Class] -> [Func] -> Mod
type Name = String
type Version = String
type Description = String
type Import = String

-- | Define an assignment statement
($:=) :: (Quantity c, MayHaveUnit c) => c -> Expr -> FuncStmt

-- | Define a public state variable based on the given CodeVarChunk
pubStateVar :: CodeVarChunk -> StateVariable

-- | Define a private state variable based on the given CodeVarChunk
privStateVar :: CodeVarChunk -> StateVariable

-- | Define a class with the given Name, Description, state variables, and
--   methods.
classDef :: Name -> Description -> [StateVariable] -> [Func] -> Class

-- | Define a class that implements an interface. 1st Name is class name,
--   2nd is interface name.
classImplements :: Name -> Name -> Description -> [StateVariable] -> [Func] -> Class

-- | Define a constructor, with the given name, description, parameters,
--   initializers (variable-value pairs), and FuncStmts for the body.
ctorDef :: Name -> Description -> [ParameterChunk] -> [Initializer] -> [FuncStmt] -> Func

-- | Define a for-loop. Quantity is for the iteration variable, Expr is the
--   upper bound at that variable (the variable will start with a value of
--   0). [FuncStmt] is for the loop body.
ffor :: (Quantity c, MayHaveUnit c) => c -> Expr -> [FuncStmt] -> FuncStmt

-- | Define a declare-define statement.
fDecDef :: (Quantity c, MayHaveUnit c) => c -> Expr -> FuncStmt

-- | Get the name of a function.
fname :: Func -> Name

-- | Returns the list of CodeVarChunks that are used in the list of
--   FuncStmts but are not declared in any of the FuncStmts.
fstdecl :: ChunkDB -> [FuncStmt] -> [CodeVarChunk]

-- | Define a function that reads data from a file, according to the given
--   DataDesc.
funcData :: Name -> Description -> DataDesc -> Func

-- | Define a function by providing the FuncStmts for its body. Other
--   parameters are function name, description, list of parameters, space
--   of the returned value, and description of the returned value.
funcDef :: (Quantity c, MayHaveUnit c) => Name -> Description -> [c] -> Space -> Maybe Description -> [FuncStmt] -> Func

-- | Like funcDef but uses ParameterChunks to represent the parameters.
funcDefParams :: Name -> Description -> [ParameterChunk] -> Space -> Maybe Description -> [FuncStmt] -> Func

-- | Define a Mod with the given Name, Description, Classes, and Functions.
packmod :: Name -> Description -> [Class] -> [Func] -> Mod

-- | Define a Mod that requires some library imports, with the given Name,
--   Description, Classes, and Functions.
packmodRequires :: Name -> Description -> [Import] -> [Class] -> [Func] -> Mod


-- | Defines an AST to be paired with an ExternalLibrary for a specific
--   use-case
module Language.Drasil.Code.ExternalLibraryCall
type ExternalLibraryCall = [StepGroupFill]
data StepGroupFill
SGF :: Int -> [StepFill] -> StepGroupFill
data StepFill
CallF :: FunctionIntFill -> StepFill
LoopF :: NonEmpty FunctionIntFill -> [Expr] -> NonEmpty StepFill -> StepFill
StatementF :: [CodeVarChunk] -> [Expr] -> StepFill
newtype FunctionIntFill
FIF :: [ArgumentFill] -> FunctionIntFill
data ArgumentFill
UserDefinedArgF :: Maybe NamedArgument -> Expr -> ArgumentFill
BasicF :: Expr -> ArgumentFill
FnF :: [ParameterFill] -> StepFill -> ArgumentFill
ClassF :: [StateVariable] -> ClassInfoFill -> ArgumentFill
RecordF :: [Expr] -> ArgumentFill
data ParameterFill
NameableParamF :: ParameterChunk -> ParameterFill
UserDefined :: ParameterChunk -> ParameterFill
data ClassInfoFill
RegularF :: [MethodInfoFill] -> ClassInfoFill
ImplementsF :: [MethodInfoFill] -> ClassInfoFill
data MethodInfoFill
CIF :: [ParameterFill] -> [Initializer] -> [StepFill] -> MethodInfoFill
MIF :: [ParameterFill] -> NonEmpty StepFill -> MethodInfoFill
externalLibCall :: [StepGroupFill] -> ExternalLibraryCall
choiceStepsFill :: Int -> [StepFill] -> StepGroupFill
choiceStepFill :: Int -> StepFill -> StepGroupFill
mandatoryStepFill :: StepFill -> StepGroupFill
mandatoryStepsFill :: [StepFill] -> StepGroupFill
callStepFill :: FunctionIntFill -> StepFill
libCallFill :: [ArgumentFill] -> FunctionIntFill
userDefinedArgFill :: Expr -> ArgumentFill
basicArgFill :: Expr -> ArgumentFill
functionArgFill :: [ParameterFill] -> StepFill -> ArgumentFill
customObjArgFill :: [StateVariable] -> ClassInfoFill -> ArgumentFill
recordArgFill :: [Expr] -> ArgumentFill
unnamedParamFill :: CodeVarChunk -> ParameterFill
unnamedParamPBVFill :: CodeVarChunk -> ParameterFill
userDefinedParamFill :: CodeVarChunk -> ParameterFill
customClassFill :: [MethodInfoFill] -> ClassInfoFill
implementationFill :: [MethodInfoFill] -> ClassInfoFill
constructorInfoFill :: [ParameterFill] -> [Initializer] -> [StepFill] -> MethodInfoFill
methodInfoFill :: [ParameterFill] -> [StepFill] -> MethodInfoFill
appendCurrSolFill :: CodeVarChunk -> StepFill
populateSolListFill :: CodeVarChunk -> [StepFill]
assignArrayIndexFill :: CodeVarChunk -> [Expr] -> StepFill
assignSolFromObjFill :: CodeVarChunk -> StepFill
initSolListFromArrayFill :: CodeVarChunk -> StepFill
initSolListWithValFill :: CodeVarChunk -> Expr -> StepFill
solveAndPopulateWhileFill :: FunctionIntFill -> Expr -> FunctionIntFill -> CodeVarChunk -> StepFill
returnExprListFill :: [Expr] -> StepFill
fixedStatementFill :: StepFill
initSolWithValFill :: CodeVarChunk -> Expr -> StepFill


-- | Defines a language for specifying external library use scenarios
module Language.Drasil.Code.ExternalLibrary
type ExternalLibrary = [StepGroup]
data Step
Call :: FunctionInterface -> Step
Loop :: NonEmpty FunctionInterface -> ([Expr] -> Condition) -> NonEmpty Step -> Step
Statement :: ([CodeVarChunk] -> [Expr] -> FuncStmt) -> Step
data FunctionInterface
FI :: NonEmpty Requires -> FuncType -> CodeFuncChunk -> [Argument] -> Maybe Result -> FunctionInterface
data Result
Assign :: CodeVarChunk -> Result
Return :: Result
data Argument
Arg :: Maybe NamedArgument -> ArgumentInfo -> Argument
data ArgumentInfo
LockedArg :: Expr -> ArgumentInfo
Basic :: Space -> Maybe CodeVarChunk -> ArgumentInfo
Fn :: CodeFuncChunk -> [Parameter] -> Step -> ArgumentInfo
Class :: [Requires] -> Description -> CodeVarChunk -> CodeFuncChunk -> ClassInfo -> ArgumentInfo
Record :: NonEmpty Requires -> CodeFuncChunk -> CodeVarChunk -> [CodeVarChunk] -> ArgumentInfo
data Parameter
LockedParam :: ParameterChunk -> Parameter
NameableParam :: Space -> Parameter
data ClassInfo
Regular :: [MethodInfo] -> ClassInfo
Implements :: String -> [MethodInfo] -> ClassInfo
data MethodInfo
CI :: Description -> [Parameter] -> [Step] -> MethodInfo
MI :: CodeFuncChunk -> Description -> [Parameter] -> Maybe Description -> NonEmpty Step -> MethodInfo
data FuncType
Function :: FuncType
Method :: CodeVarChunk -> FuncType
Constructor :: FuncType
externalLib :: [StepGroup] -> ExternalLibrary
choiceSteps :: [[Step]] -> StepGroup
choiceStep :: [Step] -> StepGroup
mandatoryStep :: Step -> StepGroup
mandatorySteps :: [Step] -> StepGroup
callStep :: FunctionInterface -> Step
libFunction :: Requires -> CodeFuncChunk -> [Argument] -> FunctionInterface
libMethod :: Requires -> CodeVarChunk -> CodeFuncChunk -> [Argument] -> FunctionInterface
libFunctionWithResult :: Requires -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libMethodWithResult :: Requires -> CodeVarChunk -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libConstructor :: Requires -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libConstructorMultiReqs :: [Requires] -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
constructAndReturn :: Requires -> CodeFuncChunk -> [Argument] -> FunctionInterface
lockedArg :: Expr -> Argument
lockedNamedArg :: NamedArgument -> Expr -> Argument
inlineArg :: Space -> Argument
inlineNamedArg :: NamedArgument -> Space -> Argument
preDefinedArg :: CodeVarChunk -> Argument
preDefinedNamedArg :: NamedArgument -> CodeVarChunk -> Argument
functionArg :: CodeFuncChunk -> [Parameter] -> Step -> Argument
customObjArg :: [Requires] -> Description -> CodeVarChunk -> CodeFuncChunk -> ClassInfo -> Argument
recordArg :: Requires -> CodeFuncChunk -> CodeVarChunk -> [CodeVarChunk] -> Argument
lockedParam :: CodeVarChunk -> Parameter
unnamedParam :: Space -> Parameter
customClass :: [MethodInfo] -> ClassInfo
implementation :: String -> [MethodInfo] -> ClassInfo
constructorInfo :: CodeFuncChunk -> [Parameter] -> [Step] -> MethodInfo
methodInfo :: CodeFuncChunk -> Description -> [Parameter] -> Description -> [Step] -> MethodInfo
methodInfoNoReturn :: CodeFuncChunk -> Description -> [Parameter] -> [Step] -> MethodInfo
appendCurrSol :: Expr -> Step
populateSolList :: CodeVarChunk -> CodeVarChunk -> CodeVarChunk -> [Step]
assignArrayIndex :: Step
assignSolFromObj :: CodeVarChunk -> Step
initSolListFromArray :: CodeVarChunk -> Step
initSolListWithVal :: Step
solveAndPopulateWhile :: FunctionInterface -> CodeVarChunk -> CodeVarChunk -> FunctionInterface -> CodeVarChunk -> Step
returnExprList :: Step
fixedReturn :: Expr -> Step
initSolWithVal :: Step


-- | Defines a type for representing ODE-solving external libraries.
module Language.Drasil.Data.ODELibPckg
data ODELibPckg
ODELib :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> Maybe FilePath -> [Lang] -> ODELibPckg
[libName] :: ODELibPckg -> Name
[libVers] :: ODELibPckg -> Version
[libSpec] :: ODELibPckg -> ExternalLibrary
[libCall] :: ODELibPckg -> ODEInfo -> ExternalLibraryCall
[libPath] :: ODELibPckg -> Maybe FilePath
[compatibleLangs] :: ODELibPckg -> [Lang]

-- | Makes an ODELibPckg with the given name, ExternalLibrary
--   specification, ExternalLibraryCall specification parameterized by an
--   ODEInfo, local file path to the library, and list of compatible
--   languages.
mkODELib :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> FilePath -> [Lang] -> ODELibPckg

-- | Makes an ODELibPckg with the given name, ExternalLibrary
--   specification, ExternalLibraryCall specification parameterized by an
--   ODEInfo, and list of compatible languages.
mkODELibNoPath :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> [Lang] -> ODELibPckg


-- | Defines the design language for SCS.
module Language.Drasil.Choices
data Choices
Choices :: [Lang] -> Modularity -> Structure -> ConstantStructure -> ConstantRepr -> ConceptMatchMap -> SpaceMatch -> ImplementationType -> [ODELibPckg] -> [ODEInfo] -> ConstraintBehaviour -> ConstraintBehaviour -> [Comments] -> Verbosity -> Visibility -> [Logging] -> FilePath -> [AuxFile] -> Choices
[lang] :: Choices -> [Lang]
[modularity] :: Choices -> Modularity
[inputStructure] :: Choices -> Structure
[constStructure] :: Choices -> ConstantStructure
[constRepr] :: Choices -> ConstantRepr
[conceptMatch] :: Choices -> ConceptMatchMap
[spaceMatch] :: Choices -> SpaceMatch
[impType] :: Choices -> ImplementationType
[odeLib] :: Choices -> [ODELibPckg]
[odes] :: Choices -> [ODEInfo]
[onSfwrConstraint] :: Choices -> ConstraintBehaviour
[onPhysConstraint] :: Choices -> ConstraintBehaviour
[comments] :: Choices -> [Comments]
[doxVerbosity] :: Choices -> Verbosity
[dates] :: Choices -> Visibility
[logging] :: Choices -> [Logging]
[logFile] :: Choices -> FilePath
[auxFiles] :: Choices -> [AuxFile]
data Modularity
Modular :: InputModule -> Modularity
Unmodular :: Modularity
data InputModule
Combined :: InputModule
Separated :: InputModule
inputModule :: Choices -> InputModule
data Structure
Unbundled :: Structure
Bundled :: Structure
data ConstantStructure
Inline :: ConstantStructure
WithInputs :: ConstantStructure
Store :: Structure -> ConstantStructure
data ConstantRepr
Var :: ConstantRepr
Const :: ConstantRepr

-- | Specifies matches between chunks and CodeConcepts, meaning the target
--   language's pre-existing definition of the concept should be used
--   instead of defining a new variable for the concept in the generated
--   code. [CodeConcept] is preferentially-ordered, generator concretizes a
--   ConceptMatchMap to a MatchedConceptMap by checking user's other
--   choices.
type ConceptMatchMap = Map UID [CodeConcept]
type MatchedConceptMap = Map UID CodeConcept
data CodeConcept
Pi :: CodeConcept

-- | Builds a ConceptMatchMap from an association list of chunks and
--   CodeConcepts
matchConcepts :: HasUID c => [(c, [CodeConcept])] -> ConceptMatchMap

-- | Specifies which CodeType should be used to represent each mathematical
--   Space. [CodeType] is preferentially-ordered, first CodeType that does
--   not conflict with other choices will be selected.
type SpaceMatch = Space -> [CodeType]

-- | Builds a SpaceMatch from an association list of Spaces and CodeTypes.
matchSpaces :: [(Space, [CodeType])] -> SpaceMatch
data ImplementationType
Library :: ImplementationType
Program :: ImplementationType
data ConstraintBehaviour
Warning :: ConstraintBehaviour
Exception :: ConstraintBehaviour
data Comments
CommentFunc :: Comments
CommentClass :: Comments
CommentMod :: Comments
data Verbosity
Verbose :: Verbosity
Quiet :: Verbosity
data Visibility
Show :: Visibility
Hide :: Visibility
data Logging
LogFunc :: Logging
LogVar :: Logging
data AuxFile
SampleInput :: FilePath -> AuxFile
ReadME :: AuxFile
getSampleData :: Choices -> Maybe FilePath
hasSampleInput :: [AuxFile] -> Bool

-- | Default choices to be used as the base from which design
--   specifications can be built.
defaultChoices :: Choices
choicesSent :: Choices -> [Sentence]
showChs :: RenderChoices a => a -> Sentence
instance GHC.Classes.Eq Language.Drasil.Choices.AuxFile
instance GHC.Classes.Eq Language.Drasil.Choices.Logging
instance GHC.Classes.Eq Language.Drasil.Choices.Comments
instance GHC.Classes.Eq Language.Drasil.Choices.CodeConcept
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.AuxFile
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Logging
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Visibility
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Verbosity
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Comments
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.ConstraintBehaviour
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.ImplementationType
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.CodeConcept
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.ConstantRepr
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.ConstantStructure
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Structure
instance Language.Drasil.Choices.RenderChoices Language.Drasil.Choices.Modularity


-- | Defines the CodeSpec structure and related functions.
module Language.Drasil.CodeSpec
type Input = CodeVarChunk
type Output = CodeVarChunk
type Const = CodeDefinition
type Derived = CodeDefinition
type Def = CodeDefinition
data CodeSpec
[CodeSpec] :: HasName a => {pName :: Name, authors :: [a], inputs :: [Input], extInputs :: [Input], derivedInputs :: [Derived], outputs :: [Output], configFiles :: [FilePath], execOrder :: [Def], cMap :: ConstraintMap, constants :: [Const], constMap :: ConstantMap, mods :: [Mod], sysinfodb :: ChunkDB} -> CodeSpec
type ConstantMap = Map UID CodeDefinition
assocToMap :: HasUID a => [a] -> Map UID a

-- | Defines a CodeSpec based on the SystemInformation, Choices, and Mods
--   defined by the user.
codeSpec :: SystemInformation -> Choices -> [Mod] -> CodeSpec
relToQD :: ExprRelat c => ChunkDB -> c -> QDefinition
convertRel :: ChunkDB -> Expr -> QDefinition

-- | Convert a Func to an implementation-stage QuantityDict representing
--   the function.
asVC :: Func -> QuantityDict

-- | Get a UID of a chunk corresponding to a Func
funcUID :: Func -> UID

-- | FIXME: hack. Use for implementation-stage functions that need to be
--   displayed in the SRS.
funcUID' :: Func -> UID

-- | FIXME: Part of above hack
asVC' :: Func -> QuantityDict
getDerivedInputs :: [DataDefinition] -> [QDefinition] -> [Input] -> [Const] -> ChunkDB -> [QDefinition]
type Known = CodeVarChunk
type Need = CodeVarChunk
getExecOrder :: [Def] -> [Known] -> [Need] -> ChunkDB -> [Def]
subsetOf :: Eq a => [a] -> [a] -> Bool

-- | Get a list of Constraints for a list of CodeChunks
getConstraints :: HasUID c => ConstraintMap -> [c] -> [Constraint]

-- | Get a list of CodeChunks from a constraint
constraintvars :: Constraint -> ChunkDB -> [CodeChunk]


-- | Defines a package extension for GOOL, with functions for pairing a
--   GOOL program with auxiliary, non-source-code files.
module Language.Drasil.Code.Imperative.GOOL.ClassInterface
data ReadMeInfo
ReadMeInfo :: LangAbbrev -> LangVers -> Maybe String -> ImplementationType -> [(Name, Version)] -> [FilePath] -> [Contributer] -> [FilePath] -> CaseName -> ReadMeInfo
[langName] :: ReadMeInfo -> LangAbbrev
[langVersion] :: ReadMeInfo -> LangVers
[invalidOS] :: ReadMeInfo -> Maybe String
[implementType] :: ReadMeInfo -> ImplementationType
[extLibNV] :: ReadMeInfo -> [(Name, Version)]
[extLibFP] :: ReadMeInfo -> [FilePath]
[contributors] :: ReadMeInfo -> [Contributer]
[configFP] :: ReadMeInfo -> [FilePath]
[caseName] :: ReadMeInfo -> CaseName
class (AuxiliarySym r) => PackageSym r where {
    type family Package r;
}
package :: PackageSym r => ProgData -> [r (Auxiliary r)] -> r (Package r)
class AuxiliarySym r where {
    type family Auxiliary r;
    type family AuxHelper r;
}
doxConfig :: AuxiliarySym r => String -> GOOLState -> Verbosity -> r (Auxiliary r)
readMe :: AuxiliarySym r => ReadMeInfo -> r (Auxiliary r)
sampleInput :: AuxiliarySym r => ChunkDB -> DataDesc -> [Expr] -> r (Auxiliary r)
optimizeDox :: AuxiliarySym r => r (AuxHelper r)
makefile :: AuxiliarySym r => [FilePath] -> ImplementationType -> [Comments] -> GOOLState -> ProgData -> r (Auxiliary r)
auxHelperDoc :: AuxiliarySym r => r (AuxHelper r) -> Doc
auxFromData :: AuxiliarySym r => FilePath -> Doc -> r (Auxiliary r)

module Language.Drasil.Code.Imperative.WriteReadMe
makeReadMe :: ReadMeInfo -> Doc

module Language.Drasil.Code.Imperative.Doxygen.Import
makeDoxConfig :: ProjName -> GOOLState -> OptimizeChoice -> Verbosity -> Doc
yes :: Doc
no :: Doc

module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.LanguagePolymorphic
doxConfig :: AuxiliarySym r => r (AuxHelper r) -> String -> GOOLState -> Verbosity -> r (Auxiliary r)
readMe :: AuxiliarySym r => ReadMeInfo -> r (Auxiliary r)
sampleInput :: AuxiliarySym r => ChunkDB -> DataDesc -> [Expr] -> r (Auxiliary r)
makefile :: AuxiliarySym r => Maybe BuildConfig -> Maybe Runnable -> Maybe DocConfig -> GOOLState -> ProgData -> r (Auxiliary r)
noRunIfLib :: ImplementationType -> Maybe Runnable -> Maybe Runnable
doxDocConfig :: DocConfig
docIfEnabled :: [Comments] -> DocConfig -> Maybe DocConfig


-- | The logic to render Swift auxiliary files is contained in this module
module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer
newtype SwiftProject a
SP :: a -> SwiftProject a
[unSP] :: SwiftProject a -> a
instance GHC.Base.Functor Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer.SwiftProject
instance GHC.Base.Applicative Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer.SwiftProject
instance GHC.Base.Monad Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer.SwiftProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.PackageSym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer.SwiftProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.AuxiliarySym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.SwiftRenderer.SwiftProject


-- | The logic to render Python auxiliary files is contained in this module
module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer
newtype PythonProject a
PP :: a -> PythonProject a
[unPP] :: PythonProject a -> a
instance GHC.Base.Functor Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer.PythonProject
instance GHC.Base.Applicative Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer.PythonProject
instance GHC.Base.Monad Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer.PythonProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.PackageSym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer.PythonProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.AuxiliarySym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.PythonRenderer.PythonProject


-- | The logic to render Java auxiliary files is contained in this module
module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer
newtype JavaProject a
JP :: a -> JavaProject a
[unJP] :: JavaProject a -> a
instance GHC.Base.Functor Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer.JavaProject
instance GHC.Base.Applicative Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer.JavaProject
instance GHC.Base.Monad Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer.JavaProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.PackageSym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer.JavaProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.AuxiliarySym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.JavaRenderer.JavaProject


-- | The logic to render C++ auxiliary files is contained in this module
module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer
newtype CppProject a
CPPP :: a -> CppProject a
[unCPPP] :: CppProject a -> a
instance GHC.Base.Functor Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer.CppProject
instance GHC.Base.Applicative Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer.CppProject
instance GHC.Base.Monad Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer.CppProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.PackageSym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer.CppProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.AuxiliarySym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CppRenderer.CppProject


-- | The logic to render C# auxiliary files is contained in this module
module Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer
newtype CSharpProject a
CSP :: a -> CSharpProject a
[unCSP] :: CSharpProject a -> a
instance GHC.Base.Functor Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer.CSharpProject
instance GHC.Base.Applicative Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer.CSharpProject
instance GHC.Base.Monad Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer.CSharpProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.PackageSym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer.CSharpProject
instance Language.Drasil.Code.Imperative.GOOL.ClassInterface.AuxiliarySym Language.Drasil.Code.Imperative.GOOL.LanguageRenderer.CSharpRenderer.CSharpProject


-- | Contains functions related to the choice of concept matches
module Language.Drasil.Code.Imperative.ConceptMatch

-- | Concretizes the ConceptMatchMap in Choices to a MatchedConceptMap.
--   Currently we don't have any Choices that would prevent a CodeConcept
--   from being mapped, so we just take the head of the list of
--   CodeConcepts The conceptMatchMap from choices is passed to
--   chooseConept' internally, this way any codeconcept list can be matched
--   to its appropiate UID
chooseConcept :: Choices -> State [Sentence] MatchedConceptMap
conceptToGOOL :: OOProg r => CodeConcept -> SValue r


-- | Defines functions for simultaneous interpretation of ExternalLibrary
--   and ExternalLibraryCall.
module Language.Drasil.Code.ExtLibImport
data ExtLibState
ELS :: [Mod] -> [FuncStmt] -> [Name] -> [FuncStmt] -> [String] -> [(Name, Name)] -> ExtLibState
[_auxMods] :: ExtLibState -> [Mod]
[_defs] :: ExtLibState -> [FuncStmt]
[_defined] :: ExtLibState -> [Name]
[_steps] :: ExtLibState -> [FuncStmt]
[_imports] :: ExtLibState -> [String]
[_modExports] :: ExtLibState -> [(Name, Name)]
auxMods :: Lens' ExtLibState [Mod]
defs :: Lens' ExtLibState [FuncStmt]
imports :: Lens' ExtLibState [String]
modExports :: Lens' ExtLibState [(Name, Name)]
steps :: Lens' ExtLibState [FuncStmt]
genExternalLibraryCall :: ExternalLibrary -> ExternalLibraryCall -> ExtLibState

module Language.Drasil.Code.Imperative.GenODE
chooseODELib :: Lang -> [ODELibPckg] -> [ODEInfo] -> State [Sentence] ODEGenInfo

module Language.Drasil.Code.Imperative.DrasilState
type GenState = State DrasilState
data DrasilState
DrasilState :: CodeSpec -> Modularity -> ImplementationType -> Structure -> ConstantStructure -> ConstantRepr -> MatchedConceptMap -> MatchedSpaces -> ConstraintBehaviour -> ConstraintBehaviour -> [Comments] -> Verbosity -> String -> String -> [Logging] -> [AuxFile] -> [Expr] -> [Mod] -> [(Name, Version)] -> ExtLibMap -> [FilePath] -> ModExportMap -> ModExportMap -> ClassDefinitionMap -> [Name] -> String -> String -> Doc -> [(Space, CodeType)] -> DrasilState
[codeSpec] :: DrasilState -> CodeSpec
[modular] :: DrasilState -> Modularity
[implType] :: DrasilState -> ImplementationType
[inStruct] :: DrasilState -> Structure
[conStruct] :: DrasilState -> ConstantStructure
[conRepr] :: DrasilState -> ConstantRepr
[concMatches] :: DrasilState -> MatchedConceptMap
[spaceMatches] :: DrasilState -> MatchedSpaces
[onSfwrC] :: DrasilState -> ConstraintBehaviour
[onPhysC] :: DrasilState -> ConstraintBehaviour
[commented] :: DrasilState -> [Comments]
[doxOutput] :: DrasilState -> Verbosity
[date] :: DrasilState -> String
[logName] :: DrasilState -> String
[logKind] :: DrasilState -> [Logging]
[auxiliaries] :: DrasilState -> [AuxFile]
[sampleData] :: DrasilState -> [Expr]
[modules] :: DrasilState -> [Mod]
[extLibNames] :: DrasilState -> [(Name, Version)]
[extLibMap] :: DrasilState -> ExtLibMap
[libPaths] :: DrasilState -> [FilePath]
[eMap] :: DrasilState -> ModExportMap
[libEMap] :: DrasilState -> ModExportMap
[clsMap] :: DrasilState -> ClassDefinitionMap
[defList] :: DrasilState -> [Name]
[currentModule] :: DrasilState -> String
[currentClass] :: DrasilState -> String
[_designLog] :: DrasilState -> Doc
[_loggedSpaces] :: DrasilState -> [(Space, CodeType)]
designLog :: Lens' DrasilState Doc

-- | Determines whether input modules are Combined or Separated, based on
--   the Modularity stored in DrasilState
inMod :: DrasilState -> InputModule
type MatchedSpaces = Space -> GenState CodeType
type ModExportMap = Map String String
type ClassDefinitionMap = Map String String
modExportMap :: CodeSpec -> Choices -> [Mod] -> ModExportMap
clsDefMap :: CodeSpec -> Choices -> [Mod] -> ClassDefinitionMap
addToDesignLog :: Space -> CodeType -> Doc -> DrasilState -> DrasilState
addLoggedSpace :: Space -> CodeType -> DrasilState -> DrasilState

module Language.Drasil.Code.Imperative.SpaceMatch
chooseSpace :: Lang -> Choices -> MatchedSpaces

module Language.Drasil.Code.Imperative.Parameters

-- | Since the input constructor calls the three input-related methods, the
--   parameters to the constructor are the parameters to the three methods,
--   except excluding any of variables that are state variables in the
--   class, since they are already in scope. If InputParameters is not in
--   the definition list, then the default constructor is used, which takes
--   no parameters.
getInConstructorParams :: GenState [CodeVarChunk]
getInputFormatIns :: GenState [CodeVarChunk]
getInputFormatOuts :: GenState [CodeVarChunk]
getDerivedIns :: GenState [CodeVarChunk]
getDerivedOuts :: GenState [CodeVarChunk]
getConstraintParams :: GenState [CodeVarChunk]
getCalcParams :: CodeDefinition -> GenState [CodeVarChunk]
getOutputParams :: GenState [CodeVarChunk]
instance GHC.Classes.Eq Language.Drasil.Code.Imperative.Parameters.ParamType

module Language.Drasil.Code.Imperative.Logging
maybeLog :: OOProg r => SVariable r -> GenState [MSStatement r]
logBody :: OOProg r => Label -> [SVariable r] -> [MSBlock r] -> GenState (MSBody r)
loggedMethod :: OOProg r => FilePath -> Label -> [SVariable r] -> MSBlock r
varLogFile :: OOProg r => SVariable r

module Language.Drasil.Code.Imperative.Helpers
liftS :: State a b -> State a [b]
getUpperBound :: Expr -> Expr
lookupC :: DrasilState -> UID -> QuantityDict

module Language.Drasil.Code.Imperative.GenerateGOOL
data ClassType
Primary :: ClassType
Auxiliary :: ClassType

-- | Defines a GOOL module. If the user chose CommentMod, the module will
--   have Doxygen comments. If the user did not choose CommentMod but did
--   choose CommentFunc, a module-level Doxygen comment is still created,
--   though it only documents the file name, because without this Doxygen
--   will not find the function-level comments in the file.
genModuleWithImports :: OOProg r => Name -> Description -> [Import] -> [GenState (Maybe (SMethod r))] -> [GenState (Maybe (SClass r))] -> GenState (SFile r)

-- | Generates a module for when imports do not need to be explicitly
--   stated
genModule :: OOProg r => Name -> Description -> [GenState (Maybe (SMethod r))] -> [GenState (Maybe (SClass r))] -> GenState (SFile r)
genDoxConfig :: AuxiliarySym r => GOOLState -> GenState (Maybe (r (Auxiliary r)))
genReadMe :: AuxiliarySym r => ReadMeInfo -> GenState (Maybe (r (Auxiliary r)))
primaryClass :: OOProg r => Name -> Maybe Name -> Description -> [CSStateVar r] -> GenState [SMethod r] -> GenState (SClass r)
auxClass :: OOProg r => Name -> Maybe Name -> Description -> [CSStateVar r] -> GenState [SMethod r] -> GenState (SClass r)
fApp :: OOProg r => Name -> Name -> VSType r -> [SValue r] -> NamedArgs r -> GenState (SValue r)
ctorCall :: OOProg r => Name -> VSType r -> [SValue r] -> NamedArgs r -> GenState (SValue r)
fAppInOut :: OOProg r => Name -> Name -> [SValue r] -> [SVariable r] -> [SVariable r] -> GenState (MSStatement r)


-- | Defines description generators for common SCS functions, classes, and
--   modules
module Language.Drasil.Code.Imperative.Descriptions

-- | Returns a module description based on a list of descriptions of what
--   is contained in the module.
modDesc :: GenState [Description] -> GenState Description

-- | Returns description of what is contained in the module that is
--   generated when the user chooses an Unmodular design. Module is
--   described as either program or library, depending on the user's choice
--   of implementation type.
unmodularDesc :: GenState Description

-- | Returns description of what is contained in the Input Parameters
--   module. If user chose Bundled, this module includes the structure for
--   holding the input values, but not if they chose Unbundled. If the user
--   chose Combined, this module includes the input-related functions, but
--   not if they chose Separated.
inputParametersDesc :: GenState [Description]

-- | Returns description of the input constructor, checking whether each
--   possible method that may be called by the constructor is defined, and
--   including it in the description if so
inputConstructorDesc :: GenState Description

-- | Returns description of what is contained in the Input Format module,
--   if it exists.
inputFormatDesc :: GenState Description

-- | Returns description of what is contained in the Derived Values module,
--   if it exists.
derivedValuesDesc :: GenState Description

-- | Returns description of what is contained in the Input Constraints
--   module, if it exists.
inputConstraintsDesc :: GenState Description

-- | Returns description of what is contained in the Constants module, if
--   it exists.
constModDesc :: GenState Description

-- | Returns description of what is contained in the Output Format module,
--   if it exists.
outputFormatDesc :: GenState Description

-- | Returns description for generated function that stores inputs, if it
--   exists. Checks whether explicit inputs, derived inputs, and constants
--   are defined in the InputParameters class and includes each in the
--   description if so.
inputClassDesc :: GenState Description

-- | Returns description for generated class that stores constants, if it
--   exists. If no constants are defined in the Constants class, then it
--   does not exist and an empty description is returned.
constClassDesc :: GenState Description

-- | Returns description for generated function that reads input from a
--   file, if it exists.
inFmtFuncDesc :: GenState Description

-- | Returns description for generated function that checks input
--   constraints, if it exists.
inConsFuncDesc :: GenState Description

-- | Returns description for generated function that calculates derived
--   inputs, if it exists.
dvFuncDesc :: GenState Description

-- | Description of the generated Calculations module
calcModDesc :: Description

-- | Returns description for generated output-printing function, if it
--   exists
woFuncDesc :: GenState Description


-- | Contains functions for generating code comments that describe a chunk
module Language.Drasil.Code.Imperative.Comments

-- | Generates a comment string for a chunk, including the term, definition
--   (if applicable), and unit (if applicable)
getComment :: CodeIdea c => c -> GenState String

module Language.Drasil.Code.Imperative.Import
codeType :: HasSpace c => c -> GenState CodeType
spaceCodeType :: Space -> GenState CodeType
publicFunc :: OOProg r => Label -> VSType r -> Description -> [ParameterChunk] -> Maybe Description -> [MSBlock r] -> GenState (SMethod r)
privateMethod :: OOProg r => Label -> VSType r -> Description -> [ParameterChunk] -> Maybe Description -> [MSBlock r] -> GenState (SMethod r)
publicInOutFunc :: OOProg r => Label -> Description -> [CodeVarChunk] -> [CodeVarChunk] -> [MSBlock r] -> GenState (SMethod r)
privateInOutMethod :: OOProg r => Label -> Description -> [CodeVarChunk] -> [CodeVarChunk] -> [MSBlock r] -> GenState (SMethod r)
genConstructor :: OOProg r => Label -> Description -> [ParameterChunk] -> [MSBlock r] -> GenState (SMethod r)
mkVar :: OOProg r => CodeVarChunk -> GenState (SVariable r)
mkVal :: OOProg r => CodeVarChunk -> GenState (SValue r)
convExpr :: OOProg r => Expr -> GenState (SValue r)
convStmt :: OOProg r => FuncStmt -> GenState (MSStatement r)
genModDef :: OOProg r => Mod -> GenState (SFile r)
genModFuncs :: OOProg r => Mod -> [GenState (SMethod r)]
genModClasses :: OOProg r => Mod -> [GenState (SClass r)]
readData :: OOProg r => DataDesc -> GenState [MSBlock r]
renderC :: (HasUID c, HasSymbol c) => c -> Constraint -> Expr

module Language.Drasil.Code.Imperative.FunctionCalls
getAllInputCalls :: OOProg r => GenState [MSStatement r]
getInputCall :: OOProg r => GenState (Maybe (MSStatement r))
getDerivedCall :: OOProg r => GenState (Maybe (MSStatement r))
getConstraintCall :: OOProg r => GenState (Maybe (MSStatement r))
getCalcCall :: OOProg r => CodeDefinition -> GenState (Maybe (MSStatement r))
getOutputCall :: OOProg r => GenState (Maybe (MSStatement r))

module Language.Drasil.Code.Imperative.Modules
genMain :: OOProg r => GenState (SFile r)
genMainFunc :: OOProg r => GenState (Maybe (SMethod r))
chooseInModule :: OOProg r => InputModule -> GenState [SFile r]

-- | Returns Nothing if no inputs or constants are mapped to
--   InputParameters in the class definition map. If any inputs or
--   constants are defined in InputParameters, this generates the
--   InputParameters class containing the inputs and constants as state
--   variables. If the InputParameters constructor is also exported, then
--   the generated class also contains the input-related functions as
--   private methods
genInputClass :: OOProg r => ClassType -> GenState (Maybe (SClass r))
genInputDerived :: OOProg r => ScopeTag -> GenState (Maybe (SMethod r))
genInputConstraints :: OOProg r => ScopeTag -> GenState (Maybe (SMethod r))
genInputFormat :: OOProg r => ScopeTag -> GenState (Maybe (SMethod r))
genConstMod :: OOProg r => GenState [SFile r]
genConstClass :: OOProg r => ClassType -> GenState (Maybe (SClass r))
genCalcMod :: OOProg r => GenState (SFile r)
genCalcFunc :: OOProg r => CodeDefinition -> GenState (SMethod r)
genOutputMod :: OOProg r => GenState [SFile r]
genOutputFormat :: OOProg r => GenState (Maybe (SMethod r))
genSampleInput :: AuxiliarySym r => GenState (Maybe (r (Auxiliary r)))
instance GHC.Classes.Eq Language.Drasil.Code.Imperative.Modules.CalcType


-- | Defines generation functions for SCS code packages.
module Language.Drasil.Code.Imperative.Generator

-- | Initializes the generator's DrasilState. String parameter is a string
--   representing the date. [Expr] parameter is the sample input values
--   provided by the user
generator :: Lang -> String -> [Expr] -> Choices -> CodeSpec -> DrasilState

-- | Generates a package with the given DrasilState. The passed
--   un-representation functions determine which target language the
--   package will be generated in.
generateCode :: (OOProg progRepr, PackageSym packRepr) => Lang -> (progRepr (Program progRepr) -> ProgData) -> (packRepr (Package packRepr) -> PackData) -> DrasilState -> IO ()


-- | re-export smart constructors for external code writing
module Language.Drasil.Code

-- | Takes code
makeCode :: [FileData] -> [AuxData] -> Code

-- | Creates the requested <a>Code</a> by producing files
createCodeFiles :: Code -> IO ()

-- | Initializes the generator's DrasilState. String parameter is a string
--   representing the date. [Expr] parameter is the sample input values
--   provided by the user
generator :: Lang -> String -> [Expr] -> Choices -> CodeSpec -> DrasilState

-- | Generates a package with the given DrasilState. The passed
--   un-representation functions determine which target language the
--   package will be generated in.
generateCode :: (OOProg progRepr, PackageSym packRepr) => Lang -> (progRepr (Program progRepr) -> ProgData) -> (packRepr (Package packRepr) -> PackData) -> DrasilState -> IO ()

-- | Reads data from a file and converts the values to Exprs. The file must
--   be formatted according to the DataDesc passed as a parameter.
readWithDataDesc :: FilePath -> DataDesc' -> IO [Expr]

-- | Defines the DataDesc for the file containing a sample data set, which
--   a user must supply if they want to generate a sample input file.
sampleInputDD :: [CodeVarChunk] -> DataDesc'
data Choices
Choices :: [Lang] -> Modularity -> Structure -> ConstantStructure -> ConstantRepr -> ConceptMatchMap -> SpaceMatch -> ImplementationType -> [ODELibPckg] -> [ODEInfo] -> ConstraintBehaviour -> ConstraintBehaviour -> [Comments] -> Verbosity -> Visibility -> [Logging] -> FilePath -> [AuxFile] -> Choices
[lang] :: Choices -> [Lang]
[modularity] :: Choices -> Modularity
[inputStructure] :: Choices -> Structure
[constStructure] :: Choices -> ConstantStructure
[constRepr] :: Choices -> ConstantRepr
[conceptMatch] :: Choices -> ConceptMatchMap
[spaceMatch] :: Choices -> SpaceMatch
[impType] :: Choices -> ImplementationType
[odeLib] :: Choices -> [ODELibPckg]
[odes] :: Choices -> [ODEInfo]
[onSfwrConstraint] :: Choices -> ConstraintBehaviour
[onPhysConstraint] :: Choices -> ConstraintBehaviour
[comments] :: Choices -> [Comments]
[doxVerbosity] :: Choices -> Verbosity
[dates] :: Choices -> Visibility
[logging] :: Choices -> [Logging]
[logFile] :: Choices -> FilePath
[auxFiles] :: Choices -> [AuxFile]
data Comments
CommentFunc :: Comments
CommentClass :: Comments
CommentMod :: Comments
data Verbosity
Verbose :: Verbosity
Quiet :: Verbosity
data ConstraintBehaviour
Warning :: ConstraintBehaviour
Exception :: ConstraintBehaviour
data ImplementationType
Library :: ImplementationType
Program :: ImplementationType
data Logging
LogFunc :: Logging
LogVar :: Logging
data Modularity
Modular :: InputModule -> Modularity
Unmodular :: Modularity
data Structure
Unbundled :: Structure
Bundled :: Structure
data ConstantStructure
Inline :: ConstantStructure
WithInputs :: ConstantStructure
Store :: Structure -> ConstantStructure
data ConstantRepr
Var :: ConstantRepr
Const :: ConstantRepr
data InputModule
Combined :: InputModule
Separated :: InputModule
data CodeConcept
Pi :: CodeConcept

-- | Builds a ConceptMatchMap from an association list of chunks and
--   CodeConcepts
matchConcepts :: HasUID c => [(c, [CodeConcept])] -> ConceptMatchMap

-- | Specifies which CodeType should be used to represent each mathematical
--   Space. [CodeType] is preferentially-ordered, first CodeType that does
--   not conflict with other choices will be selected.
type SpaceMatch = Space -> [CodeType]

-- | Builds a SpaceMatch from an association list of Spaces and CodeTypes.
matchSpaces :: [(Space, [CodeType])] -> SpaceMatch
data AuxFile
SampleInput :: FilePath -> AuxFile
ReadME :: AuxFile
getSampleData :: Choices -> Maybe FilePath
data Visibility
Show :: Visibility
Hide :: Visibility

-- | Default choices to be used as the base from which design
--   specifications can be built.
defaultChoices :: Choices
data CodeSpec
[CodeSpec] :: HasName a => {pName :: Name, authors :: [a], inputs :: [Input], extInputs :: [Input], derivedInputs :: [Derived], outputs :: [Output], configFiles :: [FilePath], execOrder :: [Def], cMap :: ConstraintMap, constants :: [Const], constMap :: ConstantMap, mods :: [Mod], sysinfodb :: ChunkDB} -> CodeSpec

-- | Get a UID of a chunk corresponding to a Func
funcUID :: Func -> UID

-- | FIXME: hack. Use for implementation-stage functions that need to be
--   displayed in the SRS.
funcUID' :: Func -> UID

-- | Convert a Func to an implementation-stage QuantityDict representing
--   the function.
asVC :: Func -> QuantityDict

-- | FIXME: Part of above hack
asVC' :: Func -> QuantityDict

-- | Defines a CodeSpec based on the SystemInformation, Choices, and Mods
--   defined by the user.
codeSpec :: SystemInformation -> Choices -> [Mod] -> CodeSpec
relToQD :: ExprRelat c => ChunkDB -> c -> QDefinition

-- | Define an assignment statement
($:=) :: (Quantity c, MayHaveUnit c) => c -> Expr -> FuncStmt
data Mod
Mod :: Name -> Description -> [Import] -> [Class] -> [Func] -> Mod
data StateVariable
data Func
data FuncStmt
[FAsg] :: CodeVarChunk -> Expr -> FuncStmt
[FAsgIndex] :: CodeVarChunk -> Integer -> Expr -> FuncStmt
[FFor] :: CodeVarChunk -> Expr -> [FuncStmt] -> FuncStmt
[FForEach] :: CodeVarChunk -> Expr -> [FuncStmt] -> FuncStmt
[FWhile] :: Expr -> [FuncStmt] -> FuncStmt
[FCond] :: Expr -> [FuncStmt] -> [FuncStmt] -> FuncStmt
[FRet] :: Expr -> FuncStmt
[FThrow] :: String -> FuncStmt
[FTry] :: [FuncStmt] -> [FuncStmt] -> FuncStmt
[FContinue] :: FuncStmt
[FDecDef] :: CodeVarChunk -> Expr -> FuncStmt
[FFuncDef] :: CodeFuncChunk -> [ParameterChunk] -> [FuncStmt] -> FuncStmt
[FVal] :: Expr -> FuncStmt
[FMulti] :: [FuncStmt] -> FuncStmt
[FAppend] :: Expr -> Expr -> FuncStmt

-- | Define a public state variable based on the given CodeVarChunk
pubStateVar :: CodeVarChunk -> StateVariable

-- | Define a private state variable based on the given CodeVarChunk
privStateVar :: CodeVarChunk -> StateVariable

-- | Define a declare-define statement.
fDecDef :: (Quantity c, MayHaveUnit c) => c -> Expr -> FuncStmt

-- | Define a for-loop. Quantity is for the iteration variable, Expr is the
--   upper bound at that variable (the variable will start with a value of
--   0). [FuncStmt] is for the loop body.
ffor :: (Quantity c, MayHaveUnit c) => c -> Expr -> [FuncStmt] -> FuncStmt

-- | Define a function that reads data from a file, according to the given
--   DataDesc.
funcData :: Name -> Description -> DataDesc -> Func

-- | Define a function by providing the FuncStmts for its body. Other
--   parameters are function name, description, list of parameters, space
--   of the returned value, and description of the returned value.
funcDef :: (Quantity c, MayHaveUnit c) => Name -> Description -> [c] -> Space -> Maybe Description -> [FuncStmt] -> Func

-- | Define a Mod with the given Name, Description, Classes, and Functions.
packmod :: Name -> Description -> [Class] -> [Func] -> Mod
junkLine :: Data
multiLine :: LinePattern -> Delim -> Data
repeated :: [DataItem] -> LinePattern
singleLine :: LinePattern -> Delim -> Data
singleton :: DataItem -> Data
type ExternalLibrary = [StepGroup]
data Step
data FunctionInterface
data Argument
externalLib :: [StepGroup] -> ExternalLibrary
choiceSteps :: [[Step]] -> StepGroup
choiceStep :: [Step] -> StepGroup
mandatoryStep :: Step -> StepGroup
mandatorySteps :: [Step] -> StepGroup
callStep :: FunctionInterface -> Step
libFunction :: Requires -> CodeFuncChunk -> [Argument] -> FunctionInterface
libMethod :: Requires -> CodeVarChunk -> CodeFuncChunk -> [Argument] -> FunctionInterface
libFunctionWithResult :: Requires -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libMethodWithResult :: Requires -> CodeVarChunk -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libConstructor :: Requires -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
libConstructorMultiReqs :: [Requires] -> CodeFuncChunk -> [Argument] -> CodeVarChunk -> FunctionInterface
constructAndReturn :: Requires -> CodeFuncChunk -> [Argument] -> FunctionInterface
lockedArg :: Expr -> Argument
lockedNamedArg :: NamedArgument -> Expr -> Argument
inlineArg :: Space -> Argument
inlineNamedArg :: NamedArgument -> Space -> Argument
preDefinedArg :: CodeVarChunk -> Argument
preDefinedNamedArg :: NamedArgument -> CodeVarChunk -> Argument
functionArg :: CodeFuncChunk -> [Parameter] -> Step -> Argument
customObjArg :: [Requires] -> Description -> CodeVarChunk -> CodeFuncChunk -> ClassInfo -> Argument
recordArg :: Requires -> CodeFuncChunk -> CodeVarChunk -> [CodeVarChunk] -> Argument
lockedParam :: CodeVarChunk -> Parameter
unnamedParam :: Space -> Parameter
customClass :: [MethodInfo] -> ClassInfo
implementation :: String -> [MethodInfo] -> ClassInfo
constructorInfo :: CodeFuncChunk -> [Parameter] -> [Step] -> MethodInfo
methodInfo :: CodeFuncChunk -> Description -> [Parameter] -> Description -> [Step] -> MethodInfo
methodInfoNoReturn :: CodeFuncChunk -> Description -> [Parameter] -> [Step] -> MethodInfo
appendCurrSol :: Expr -> Step
populateSolList :: CodeVarChunk -> CodeVarChunk -> CodeVarChunk -> [Step]
assignArrayIndex :: Step
assignSolFromObj :: CodeVarChunk -> Step
initSolListFromArray :: CodeVarChunk -> Step
initSolListWithVal :: Step
solveAndPopulateWhile :: FunctionInterface -> CodeVarChunk -> CodeVarChunk -> FunctionInterface -> CodeVarChunk -> Step
returnExprList :: Step
fixedReturn :: Expr -> Step
initSolWithVal :: Step
type ExternalLibraryCall = [StepGroupFill]
data StepGroupFill
SGF :: Int -> [StepFill] -> StepGroupFill
data StepFill
CallF :: FunctionIntFill -> StepFill
LoopF :: NonEmpty FunctionIntFill -> [Expr] -> NonEmpty StepFill -> StepFill
StatementF :: [CodeVarChunk] -> [Expr] -> StepFill
newtype FunctionIntFill
FIF :: [ArgumentFill] -> FunctionIntFill
data ArgumentFill
UserDefinedArgF :: Maybe NamedArgument -> Expr -> ArgumentFill
BasicF :: Expr -> ArgumentFill
FnF :: [ParameterFill] -> StepFill -> ArgumentFill
ClassF :: [StateVariable] -> ClassInfoFill -> ArgumentFill
RecordF :: [Expr] -> ArgumentFill
data ParameterFill
NameableParamF :: ParameterChunk -> ParameterFill
UserDefined :: ParameterChunk -> ParameterFill
data ClassInfoFill
RegularF :: [MethodInfoFill] -> ClassInfoFill
ImplementsF :: [MethodInfoFill] -> ClassInfoFill
data MethodInfoFill
CIF :: [ParameterFill] -> [Initializer] -> [StepFill] -> MethodInfoFill
MIF :: [ParameterFill] -> NonEmpty StepFill -> MethodInfoFill
externalLibCall :: [StepGroupFill] -> ExternalLibraryCall
choiceStepsFill :: Int -> [StepFill] -> StepGroupFill
choiceStepFill :: Int -> StepFill -> StepGroupFill
mandatoryStepFill :: StepFill -> StepGroupFill
mandatoryStepsFill :: [StepFill] -> StepGroupFill
callStepFill :: FunctionIntFill -> StepFill
libCallFill :: [ArgumentFill] -> FunctionIntFill
userDefinedArgFill :: Expr -> ArgumentFill
basicArgFill :: Expr -> ArgumentFill
functionArgFill :: [ParameterFill] -> StepFill -> ArgumentFill
customObjArgFill :: [StateVariable] -> ClassInfoFill -> ArgumentFill
recordArgFill :: [Expr] -> ArgumentFill
unnamedParamFill :: CodeVarChunk -> ParameterFill
unnamedParamPBVFill :: CodeVarChunk -> ParameterFill
userDefinedParamFill :: CodeVarChunk -> ParameterFill
customClassFill :: [MethodInfoFill] -> ClassInfoFill
implementationFill :: [MethodInfoFill] -> ClassInfoFill
constructorInfoFill :: [ParameterFill] -> [Initializer] -> [StepFill] -> MethodInfoFill
methodInfoFill :: [ParameterFill] -> [StepFill] -> MethodInfoFill
appendCurrSolFill :: CodeVarChunk -> StepFill
populateSolListFill :: CodeVarChunk -> [StepFill]
assignArrayIndexFill :: CodeVarChunk -> [Expr] -> StepFill
assignSolFromObjFill :: CodeVarChunk -> StepFill
initSolListFromArrayFill :: CodeVarChunk -> StepFill
initSolListWithValFill :: CodeVarChunk -> Expr -> StepFill
solveAndPopulateWhileFill :: FunctionIntFill -> Expr -> FunctionIntFill -> CodeVarChunk -> StepFill
returnExprListFill :: [Expr] -> StepFill
fixedStatementFill :: StepFill
initSolWithValFill :: CodeVarChunk -> Expr -> StepFill
data Lang
Cpp :: Lang
CSharp :: Lang
Java :: Lang
Python :: Lang
Swift :: Lang
class (AuxiliarySym r) => PackageSym r where {
    type family Package r;
}
package :: PackageSym r => ProgData -> [r (Auxiliary r)] -> r (Package r)
class AuxiliarySym r where {
    type family Auxiliary r;
    type family AuxHelper r;
}
doxConfig :: AuxiliarySym r => String -> GOOLState -> Verbosity -> r (Auxiliary r)
readMe :: AuxiliarySym r => ReadMeInfo -> r (Auxiliary r)
sampleInput :: AuxiliarySym r => ChunkDB -> DataDesc -> [Expr] -> r (Auxiliary r)
optimizeDox :: AuxiliarySym r => r (AuxHelper r)
makefile :: AuxiliarySym r => [FilePath] -> ImplementationType -> [Comments] -> GOOLState -> ProgData -> r (Auxiliary r)
auxHelperDoc :: AuxiliarySym r => r (AuxHelper r) -> Doc
auxFromData :: AuxiliarySym r => FilePath -> Doc -> r (Auxiliary r)
data AuxData
data PackData
data CodeChunk
data CodeVarChunk
data CodeFuncChunk

-- | Construct a CodeVarChunk from a Quantity
quantvar :: (Quantity c, MayHaveUnit c) => c -> CodeVarChunk

-- | Construct a CodeFuncChunk from a Quantity
quantfunc :: (Quantity c, MayHaveUnit c) => c -> CodeFuncChunk
ccObjVar :: CodeVarChunk -> CodeVarChunk -> CodeVarChunk
listToArray :: CodeVarChunk -> CodeVarChunk

-- | Constructs an Expr representing the field of an actor
field :: CodeVarChunk -> CodeVarChunk -> Expr
data ODEInfo
ODEInfo :: CodeVarChunk -> CodeVarChunk -> [CodeVarChunk] -> Expr -> Expr -> Expr -> [Expr] -> ODEOptions -> ODEInfo
[indepVar] :: ODEInfo -> CodeVarChunk
[depVar] :: ODEInfo -> CodeVarChunk
[otherVars] :: ODEInfo -> [CodeVarChunk]
[tInit] :: ODEInfo -> Expr
[tFinal] :: ODEInfo -> Expr
[initVal] :: ODEInfo -> Expr
[odeSyst] :: ODEInfo -> [Expr]
[odeOpts] :: ODEInfo -> ODEOptions
odeInfo :: CodeVarChunk -> CodeVarChunk -> [CodeVarChunk] -> Expr -> Expr -> Expr -> [Expr] -> ODEOptions -> ODEInfo
data ODEOptions
ODEOpts :: ODEMethod -> Expr -> Expr -> Expr -> Expr -> ODEOptions
[solveMethod] :: ODEOptions -> ODEMethod
[absTol] :: ODEOptions -> Expr
[relTol] :: ODEOptions -> Expr
[stepSize] :: ODEOptions -> Expr
[initValFstOrd] :: ODEOptions -> Expr
odeOptions :: ODEMethod -> Expr -> Expr -> Expr -> Expr -> ODEOptions
data ODEMethod
RK45 :: ODEMethod
BDF :: ODEMethod
Adams :: ODEMethod
data ODELibPckg
ODELib :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> Maybe FilePath -> [Lang] -> ODELibPckg
[libName] :: ODELibPckg -> Name
[libVers] :: ODELibPckg -> Version
[libSpec] :: ODELibPckg -> ExternalLibrary
[libCall] :: ODELibPckg -> ODEInfo -> ExternalLibraryCall
[libPath] :: ODELibPckg -> Maybe FilePath
[compatibleLangs] :: ODELibPckg -> [Lang]

-- | Makes an ODELibPckg with the given name, ExternalLibrary
--   specification, ExternalLibraryCall specification parameterized by an
--   ODEInfo, local file path to the library, and list of compatible
--   languages.
mkODELib :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> FilePath -> [Lang] -> ODELibPckg

-- | Makes an ODELibPckg with the given name, ExternalLibrary
--   specification, ExternalLibraryCall specification parameterized by an
--   ODEInfo, and list of compatible languages.
mkODELibNoPath :: Name -> Version -> ExternalLibrary -> (ODEInfo -> ExternalLibraryCall) -> [Lang] -> ODELibPckg
unPP :: PythonProject a -> a
unJP :: JavaProject a -> a
unCSP :: CSharpProject a -> a
unCPPP :: CppProject a -> a
unSP :: SwiftProject a -> a

module Data.Drasil.ExternalLibraries.ODELibraries
scipyODEPckg :: ODELibPckg
scipyODESymbols :: [QuantityDict]
osloPckg :: ODELibPckg
osloSymbols :: [QuantityDict]
arrayVecDepVar :: ODEInfo -> CodeVarChunk
apacheODEPckg :: ODELibPckg
apacheODESymbols :: [QuantityDict]
odeintPckg :: ODELibPckg
odeintSymbols :: [QuantityDict]
scipyODELSodaPkg :: ODELibPckg
