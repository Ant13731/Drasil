-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Utils SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-utils
@version 0.1.1.0

module Utils.Drasil.Sentence

-- | Inserts the words "and its" between two Sentences
andIts :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and the" between two Sentences
andThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "from the" between two Sentences
fromThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "in the" between two Sentences
inThe :: Sentence -> Sentence -> Sentence

-- | Prepends <a>The</a> and inserts "is expected to have" between two
--   Sentences
isExpctdToHv :: Sentence -> Sentence -> Sentence

-- | Inserts the words "is the" between two Sentences
isThe :: Sentence -> Sentence -> Sentence

-- | Prepends "the" and inserts "of a given" between two Sentences
ofGiv :: Sentence -> Sentence -> Sentence

-- | Similar to <a>sFor</a>, but used for titles and first <a>NamedIdea</a>
--   is pluralized
forTT :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <a>forTT</a>, but both <a>NamedIdea</a>s are pluralized
forTT' :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Same as <a>ofGiv</a>, except first "the" is capitalized
ofGiv' :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of the" between two Sentences
ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>ofThe</a>, but inserts "the" at the beginning of the
--   Sentence
the_ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>the_ofThe</a>, except first "the" is capitalized
the_ofThe' :: Sentence -> Sentence -> Sentence

-- | Inserts the word "of" between two Sentences
sOf :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of a" between two Sentences
sOfA :: Sentence -> Sentence -> Sentence

-- | Inserts the word "or" between two Sentences
sOr :: Sentence -> Sentence -> Sentence

-- | Inserts the word "versus" between two Sentences
sVersus :: Sentence -> Sentence -> Sentence

-- | Inserts the word "and" between two Sentences
sAnd :: Sentence -> Sentence -> Sentence

-- | Inserts the word "are" between two Sentences
sAre :: Sentence -> Sentence -> Sentence

-- | Inserts the word "in" between two Sentences
sIn :: Sentence -> Sentence -> Sentence

-- | Inserts the word "is" between two Sentences
sIs :: Sentence -> Sentence -> Sentence

-- | Inserts the words "to the" between two Sentences
toThe :: Sentence -> Sentence -> Sentence

-- | Inserts the word "for" between two Sentences
sFor :: Sentence -> Sentence -> Sentence

-- | Similar to <a>sFor</a>, but both terms are <a>titleize</a>d
sFor' :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <a>sFor'</a>, but takes two arguments (for capitalization
--   or pluralization) to apply to the two terms respectively
sFor'' :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> Sentence

-- | Inserts the words "denotes the" between two Sentences
denotes :: Sentence -> Sentence -> Sentence

-- | Inserts the words "with respect to" between two Sentences
wrt :: Sentence -> Sentence -> Sentence

-- | Inserts the words "defined as" between two Sentences
defnAs :: Sentence -> Sentence -> Sentence

module Utils.Drasil

-- | enumBullet applies <a>Enumeration</a>, <a>Bullet</a> and <a>Flat</a>
--   to a list
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | same as <a>enumBullet</a> but unlabelled
enumBulletU :: [Sentence] -> Contents

-- | enumSimple enumerates a list and applies <a>Simple</a> and
--   <a>Enumeration</a> to it: s - start index for the enumeration, t -
--   title of the list, l - list to be enumerated,
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | same as <a>enumSimple</a> but unlabelled
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Constructs LabelledContent from an expression and a reference
eqUnR :: Expr -> Reference -> LabelledContent

-- | Same as <a>eqUnR</a> except content is unlabelled
eqUnR' :: Expr -> Contents

-- | mkEnumSimpleD is a convenience function for transforming types which
--   are instances of the constraints Referable, HasShortName, and
--   Definition, into Simple-type Enumerations.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]
blank :: Doc
indent :: Doc -> Doc
indentList :: [Doc] -> Doc

-- | String capitalization
capitalize :: String -> String

-- | Comma separated list with "and" before final item
stringList :: [String] -> String
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType
data WrapType
Parens :: WrapType
Period :: WrapType
data SepType
Comma :: SepType
SemiCol :: SepType
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting constraints
foldConstraints :: Quantity c => c -> [Constraint] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or"
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of foldle for sentences specifically.
--   folds with spaces and adds "." at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not end with period
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13")
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"])
numList :: String -> [Int] -> [String]

-- | Converts input to a Sentence and appends %
addPercent :: Show a => a -> Sentence

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>:
--   t - Headers of the <a>Nested</a> lists, l - Lists of <a>ListType</a>
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Uses an Either type to check if a string is valid - Left with error
--   message if invalid Char in String, else Right with String
checkValidStr :: String -> String -> Either String String

-- | Output is of the form "reference - sentence"
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a HasSymbol that is also Referable and outputs as a Sentence
--   "<tt>symbol</tt> is defined in <tt>reference</tt>"
definedIn :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence

-- | Same as definedIn, but allows for addition information to be appended
definedIn' :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence -> Sentence

-- | Takes a Referable and outputs as a Sentence "defined in
--   <tt>reference</tt>" (no HasSymbol)
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Produces a sentence that displays the constraints in a {}.
displayStrConstrntsAsSet :: Quantity a => a -> [String] -> Sentence

-- | Produces a sentence that displays the constraints in a {}.
displayDblConstrntsAsSet :: Quantity a => a -> [Double] -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>
eqN :: Int -> Sentence

-- | Takes an expression and a referable and outputs as a Sentence
--   "expression (source)"
eqnWSource :: (Referable r, HasShortName r) => Expr -> r -> Sentence

-- | Takes a referable source and a <a>UnitalChunk</a> and outputs as a
--   Sentence "From <tt>source</tt> we can replace <tt>symbol</tt>"
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount and adds a unit to it: n - sentenc representing an
--   amount, u - unit we want to attach to amount
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a Sentence
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in..."
getTandS :: Quantity a => a -> Sentence

-- | Makes Sentences from an item and its reference: a - String title of
--   reference, b - Sentence containing the full reference
itemRefToSent :: String -> Sentence -> Sentence

-- | Takes a list and a reference, generates references to match the length
--   of the list: l - list whos length is to be matched
makeListRef :: [a] -> Section -> [Sentence]

-- | Makes a traceability matrix from a list of row titles, list of rows of
--   "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Zip helper function enumerates abbreviation and zips it with list of
--   ItemType: s - the number from which the enumeration should start from,
--   t - the title of the list, l - the list to be enumerated
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in Contents but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Returns the Sentence "<tt>aNamedIdea</tt> Showing the Connections
--   Between <tt>contents</tt>"
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by Symbol
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the tuple
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Takes a list of Referables and Symbols and outputs as a Sentence "By
--   substituting <tt>symbols</tt>, this can be written as"
substitute :: (Referable r, HasShortName r, HasSymbol r) => [r] -> Sentence

-- | Helpful combinators for making Sentences for Terminologies with
--   Definitions. term - definition
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making Sentences for Terminologies with
--   Definitions. term (acc) - definition
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making Sentences for Terminologies with
--   Definitions. term (symbol) - definition
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the Sentence "The <tt>chunk</tt> under consideration is
--   <tt>definition</tt>"
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one
unwrap :: Maybe UnitDefn -> Sentence

-- | Interweaves two lists together [[a,b,c],[d,e,f]] -&gt; [a,d,b,e,c,f]
weave :: [[a]] -> [a]

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences. For example: &gt;&gt;&gt;
--   zipSentList [S <a>Hi</a>, S <a>Hey</a>, S <a>Hi</a>] [[S<a>Hello</a>],
--   [S<a>World</a>], [S<a>Hello</a>, S"World]] [[S <a>Hi</a>,
--   S<a>Hello</a>], [S <a>Hey</a>, S<a>World</a>], [S <a>Hi</a>,
--   S<a>Hello</a>, S"World]]
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

-- | Creates a NP by combining two <a>NamedIdea</a>s with the word "and"
--   between their terms. Plural is defaulted to <tt>(phrase t1) "of"
--   (plural t2)</tt>
and_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>and_</a> combinator, except phrase default of second term
--   is plural instead of phrase
and_' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Customizable <a>and_</a> combinator (takes two title case
--   capitalization rules and two NamedIdeas)
andRT :: (NamedIdea c, NamedIdea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Combinator for combining two <a>NamedChunk</a>s into one. <i>Does not
--   preserve abbreviations</i>
compoundNC :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk

-- | Similar to <a>compoundNC</a> but uses <a>pluralNP</a> for plural cases
compoundNC' :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk

-- | Similar to <a>compoundNC</a>, except plural cases are customizable
compoundNC'' :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> (NP -> Sentence) -> a -> b -> NamedChunk
compoundNC''' :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> a -> b -> NamedChunk

-- | Similar to <a>compoundNC'''</a> but sets first parameter function to
--   plural
compoundNCP1 :: NamedChunk -> NamedChunk -> NamedChunk

-- | Similar to <a>compoundNC</a>, except first parameter gets pluralized
--   while second one stays singular
compoundNCPlPh :: NamedChunk -> NamedChunk -> NamedChunk

-- | Creates a noun phrase by combining two <a>NamedIdea</a>s with the word
--   "for" between their terms. Plural is defaulted to <tt>(plural t1)
--   "for" (phrase t2)</tt>
for :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Similar to <a>for</a>, but takes two functions that determine the
--   <a>titleCase</a>
for' :: (NamedIdea c, Idea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a noun phrase by combining two <a>NamedIdea</a>s with the word
--   "of" between their terms. Plural is defaulted to <tt>(phrase t1) "of"
--   (plural t2)</tt>
of_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Similar to <a>of_</a>, but <a>phrase</a> is defaulted to <tt>(phrase
--   t1) "of" (plural t2)</tt>. Plural is the same.
of_' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except plural is defaulted to <tt>(plural t1) "of"
--   (phrase t2)</tt>
of_'' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except phrase and plural default to <tt>(plural
--   t1) "of" (phrase t2)</tt>
of__ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of__</a>, except combining Sentence piece is "of a"
ofA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a> but second argument is a <a>NounPhrase</a>
ofN_ :: (NamedIdea c, NounPhrase d) => c -> d -> NP

-- | Prepends "the" to a <a>NamedIdea</a>. Similar to <a>the'</a>, but not
--   titleized
the :: NamedIdea t => t -> NP

-- | Prepends "the" to a titleized <a>NamedIdea</a>
the' :: NamedIdea t => t -> NP

-- | A customizable version of <a>the</a>
the'' :: (t -> Sentence) -> t -> NP

-- | Creates a noun phrase by combining two <a>NamedIdea</a>s with the
--   words "in the" between their terms. Plural is defaulted to <tt>(plural
--   t1) "in the" (phrase t2)</tt>
inThe' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Case with "T1s with T2", as opposed to "T1 with T2", i.e. phrase
--   defaults to <tt>(plural t1) "with" (phrase t2)</tt> while plural
--   pluralizes both.
with :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining Sentence piece is "of the"
ofThe' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Helper function that places a string in between two <a>NP</a>s. Plural
--   is defaulted to <tt>phraseNP t1 +:+ S s +:+ pluralNP t2</tt>
insertStringNP :: String -> NP -> NP -> NP

-- | Helper function that prepends a string to a <a>NP</a>
prependStringNP :: String -> NP -> NP

-- | Helper function that places a Sentence in between two <a>NP</a>s.
--   Plural is defaulted to <tt>phraseNP t1 +:+ s +:+ pluralNP t2</tt>
insertSentNP :: Sentence -> NP -> NP -> NP

-- | Helper function that prepends a <a>Sentence</a> to a <a>NP</a>
prependSentNP :: Sentence -> NP -> NP

-- | Prepends "the" to a <a>NP</a>
theNP :: NP -> NP

-- | Similar to <a>theNP</a>, but accepts a function that determines the
--   plural case
theNP' :: (NP -> Sentence) -> NP -> NP

-- | Prepends "a" to a <a>NP</a>
aNP :: NP -> NP

-- | Similar to <a>aNP</a>, but accepts a function that determines the
--   plural case
aNP' :: (NP -> Sentence) -> NP -> NP

-- | Inserts "of the" between two <a>NP</a>s
ofTheNP :: NP -> NP -> NP

-- | Similar to <a>ofTheNP</a>, but the plural case is now <tt>pluralNP t1
--   <a>ofThe</a> phraseNP t2</tt>
ofTheNP' :: NP -> NP -> NP

-- | Similar to <a>ofTheNP</a>, but accepts two functions for the plural
--   case
ofTheNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "in the" between two <a>NP</a>s
inTheNP :: NP -> NP -> NP

-- | Similar to <a>ofTheNP</a>, but the plural case is now <tt>pluralNP t1
--   <a>inThe</a> phraseNP t2</tt>
inTheNP' :: NP -> NP -> NP

-- | Similar to <a>ofTheNP</a>, but accepts two functions for the plural
--   case
inTheNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Prepends "the" and inserts "of the"
the_ofTheNP :: NP -> NP -> NP

-- | Similar to <a>the_ofTheNP</a>, but the plural case is now <tt> S "the"
--   +:+ pluralNP t1 <a>ofThe</a> phraseNP t2</tt>
the_ofTheNP' :: NP -> NP -> NP

-- | Similar to <a>the_ofTheNP'</a>, but takes two functions for the plural
--   case
the_ofTheNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "for" between two <a>NP</a>s
forNP :: NP -> NP -> NP

-- | Same as <a>forNP</a>, but plural case is now <tt>pluralNP t1
--   <a>sFor</a> phraseNP t2</tt>
forNP' :: NP -> NP -> NP

-- | Same as <a>forNP'</a>, but takes two functions for the plural case
forNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "of" between two <a>NP</a>s
ofNP :: NP -> NP -> NP

-- | Same as <a>ofNP</a>, but plural case is now <tt>pluralNP t1 <a>sOf</a>
--   phraseNP t2</tt>
ofNP' :: NP -> NP -> NP

-- | Same as <a>ofNP</a>, but takes two functions for the plural case
ofNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>ofNP</a>, but takes two functions for the singular case and
--   two for the plural case
ofNP''' :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "with" between two <a>NP</a>s
withNP :: NP -> NP -> NP

-- | Inserts "and" between two <a>NP</a>s
andNP :: NP -> NP -> NP

-- | Same as <a>andNP</a>, but plural case is now <tt>pluralNP t1
--   <a>sAnd</a> phraseNP t2</tt>
andNP' :: NP -> NP -> NP

-- | Same as <a>andNP</a>, but takes two functions for the plural case
andNP'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>andNP</a>, but takes two functions for the singular case
--   and two for the plural case
andNP''' :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP
