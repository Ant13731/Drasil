-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Language SubPackage
--   
--   A framework for code and document generation for scientific software -
--   Language SubPackage
@package drasil-lang
@version 0.1.60


-- | Alphabet of capital/lowercase English letters as symbols
module Language.Drasil.ShortHands

-- | c_ means capital _; l_ means lowercase _
cA :: Symbol

-- | c_ means capital _; l_ means lowercase _
cB :: Symbol

-- | c_ means capital _; l_ means lowercase _
cC :: Symbol

-- | c_ means capital _; l_ means lowercase _
cD :: Symbol

-- | c_ means capital _; l_ means lowercase _
cE :: Symbol

-- | c_ means capital _; l_ means lowercase _
cF :: Symbol

-- | c_ means capital _; l_ means lowercase _
cG :: Symbol

-- | c_ means capital _; l_ means lowercase _
cH :: Symbol

-- | c_ means capital _; l_ means lowercase _
cI :: Symbol

-- | c_ means capital _; l_ means lowercase _
cJ :: Symbol

-- | c_ means capital _; l_ means lowercase _
cK :: Symbol

-- | c_ means capital _; l_ means lowercase _
cL :: Symbol

-- | c_ means capital _; l_ means lowercase _
cM :: Symbol

-- | c_ means capital _; l_ means lowercase _
cN :: Symbol

-- | c_ means capital _; l_ means lowercase _
cO :: Symbol

-- | c_ means capital _; l_ means lowercase _
cP :: Symbol

-- | c_ means capital _; l_ means lowercase _
cQ :: Symbol

-- | c_ means capital _; l_ means lowercase _
cR :: Symbol

-- | c_ means capital _; l_ means lowercase _
cS :: Symbol

-- | c_ means capital _; l_ means lowercase _
cT :: Symbol

-- | c_ means capital _; l_ means lowercase _
cU :: Symbol

-- | c_ means capital _; l_ means lowercase _
cV :: Symbol

-- | c_ means capital _; l_ means lowercase _
cW :: Symbol

-- | c_ means capital _; l_ means lowercase _
cX :: Symbol

-- | c_ means capital _; l_ means lowercase _
cY :: Symbol

-- | c_ means capital _; l_ means lowercase _
cZ :: Symbol

-- | c_ means capital _; l_ means lowercase _
lA :: Symbol

-- | c_ means capital _; l_ means lowercase _
lB :: Symbol

-- | c_ means capital _; l_ means lowercase _
lC :: Symbol

-- | c_ means capital _; l_ means lowercase _
lD :: Symbol

-- | c_ means capital _; l_ means lowercase _
lE :: Symbol

-- | c_ means capital _; l_ means lowercase _
lF :: Symbol

-- | c_ means capital _; l_ means lowercase _
lG :: Symbol

-- | c_ means capital _; l_ means lowercase _
lH :: Symbol

-- | c_ means capital _; l_ means lowercase _
lI :: Symbol

-- | c_ means capital _; l_ means lowercase _
lJ :: Symbol

-- | c_ means capital _; l_ means lowercase _
lK :: Symbol

-- | c_ means capital _; l_ means lowercase _
lL :: Symbol

-- | c_ means capital _; l_ means lowercase _
lM :: Symbol

-- | c_ means capital _; l_ means lowercase _
lN :: Symbol

-- | c_ means capital _; l_ means lowercase _
lO :: Symbol

-- | c_ means capital _; l_ means lowercase _
lP :: Symbol

-- | c_ means capital _; l_ means lowercase _
lQ :: Symbol

-- | c_ means capital _; l_ means lowercase _
lR :: Symbol

-- | c_ means capital _; l_ means lowercase _
lS :: Symbol

-- | c_ means capital _; l_ means lowercase _
lT :: Symbol

-- | c_ means capital _; l_ means lowercase _
lU :: Symbol

-- | c_ means capital _; l_ means lowercase _
lV :: Symbol

-- | c_ means capital _; l_ means lowercase _
lW :: Symbol

-- | c_ means capital _; l_ means lowercase _
lX :: Symbol

-- | c_ means capital _; l_ means lowercase _
lY :: Symbol

-- | c_ means capital _; l_ means lowercase _
lZ :: Symbol

-- | c_ means capital _; l_ means lowercase _
lAlpha :: Symbol

-- | c_ means capital _; l_ means lowercase _
cAlpha :: Symbol

-- | c_ means capital _; l_ means lowercase _
lBeta :: Symbol

-- | c_ means capital _; l_ means lowercase _
cBeta :: Symbol

-- | c_ means capital _; l_ means lowercase _
lGamma :: Symbol

-- | c_ means capital _; l_ means lowercase _
cGamma :: Symbol

-- | c_ means capital _; l_ means lowercase _
lDelta :: Symbol

-- | c_ means capital _; l_ means lowercase _
cDelta :: Symbol

-- | c_ means capital _; l_ means lowercase _
lEpsilon :: Symbol

-- | c_ means capital _; l_ means lowercase _
vEpsilon :: Symbol

-- | c_ means capital _; l_ means lowercase _
cEpsilon :: Symbol

-- | c_ means capital _; l_ means lowercase _
lZeta :: Symbol

-- | c_ means capital _; l_ means lowercase _
cZeta :: Symbol

-- | c_ means capital _; l_ means lowercase _
lEta :: Symbol

-- | c_ means capital _; l_ means lowercase _
cEta :: Symbol

-- | c_ means capital _; l_ means lowercase _
lTheta :: Symbol

-- | c_ means capital _; l_ means lowercase _
cTheta :: Symbol

-- | c_ means capital _; l_ means lowercase _
lIota :: Symbol

-- | c_ means capital _; l_ means lowercase _
cIota :: Symbol

-- | c_ means capital _; l_ means lowercase _
lKappa :: Symbol

-- | c_ means capital _; l_ means lowercase _
cKappa :: Symbol

-- | c_ means capital _; l_ means lowercase _
lLambda :: Symbol

-- | c_ means capital _; l_ means lowercase _
cLambda :: Symbol

-- | c_ means capital _; l_ means lowercase _
lMu :: Symbol

-- | c_ means capital _; l_ means lowercase _
cMu :: Symbol

-- | c_ means capital _; l_ means lowercase _
lNu :: Symbol

-- | c_ means capital _; l_ means lowercase _
cNu :: Symbol

-- | c_ means capital _; l_ means lowercase _
lXi :: Symbol

-- | c_ means capital _; l_ means lowercase _
cXi :: Symbol

-- | c_ means capital _; l_ means lowercase _
lOmicron :: Symbol

-- | c_ means capital _; l_ means lowercase _
cOmicron :: Symbol

-- | c_ means capital _; l_ means lowercase _
lPi :: Symbol

-- | c_ means capital _; l_ means lowercase _
cPi :: Symbol

-- | c_ means capital _; l_ means lowercase _
lRho :: Symbol

-- | c_ means capital _; l_ means lowercase _
cRho :: Symbol

-- | c_ means capital _; l_ means lowercase _
lSigma :: Symbol

-- | c_ means capital _; l_ means lowercase _
cSigma :: Symbol

-- | c_ means capital _; l_ means lowercase _
lTau :: Symbol

-- | c_ means capital _; l_ means lowercase _
cTau :: Symbol

-- | c_ means capital _; l_ means lowercase _
lUpsilon :: Symbol

-- | c_ means capital _; l_ means lowercase _
cUpsilon :: Symbol

-- | c_ means capital _; l_ means lowercase _
lPhi :: Symbol

-- | c_ means capital _; l_ means lowercase _
vPhi :: Symbol

-- | c_ means capital _; l_ means lowercase _
cPhi :: Symbol

-- | c_ means capital _; l_ means lowercase _
lChi :: Symbol

-- | c_ means capital _; l_ means lowercase _
cChi :: Symbol

-- | c_ means capital _; l_ means lowercase _
lPsi :: Symbol

-- | c_ means capital _; l_ means lowercase _
cPsi :: Symbol

-- | c_ means capital _; l_ means lowercase _
lOmega :: Symbol

-- | c_ means capital _; l_ means lowercase _
cOmega :: Symbol

-- | c_ means capital _; l_ means lowercase _
lNabla :: Symbol

-- | c_ means capital _; l_ means lowercase _
lEll :: Symbol

module Language.Drasil.Development
class NounPhrase n
phraseNP :: NounPhrase n => n -> Sentence
pluralNP :: NounPhrase n => n -> PluralForm

-- | Get dependencies from an equation
dep :: Expr -> [String]

-- | Generic traverse of all positions that could lead to names
names :: Expr -> [String]

-- | Generic traverse of all positions that could lead to names, without
--   functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
names' :: Expr -> [String]
sdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to reference UID
--   from sentences
lnames :: Sentence -> [UID]
lnames' :: [Sentence] -> [UID]

-- | prec - precedence for Binary-Associative (Commutative) operators
precA :: ArithOper -> Int
precB :: BoolOper -> Int

-- | eprec - <a>Expression</a> precedence
eprec :: Expr -> Int

module Data.Drasil.IdeaDicts
compScience :: IdeaDict
softEng :: IdeaDict
mathematics :: IdeaDict
progLanguage :: IdeaDict
idglass :: IdeaDict
physics :: IdeaDict
civilEng :: IdeaDict
materialEng :: IdeaDict
documentc :: IdeaDict
knowledgemng :: IdeaDict
dataDefn :: CI
genDefn :: CI
inModel :: CI
thModel :: CI

module Language.Drasil

-- | Drasil Expressions
data Expr
[Dbl] :: Double -> Expr
[Int] :: Integer -> Expr
[Str] :: String -> Expr
[AssocA] :: ArithOper -> [Expr] -> Expr
[AssocB] :: BoolOper -> [Expr] -> Expr
[Deriv] :: DerivType -> Expr -> UID -> Expr
[C] :: UID -> Expr
[FCall] :: Expr -> [Expr] -> Expr
[Case] :: [(Expr, Relation)] -> Expr
[Matrix] :: [[Expr]] -> Expr
[UnaryOp] :: UFunc -> Expr -> Expr
[BinaryOp] :: BinOp -> Expr -> Expr -> Expr
[Operator] :: ArithOper -> DomainDesc Expr Expr -> Expr -> Expr
[IsIn] :: Expr -> Space -> Expr
[RealI] :: UID -> RealInterval Expr Expr -> Expr
data BinOp
Frac :: BinOp
Pow :: BinOp
Subt :: BinOp
Eq :: BinOp
NEq :: BinOp
Lt :: BinOp
Gt :: BinOp
LEq :: BinOp
GEq :: BinOp
Impl :: BinOp
Iff :: BinOp
Index :: BinOp
Dot :: BinOp
Cross :: BinOp

-- | Unary functions
data UFunc
Norm :: UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Not :: UFunc
Neg :: UFunc
Dim :: UFunc
data ArithOper
Add :: ArithOper
Mul :: ArithOper
data BoolOper
And :: BoolOper
Or :: BoolOper
data DerivType
Part :: DerivType
Total :: DerivType
type Relation = Expr
($=) :: Expr -> Expr -> Expr
infixr 4 $=
($<) :: Expr -> Expr -> Expr
($<=) :: Expr -> Expr -> Expr
($>) :: Expr -> Expr -> Expr
($>=) :: Expr -> Expr -> Expr
($^) :: Expr -> Expr -> Expr
infixr 8 $^
($&&) :: Expr -> Expr -> Expr
infixr 9 $&&
($||) :: Expr -> Expr -> Expr
infixr 9 $||
($=>) :: Expr -> Expr -> Expr
($<=>) :: Expr -> Expr -> Expr
($.) :: Expr -> Expr -> Expr

-- | Get dependencies from an equation
dep :: Expr -> [String]

-- | Smart constructor to take the log of an expression
log :: Expr -> Expr

-- | Smart constructor to take the ln of an expression
ln :: Expr -> Expr

-- | Absolute value.
abs :: Num a => a -> a

-- | Smart constructor to apply sin to an expression
sin :: Expr -> Expr

-- | Smart constructor to apply cos to an expression
cos :: Expr -> Expr

-- | Smart constructor to apply tan to an expression
tan :: Expr -> Expr

-- | Smart constructor to apply sec to an expression
sec :: Expr -> Expr

-- | Smart constructor to apply csc to an expression
csc :: Expr -> Expr

-- | Smart constructor to apply cot to an expression
cot :: Expr -> Expr

-- | Smart constructor to apply arcsin to an expression
arcsin :: Expr -> Expr

-- | Smart constructor to apply arccos to an expression
arccos :: Expr -> Expr

-- | Smart constructor to apply arctan to an expression
arctan :: Expr -> Expr

-- | Smart constructor for the exponential (base e) function
exp :: Expr -> Expr

-- | Smart constructor to take the square root of an expression
sqrt :: Expr -> Expr
square :: Expr -> Expr

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares
euclidean :: [Expr] -> Expr

-- | Smart constructor for the dimension of a vector
dim :: Expr -> Expr

-- | Smart constructor for indexing
idx :: Expr -> Expr -> Expr

-- | Smart constructors for integers, doubles, strings
int :: Integer -> Expr
dbl :: Double -> Expr
str :: String -> Expr

-- | Smart constructor for set membership FIXME: first argument really
--   ought to be restricted to a <tt>variable</tt>, as IsIn should only be
--   used as a type proxy
isin :: Expr -> Space -> Expr

-- | Smart constructor for case statement (underscore as case is reserved)
case_ :: [(Expr, Relation)] -> Expr
sum_all :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integrals
defsum :: Symbol -> Expr -> Expr -> Expr -> Expr
prod_all :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integrals
defprod :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integrals
defint :: Symbol -> Expr -> Expr -> Expr -> Expr
int_all :: Symbol -> Expr -> Expr

-- | Smart constructor for 'real interval' membership
real_interval :: HasUID c => c -> RealInterval Expr Expr -> Expr
deriv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr
pderiv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr
sy :: (HasUID c, HasSymbol c) => c -> Expr
apply :: Expr -> [Expr] -> Expr
apply1 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> Expr
apply2 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> Expr

-- | Smart constructor to cross product two expressions
cross :: Expr -> Expr -> Expr
m2x2 :: Expr -> Expr -> Expr -> Expr -> Expr
vec2D :: Expr -> Expr -> Expr
dgnl2x2 :: Expr -> Expr -> Expr

-- | Special characters including partial derivatives, degree circle, and
--   underscores
data Special
Partial :: Special
Circle :: Special

-- | Class for rendering special characters
class RenderSpecial r
special :: RenderSpecial r => Special -> r
type UID = String

-- | The most basic item: having a unique key, here a UID
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use
uid :: HasUID c => Lens' c UID
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | For a "Reference Address", we just need a getter.
class HasRefAddress b
getRefAdd :: HasRefAddress b => b -> String

-- | A HasSymbol is anything which has a Symbol
class HasSymbol c

-- | Provides the Symbol -- for a particular stage of generation
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | Citations have Fields
class HasFields c
getFields :: HasFields c => Lens' c [CiteField]

-- | A NamedIdea is a <a>term</a> that we've identified (has an <a>id</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase)
term :: NamedIdea c => Lens' c NP
class HasAdditionalNotes c
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | HasSpace is anything which has a Space...
class HasSpace c
typ :: HasSpace c => Lens' c Space

-- | Some chunks store a unit symbol
class HasUnitSymbol u
usymb :: HasUnitSymbol u => u -> USymb
class HasReference c
getReferences :: HasReference c => Lens' c [Reference]

-- | A HasReasVal is a <a>Quantity</a> that could have a reasonable value
class HasReasVal c
reasVal :: HasReasVal c => Lens' c (Maybe Expr)
class HasDerivation c
derivations :: HasDerivation c => Lens' c Derivation

-- | An |Idea| is the <tt>meet</tt> of |NamedIdea| and |CommonIdea|. In
--   other words, it <i>may</i> have an acronym/abbreviation.
class NamedIdea c => Idea c
getA :: Idea c => c -> Maybe String
class Definition c

-- | defn provides (a <tt>Lens</tt> to) the definition for a chunk
defn :: Definition c => Lens' c Sentence
class ConceptDomain c

-- | cdom provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | Concepts are <a>Idea</a>s with definitions and domains
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | Units are Ideas with a Definition which store a unit symbol. They must
--   also be explicitly declared to be instances of IsUnit
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u
getUnits :: IsUnit u => u -> [UID]

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | A Constrained is a <a>Quantity</a> that has value constraints but do
--   not enforce Quantity at this point
class Constrained c
constraints :: Constrained c => Lens' c [Constraint]
class ExprRelat c
relat :: ExprRelat c => Lens' c Expr
class DefiningExpr c
defnExpr :: DefiningExpr c => Lens' c Expr

-- | An UncertainQuantity is just a Quantity with some uncertainty
--   associated to it. This uncertainty is represented as a decimal value
--   between 0 and 1 (percentage).
class HasUncertainty c
unc :: HasUncertainty c => Lens' c Uncertainty

-- | A Quantity is an <a>Idea</a> with a <a>Space</a> and a symbol. In
--   theory, it should also have MayHaveUnit, but that causes all sorts of
--   import cycles (or lots of orphans)
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | For projecting out to the ConceptChunk data-type
cw :: Concept c => c -> ConceptChunk

-- | The ConceptChunk datatype is a Concept
data ConceptChunk
data CommonConcept
data ConceptInstance
sDom :: [UID] -> UID

-- | The commonIdea smart constructor requires a chunk id, term (of type
--   <a>NP</a>), and abbreviation (as a string)
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | The common idea (with nounPhrase) data type. It must have a
--   <tt>NounPhrase</tt> for its <a>term</a>, and must have an
--   abbreviation.
data CI
getAcc :: CI -> Sentence
getAccStr :: CI -> String
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI
prependAbrv :: CommonIdea c => c -> String -> String

-- | Note that a |NamedChunk| does not have an acronym/abbreviation as
--   that's a |CommonIdea|, which has its own representation
data NamedChunk

-- | Get short form (if it exists), else get term.
short :: (Idea c, HasUID c) => c -> Sentence

-- | <a>NamedChunk</a> constructor, takes an uid and a term.
nc :: String -> NP -> NamedChunk

-- | |IdeaDict| is the canonical dictionary associated to |Idea| don't
--   export the record accessors
data IdeaDict
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | NamedIdea| exported |getA| (now in |Idea|). But there are no more
--   wrappers, instead we have explicit dictionaries.
nw :: Idea c => c -> IdeaDict
physc :: RealInterval Expr Expr -> Constraint
sfwrc :: RealInterval Expr Expr -> Constraint
enumc :: [Double] -> Constraint
isPhysC :: Constraint -> Bool
isSfwrC :: Constraint -> Bool
data Constraint
[Range] :: ConstraintReason -> RealInterval Expr Expr -> Constraint
[EnumeratedReal] :: ConstraintReason -> [Double] -> Constraint
[EnumeratedStr] :: ConstraintReason -> [String] -> Constraint
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | ConstrainedChunks are 'Symbolic Quantities' with <tt>Constraints</tt>
--   and maybe typical value
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [Constraint] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [Constraint]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | ConstrConcepts are 'Conceptual Symbolic Quantities' with
--   <tt>Constraints</tt> and maybe a reasonable value (and no unit!)
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [Constraint] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [Constraint]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a constrained unitary
cuc :: (IsUnit u) => String -> NP -> Symbol -> u -> Space -> [Constraint] -> Expr -> ConstrainedChunk

-- | Creates a constrained
cvc :: String -> NP -> Symbol -> Space -> [Constraint] -> Maybe Expr -> ConstrainedChunk
constrained' :: (Concept c, Quantity c, MayHaveUnit c) => c -> [Constraint] -> Expr -> ConstrConcept
cuc' :: (IsUnit u) => String -> NP -> String -> Symbol -> u -> Space -> [Constraint] -> Expr -> ConstrConcept

-- | For when the symbol changes depending on the stage
cuc'' :: String -> NP -> String -> (Stage -> Symbol) -> UnitDefn -> Space -> [Constraint] -> Expr -> ConstrConcept
constrainedNRV' :: (MayHaveUnit c, Concept c, Quantity c) => c -> [Constraint] -> ConstrConcept
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | A QDefinition is a <a>Quantity</a> with a defining expression, and a
--   definition
data QDefinition

-- | Create a <a>QDefinition</a> with a uid, noun phrase (term),
--   definition, symbol, unit, and defining equation. FIXME: Space hack
fromEqn :: (IsUnit u) => String -> NP -> Sentence -> Symbol -> u -> Expr -> QDefinition

-- | Same as fromEqn, but has no units. FIXME: Space hack
fromEqn' :: String -> NP -> Sentence -> Symbol -> Expr -> QDefinition

-- | For when the symbol changes depending on the stage FIXME: Space hack
fromEqnSt :: (IsUnit u) => String -> NP -> Sentence -> (Stage -> Symbol) -> u -> Expr -> QDefinition

-- | For when the symbol changes depending on the stage FIXME: Space hack
fromEqnSt' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Expr -> QDefinition
equat :: Lens' QDefinition Expr

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation. HACK - makes the definition EmptyS !!! FIXME
ec :: (Quantity c, MayHaveUnit c) => c -> Expr -> QDefinition
data QuantityDict
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Creates a Quantity from an uid, term, symbol, and space
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | implVar makes an variable that is implementation-only
implVar :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Smart constructor for creating concept chunks given an id,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as String).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Identical to <a>dcc</a>, but adds an abbreviation (String)
dcc' :: String -> NP -> String -> String -> CommonConcept

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a>
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a> and
--   adds an abbreviation (String)
dccWDS' :: String -> NP -> Sentence -> String -> CommonConcept

-- | Creates a QuantityDict from an <a>Idea</a>, symbol and space
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Constructor for <a>ConceptChunk</a>. Allows explicit tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | Constructor for <a>ConceptChunk</a>. Does not allow concept domain
--   tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as cc, except definition is a <a>Sentence</a>
cc' :: Idea c => c -> Sentence -> ConceptChunk
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | UncertQ is a chunk which is an instance of UncertainQuantity. It takes
--   a ConstrainedChunk and an Uncertainty.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | UncertQ is a chunk which is an instance of UncertainQuantity. It takes
--   a ConstrConcept and an Uncertainty.
data UncertQ

-- | The UncertainQuantity constructor. Requires a Quantity, a percentage,
--   and a typical value
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ
uqc :: (IsUnit u) => String -> NP -> String -> Symbol -> u -> Space -> [Constraint] -> Expr -> Uncertainty -> UncertQ
uqcND :: (IsUnit u) => String -> NP -> Symbol -> u -> Space -> [Constraint] -> Expr -> Uncertainty -> UncertQ
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain varchunk
uvc :: String -> NP -> Symbol -> Space -> [Constraint] -> Expr -> Uncertainty -> UncertainChunk

-- | projection
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk

-- | UnitalChunks are Unitary DefinedQuantityDict
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Create a UnitalChunk in the same way as <a>uc'</a>, but with a
--   <a>Sentence</a> for the definition instead of a String
makeUCWDS :: (IsUnit u) => String -> NP -> Sentence -> Symbol -> u -> UnitalChunk

-- | Used to create a UnitalChunk from a <a>Concept</a>, <a>Symbol</a>, and
--   <tt>Unit</tt>. Assumes the <a>Space</a> is Real
uc :: (Concept c, IsUnit u) => c -> Symbol -> u -> UnitalChunk

-- | Same as <a>uc</a>, except it builds the Concept portion of the
--   UnitalChunk from a given uid, term, and defn. Those are the first
--   three arguments
uc' :: (IsUnit u) => String -> NP -> String -> Symbol -> u -> UnitalChunk

-- | Same as <a>uc'</a>, but does not assume the <a>Space</a>
ucs :: (IsUnit u) => String -> NP -> String -> Symbol -> Space -> u -> UnitalChunk
ucs' :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | For when the symbol changes depending on the stage
ucs'' :: String -> NP -> String -> (Stage -> Symbol) -> Space -> UnitDefn -> UnitalChunk
ucsWS :: (IsUnit u) => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are <a>Unitary</a>s with <tt>Symbols</tt>
data UnitaryChunk
unitary :: (IsUnit u) => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | For when the symbol changes depending on the stage
unitary' :: (IsUnit u) => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Helper for getting the unit's symbol from a chunk, as opposed to the
--   symbols of the chunk itself.
unit_symb :: (Unitary c) => c -> USymb
data RelationConcept

-- | Create a RelationConcept from a given id, term, defn, and relation.
makeRC :: String -> NP -> Sentence -> Relation -> RelationConcept
dqd :: (IsUnit u) => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | DefinedQuantity = Concept + Quantity
data DefinedQuantityDict
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitaryConceptDict
data UnitaryConceptDict
type Derivation = [Sentence]
data ShortName
shortname' :: String -> ShortName
getStringSN :: ShortName -> String

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the UID part as an EntryID (String) used for creating
--   reference links. Finally we will have the reference information (type
--   and fields).
data Citation
type EntryID = String
type BibRef = [Citation]
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk i.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk i.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk i.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk i.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk i. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk i. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise ientical to <a>cInBookACP</a>
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise ientical to <a>cInBookECP</a>
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise ientical to <a>cInBookACP</a>
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise ientical to <a>cInBookECP</a>
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk i.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk i.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk i.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk i.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk i.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk i.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk i.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk i.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk i.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation

-- | Some documents, as well as some pieces of knowledge, have citations
class HasCitation c
getCitations :: HasCitation c => Lens' c [Citation]
data Sentence
[Ch] :: SentenceStyle -> UID -> Sentence
[Sy] :: USymb -> Sentence
[S] :: String -> Sentence
[P] :: Symbol -> Sentence
[E] :: Expr -> Sentence
[Ref] :: Reference -> Sentence
[Quote] :: Sentence -> Sentence
[Percent] :: Sentence
[:+:] :: Sentence -> Sentence -> Sentence
[EmptyS] :: Sentence

-- | Helper for wrapping sentences in parentheses.
sParen :: Sentence -> Sentence

-- | Helper for concatenating two sentences with a space-surrounded dash
--   between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two sentences with a space between them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> then adds a
--   period to the end.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two sentences with a comma and space between
--   them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> then adds a
--   colon to the end.
(+:) :: Sentence -> Sentence -> Sentence
ch :: (HasUID c, HasSymbol c) => c -> Sentence

-- | For writing "sentences" via combining smaller elements Sentences are
--   made up of some known vocabulary of things: - units (their visual
--   representation) - words (via String) - special characters - accented
--   letters - References to specific layout objects
data SentenceStyle
ShortStyle :: SentenceStyle
SymbolStyle :: SentenceStyle
TermStyle :: SentenceStyle
PluralTerm :: SentenceStyle
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]
data Reference
Reference :: UID -> LblType -> ShortName -> RefInfo -> Reference
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo
class NounPhrase n
phraseNP :: NounPhrase n => n -> Sentence
pluralNP :: NounPhrase n => n -> PluralForm
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization
data NP

-- | Self plural
--   
--   Construct a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons)
--   
--   Construct a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e"
--   
--   Construct a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes)
--   
--   Construct a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Construct a Proper Noun. Meant for use with IrregPlur from
--   <a>PluralRule</a>. First argument is the String representing the noun,
--   second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Self plural
--   
--   Construct a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs)
--   
--   Construct a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae)
--   
--   Construct a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes)
--   
--   Construct a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Common noun that allows you to specify the pluralization rule (as in
--   <a>pnIrr</a>)
cnIP :: String -> PluralRule -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence)
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Common noun that pluralizes by dropping the last letter and adding an
--   "ies" | ending (ex. body -&gt; bodies)
cnIES :: String -> NP

-- | Common noun that pluralizes by dropping the last two letters and
--   adding an | "ices" ending (ex. matrix -&gt; matrices)
cnICES :: String -> NP

-- | Common noun that pluralizes by dropping the last two letters and
--   adding "es" (ex. analysis -&gt; analyses)
cnIS :: String -> NP

-- | Common noun that pluralizes by dropping the last two letters and
--   adding "a" (ex. datum -&gt; data)
cnUM :: String -> NP

-- | Noun phrase with a given singular and plural form that capitalizes the
--   first letter of the first word for sentence case
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but following a given capitalization
--   rule for sentence case
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given Sentence. Used for custom
--   capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
at_startNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
at_startNP' :: NounPhrase n => n -> Capitalization

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by phrase of t2. The plural becomes phrase of t1
--   followed by plural of t2. Uses standard CapFirst sentence case and
--   CapWords title case. For example: <tt>compoundPhrase system
--   constraint</tt> will have singular form "system constraint" and plural
--   "system constraints"
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but where the sentence case is the
--   same as the title case (CapWords).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to 'compoundPhrase\'', but which accepts functions to be used
--   for constructing the plural form. For example <tt>compoundPhrase''
--   plural phrase system constraint</tt> would have the plural form
--   "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP
compoundPhraseP1 :: NP -> NP -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Custom noun phrase constructor that takes a singular form, plural
--   form, sentence case capitalization rule, and title case capitalization
--   rule
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized. Works like
--   <a>nounPhrase</a>, but with only the first argument
nounPhraseSP :: String -> NP

-- | For Reuirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing.
nounPhraseSent :: Sentence -> NP
class HasUID s => Referable s
refAdd :: Referable s => s -> String
renderRef :: Referable s => s -> LblType

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and Sections which hold the contents of the document
data Document
Document :: Title -> Author -> [Section] -> Document

-- | Types of definitions
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Sections have a title (<a>Sentence</a>) and a list of contents
--   (<a>SecCons</a>) and its shortname
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>)
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons
data ListType

-- | Bulleted list
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated List
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>-</tt>
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "Title: Item" (see <a>ListTuple</a>)
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt>Title</tt> is the <tt>Item</tt>"
Definitions :: [ListTuple] -> ListType
data ItemType

-- | Standard singular item
Flat :: Sentence -> ItemType

-- | Nest a list as an item
Nested :: Header -> ListType -> ItemType
type ListTuple = (Title, ItemType, Maybe String)  Title: Item
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent
extractSection :: Document -> [Section]
mkParagraph :: Sentence -> Contents
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Smart constructor for labelled content chunks
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor for creating Sections with introductory contents
--   (ie. paragraphs, tables, etc.) and a list of subsections.
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | Figure smart constructor. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | Figure smart constructor for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as pagewidth*MaxWidthPercent/100.
type MaxWidthPercent = Float
class HasContents c
accessContents :: HasContents c => Lens' c RawContent

-- | Types of layout objects we deal with explicitly
data RawContent

-- | table has: header-row data(rows) label/caption showlabel?
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent
EqnBlock :: Expr -> RawContent

-- | Lists
Enumeration :: ListType -> RawContent
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent
Bib :: BibRef -> RawContent

-- | TODO: Fill this one in.
Graph :: [(Sentence, Sentence)] -> (Maybe Width) -> (Maybe Height) -> Lbl -> RawContent
mkFig :: Reference -> RawContent -> Contents
makeTabRef :: String -> Reference
makeFigRef :: String -> Reference
makeSecRef :: String -> String -> Reference
makeLstRef :: String -> String -> Reference

-- | Create a reference for a URI
makeURI :: UID -> String -> ShortName -> Reference

-- | Spaces
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Radians :: Space
Vect :: Space -> Space
DiscreteI :: [Int] -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space

-- | RealInterval. A |RealInterval| is a subset of |Real| (as a |Space|).
--   These come in different flavours. For now, embed |Expr| for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
data DomainDesc a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc a b
[AllDD] :: Symbol -> RTopology -> DomainDesc a b

-- | Decorations on symbols/characters such as hats or Vector
--   representations (bolding/etc)
data Decoration
Hat :: Decoration
Vector :: Decoration
Prime :: Decoration

-- | Symbols can be: - atomic (strings such as <a>A</a> or "max" that
--   represent a single idea) - special characters (ex. unicode) -
--   Decorated symbols - Concatenations of symbols, including subscripts
--   and superscripts - empty! (this is to give this a monoid-like flavour)
data Symbol
Atomic :: String -> Symbol
Special :: Special -> Symbol
Atop :: Decoration -> Symbol -> Symbol
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol
Concat :: [Symbol] -> Symbol
Empty :: Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol
compsy :: Symbol -> Symbol -> Ordering

-- | Helper for creating a symbol that depends on the stage
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person
class HasName p
name :: (HasName n) => n -> String

-- | Used for rendering lists of names (one or more).
manyNames :: (HasName p) => [p] -> String

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the 'person\'' constructor, except the middle argument is a list of
--   middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person
nameStr :: HasName p => p -> String
rendPersLFM :: Person -> String
rendPersLFM' :: Person -> String
rendPersLFM'' :: Person -> String
comparePeople :: [Person] -> [Person] -> Ordering

-- | Stages correspond to what we're trying to look up. They range from
--   abstract to concrete.
data Stage
Equational :: Stage
Implementation :: Stage

-- | Helper function for getting a symbol in the Equational Stage
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage
codeSymb :: HasSymbol q => q -> Symbol

-- | Is a Stage symbol real or Empty?
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool
makeRef2S :: (Referable l, HasShortName l) => l -> Sentence
makeCite :: Citation -> Reference
makeCiteS :: Citation -> Sentence
makeRef2 :: (Referable l, HasShortName l) => l -> Reference
makeCiteInfo :: Citation -> RefInfo -> Reference
makeCiteInfoS :: Citation -> RefInfo -> Sentence
getAdd :: LblType -> String
prepend :: String -> IRefProg

-- | Trying different pieces of information for a reference An RP is a
--   decorated internal reference Citation is a citation URI is for URLs
--   and other external links
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType
data IRefProg
Deferred :: UID -> IRefProg
RS :: String -> IRefProg
RConcat :: IRefProg -> IRefProg -> IRefProg
Name :: IRefProg

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Helper for getting the phrase from a NamedIdea.
phrase :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Helper for getting the plural of a phrase from a NamedIdea
plural :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Singular possesive function
phrase's :: NamedIdea n => n -> Sentence

-- | Plural possesive function
plural's :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   NamedIdea.
at_start :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   NamedIdea.
at_start' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   NamedIdea.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   NamedIdea.
titleize' :: NamedIdea n => n -> Sentence
data Uncertainty
uncty :: Double -> Maybe Int -> Uncertainty
defaultUncrt :: Uncertainty
uncVal :: HasUncertainty x => x -> Double
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Language of units (how to build them up) UName for the base cases,
--   otherwise build up. Probably a 7-vector would be better (less
--   error-prone!) | Language of unit equations, to define a unit relative
--   to another
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Month abbreviations
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How Published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex)
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor
author :: People -> CiteField

-- | Smart field constructor
editor :: People -> CiteField

-- | Smart field constructor
address :: String -> CiteField

-- | Smart field constructor
bookTitle :: String -> CiteField

-- | Smart field constructor
howPublished :: String -> CiteField

-- | Smart field constructor
howPublishedU :: String -> CiteField

-- | Smart field constructor
institution :: String -> CiteField

-- | Smart field constructor
journal :: String -> CiteField

-- | Smart field constructor
note :: String -> CiteField

-- | Smart field constructor
organization :: String -> CiteField

-- | Smart field constructor
publisher :: String -> CiteField

-- | Smart field constructor
school :: String -> CiteField

-- | Smart field constructor
series :: String -> CiteField

-- | Smart field constructor
title :: String -> CiteField

-- | Smart field constructor
typeField :: String -> CiteField

-- | Smart field constructor
chapter :: Int -> CiteField

-- | Smart field constructor
edition :: Int -> CiteField

-- | Smart field constructor
number :: Int -> CiteField

-- | Smart field constructor
volume :: Int -> CiteField

-- | Smart field constructor
year :: Int -> CiteField

-- | Smart field constructor
pages :: [Int] -> CiteField

-- | Smart field constructor
month :: Month -> CiteField

-- | for defining units It is a concept chunk (defined what kind of unit it
--   is), has a unit symbol, maybe another (when it is a synonym), perhaps
--   a definition, and the list of UID of the units that make up the
--   definition.
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Can generate a default symbol
from_udefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   string for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
new_unit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term
--   
--   | Create a derived unit chunk from an id, term (as <a>String</a>),
--   definition, symbol, and unit equation
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding *s* to the end
--   
--   | Create a derived unit chunk from an id, term (as <a>String</a>),
--   definition, symbol, and unit equation
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from an id, term (as noun phrase),
--   definition, symbol, and unit equation
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit
fund :: String -> String -> String -> UnitDefn

-- | Variant of the above, useful for degree
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them
comp_unitdefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a SI_Unit with two symbol representations
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a SI_Unit with two symbol representations
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix the two, thus forgetting the definition part
unitWrapper :: (IsUnit u) => u -> UnitDefn
getCu :: UnitEquation -> [UID]
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

module Language.Drasil.Utils
sortBySymbol :: (HasSymbol a) => [a] -> [a]
sortBySymbolTuple :: (HasSymbol a) => [(a, b)] -> [(a, b)]
