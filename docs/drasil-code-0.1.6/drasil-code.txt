-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Code SubPackage
--   
--   A framework for code and document generation for scientific software -
--   Code SubPackage
@package drasil-code
@version 0.1.6


-- | re-export smart constructors for external code writing
module Language.Drasil.Code
type Body = [Block]
data Class

-- | Int parameter for StateVar is a measure of "delete priority" (for
--   languages with explicit destructors). 0=never delete, 4=always,
--   1-3=language-defined. This allows the programmer to specify a
--   different set of variables to delete explicitly for different
--   languages.
data StateVar
data Value
data Parameter
data Module
type FunctionDecl = Method
type Label = String
data StateType
type Library = Label
data Statement
bool :: StateType
int :: StateType
float :: StateType
char :: StateType
string :: StateType
infile :: StateType
outfile :: StateType
listT :: StateType -> StateType
obj :: Label -> StateType
arg :: Int -> Value
self :: Value
methodType :: StateType -> MethodType
methodTypeVoid :: MethodType
block :: [Statement] -> Block
defaultValue :: BaseType -> Value
true :: Value
false :: Value
pubClass :: Label -> Maybe Label -> [StateVar] -> [Method] -> Class
privClass :: Label -> Maybe Label -> [StateVar] -> [Method] -> Class
privMVar :: Int -> StateType -> Label -> StateVar
pubMVar :: Int -> StateType -> Label -> StateVar
pubGVar :: Int -> StateType -> Label -> StateVar
privMethod :: MethodType -> Label -> [Parameter] -> Body -> Method
pubMethod :: MethodType -> Label -> [Parameter] -> Body -> Method
constructor :: Label -> [Parameter] -> Body -> Method
mainMethod :: Body -> Method
(?!) :: Value -> Value
infixr 6 ?!
(?<) :: Value -> Value -> Value
infixl 4 ?<
(?<=) :: Value -> Value -> Value
infixl 4 ?<=
(?>) :: Value -> Value -> Value
infixl 4 ?>
(?>=) :: Value -> Value -> Value
infixl 4 ?>=
(?==) :: Value -> Value -> Value
infixl 3 ?==
(?!=) :: Value -> Value -> Value
infixl 3 ?!=
(?&&) :: Value -> Value -> Value
infixl 2 ?&&
(?||) :: Value -> Value -> Value
infixl 1 ?||
(#~) :: Value -> Value
infixl 8 #~
(#/^) :: Value -> Value
infixl 7 #/^
(#|) :: Value -> Value
infixl 7 #|
(#+) :: Value -> Value -> Value
infixl 5 #+
(#-) :: Value -> Value -> Value
infixl 5 #-
(#*) :: Value -> Value -> Value
infixl 6 #*
(#/) :: Value -> Value -> Value
infixl 6 #/
(#%) :: Value -> Value -> Value
infixl 6 #%
(#^) :: Value -> Value -> Value
infixl 7 #^
(&=) :: Value -> Value -> Statement
infixr 1 &=
(&.=) :: Label -> Value -> Statement
infixr 1 &.=
(&=.) :: Value -> Label -> Statement
infixr 1 &=.
(&+=) :: Value -> Value -> Statement
infixl 1 &+=
(&-=) :: Value -> Value -> Statement
infixl 1 &-=
(&++) :: Value -> Statement
infixl 8 &++
(&~-) :: Value -> Statement
infixl 8 &~-
(&.+=) :: Label -> Value -> Statement
infixl 1 &.+=
(&.-=) :: Label -> Value -> Statement
infixl 1 &.-=
(&.++) :: Label -> Statement
infixl 8 &.++
(&.~-) :: Label -> Statement
infixl 8 &.~-
($->) :: Value -> Value -> Value
infixl 9 $->
($.) :: Value -> Function -> Value
infixl 9 $.
($:) :: Label -> Label -> Value
infixl 9 $:
log :: Value -> Value
exp :: Value -> Value
alwaysDel :: Int
neverDel :: Int
assign :: Value -> Value -> Statement
at :: Label -> Function
binExpr :: Value -> BinaryOp -> Value -> Value
break :: Statement
cast :: StateType -> StateType -> Function
constDecDef :: Label -> Literal -> Statement
extends :: Label -> Maybe Label
for :: Statement -> Value -> Statement -> Body -> Statement
forEach :: Label -> Value -> Body -> Statement
ifCond :: [(Value, Body)] -> Body -> Statement
ifExists :: Value -> Body -> Body -> Statement
listDec :: Permanence -> Label -> StateType -> Int -> Statement
listDec' :: Label -> StateType -> Int -> Statement
listDecValues :: Label -> StateType -> [Value] -> Statement
listOf :: Label -> StateType -> Value
litBool :: Bool -> Value
litChar :: Char -> Value
litFloat :: Double -> Value
litInt :: Integer -> Value
litObj :: Library -> StateType -> [Value] -> Value
litObj' :: StateType -> [Value] -> Value
litString :: Label -> Value
noElse :: Body
noParent :: Maybe a
objDecDef :: Label -> StateType -> Value -> Statement
oneLiner :: Statement -> Body
param :: Label -> StateType -> Parameter
params :: [(Label, StateType)] -> [Parameter]
paramToVar :: Parameter -> Value
print :: StateType -> Value -> Statement
printLn :: StateType -> Value -> Statement
printStr :: String -> Statement
printStrLn :: String -> Statement
printFile :: Value -> StateType -> Value -> Statement
printFileLn :: Value -> StateType -> Value -> Statement
printFileStr :: Value -> String -> Statement
openFileR :: Value -> Value -> Statement
openFileW :: Value -> Value -> Statement
closeFile :: Value -> Statement
getInput :: StateType -> Value -> Statement
getFileInput :: Value -> StateType -> Value -> Statement
getFileInputAll :: Value -> Value -> Statement
getFileInputLine :: Value -> Value -> Statement
printFileStrLn :: Value -> String -> Statement
return :: Value -> Statement
returnVar :: Label -> Statement
switch :: Value -> [(Literal, Body)] -> Body -> Statement
throw :: String -> Statement
tryCatch :: Body -> Body -> Statement
typ :: StateType -> MethodType
varDec :: Label -> StateType -> Statement
varDecDef :: Label -> StateType -> Value -> Statement
while :: Value -> Body -> Statement
zipBlockWith :: (a -> b -> Statement) -> [a] -> [b] -> Block
zipBlockWith4 :: (a -> b -> c -> d -> Statement) -> [a] -> [b] -> [c] -> [d] -> Block
addComments :: Label -> [Block] -> [Block]
comment :: Label -> Statement
commentDelimit :: Label -> Statement
endCommentDelimit :: Label -> Statement
prefixFirstBlock :: Statement -> [Block] -> [Block]
getterName :: String -> String
setterName :: String -> String
convertToClass :: Class -> Class
convertToMethod :: Method -> Method

-- | Takes a "find" Value (old), a "replace" Value (new), and performs a
--   find-and-replace with these Values on the specified Body.
bodyReplace :: Value -> Value -> Body -> Body
funcReplace :: Value -> Value -> Function -> Function
valListReplace :: Value -> Value -> [Value] -> [Value]
objDecNew :: Label -> Library -> StateType -> [Value] -> Statement
objDecNewVoid :: Label -> Library -> StateType -> Statement
objDecNew' :: Label -> StateType -> [Value] -> Statement
objDecNewVoid' :: Label -> StateType -> Statement
listSize :: Function
listAccess :: Value -> Function
listAppend :: Value -> Function
listSlice :: StateType -> Value -> Value -> Maybe Value -> Maybe Value -> Maybe Value -> Statement
stringSplit :: Value -> Value -> Char -> Statement
var :: Label -> Value
svToVar :: StateVar -> Value
objMethodCall :: Value -> Label -> [Value] -> Value
objMethodCallVoid :: Value -> Label -> Value
valStmt :: Value -> Statement
funcApp :: Library -> Label -> [Value] -> Value
funcApp' :: Label -> [Value] -> Value
func :: Label -> [Value] -> Function
continue :: Statement
cSharpLabel :: String
cppLabel :: String
goolLabel :: String
javaLabel :: String
objectiveCLabel :: String
pythonLabel :: String
luaLabel :: String

-- | Translates an AbstractCode to Code using the language of the passed
--   Config
makeCode :: Config -> AbstractCode -> Code

-- | Creates the requested <a>Code</a> by producing files
createCodeFiles :: Code -> IO ()
toAbsCode :: Label -> [Module] -> AbstractCode
getClassName :: Class -> Label
buildModule :: Label -> [Library] -> [VarDecl] -> [FunctionDecl] -> [Class] -> Module
moduleName :: Module -> Label
data Options
Options :: Maybe String -> Maybe String -> Maybe String -> Maybe String -> Options
[javalist] :: Options -> Maybe String
[cpplist] :: Options -> Maybe String
[objcstaticlist] :: Options -> Maybe String
[hsModule] :: Options -> Maybe String
generator :: Choices -> CodeSpec -> State
generateCode :: Choices -> State -> IO ()
($:=) :: (Quantity c, MayHaveUnit c) => c -> Expr -> FuncStmt
data Choices
Choices :: [Lang] -> ImplementationType -> String -> Logging -> Comments -> ConstraintBehaviour -> ConstraintBehaviour -> Structure -> Choices
[lang] :: Choices -> [Lang]
[impType] :: Choices -> ImplementationType
[logFile] :: Choices -> String
[logging] :: Choices -> Logging
[comments] :: Choices -> Comments
[onSfwrConstraint] :: Choices -> ConstraintBehaviour
[onPhysConstraint] :: Choices -> ConstraintBehaviour
[inputStructure] :: Choices -> Structure
data CodeSpec
data Comments
CommentNone :: Comments
data ConstraintBehaviour
Warning :: ConstraintBehaviour
Exception :: ConstraintBehaviour
data Func
data FuncStmt
[FAsg] :: CodeChunk -> Expr -> FuncStmt
[FFor] :: CodeChunk -> Expr -> [FuncStmt] -> FuncStmt
[FWhile] :: Expr -> [FuncStmt] -> FuncStmt
[FCond] :: Expr -> [FuncStmt] -> [FuncStmt] -> FuncStmt
[FRet] :: Expr -> FuncStmt
[FThrow] :: String -> FuncStmt
[FTry] :: [FuncStmt] -> [FuncStmt] -> FuncStmt
[FContinue] :: FuncStmt
[FDec] :: CodeChunk -> CodeType -> FuncStmt
[FProcCall] :: Func -> [Expr] -> FuncStmt
[FAppend] :: Expr -> Expr -> FuncStmt
data ImplementationType
Library :: ImplementationType
Program :: ImplementationType
data Lang
Cpp :: Lang
CSharp :: Lang
Java :: Lang
Python :: Lang
data Logging
LogNone :: Logging
data Mod
Mod :: Name -> [Func] -> Mod
data Structure
Loose :: Structure
AsClass :: Structure
asExpr :: Func -> Expr
asExpr' :: Func -> Expr
asVC :: Func -> QuantityDict
asVC' :: Func -> QuantityDict
codeSpec :: SystemInformation -> [Mod] -> CodeSpec
fdec :: (Quantity c, MayHaveUnit c) => c -> FuncStmt
ffor :: (Quantity c, MayHaveUnit c) => c -> Expr -> [FuncStmt] -> FuncStmt
funcData :: Name -> DataDesc -> Func
funcDef :: (Quantity c, MayHaveUnit c) => Name -> [c] -> Space -> [FuncStmt] -> Func
packmod :: Name -> [Func] -> Mod
relToQD :: ExprRelat c => ChunkDB -> c -> QDefinition
data Ind
Explicit :: Integer -> Ind
WithPattern :: Ind
WithLine :: Ind
junk :: Entry
junkLine :: Data
listEntry :: (Quantity c, MayHaveUnit c) => [Ind] -> c -> Entry
multiLine :: LinePattern -> Delim -> Data
repeated :: [Entry] -> LinePattern
singleLine :: LinePattern -> Delim -> Data
singleton :: (Quantity c, MayHaveUnit c) => c -> Data
