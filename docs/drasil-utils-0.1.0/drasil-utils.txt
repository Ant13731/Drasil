-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Utils SubPackage
--   
--   A framework for code and document generation for scientific software -
--   Utils SubPackage
@package drasil-utils
@version 0.1.0

module Utils.Drasil
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType
data WrapType
Parens :: WrapType
Period :: WrapType
data SepType
Comma :: SepType
SemiCol :: SepType
data FoldType
List :: FoldType
Options :: FoldType

-- | helper for formatting constraints
foldConstraints :: (Quantity c) => c -> [Constraint] -> Sentence

-- | creates an list of elements with "enumerators" in "wrappers" using
--   foldlList
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | creates a list of elements separated by a "separator", ending with
--   "and" or "or"
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | fold sentences then turns into content
foldlSP :: [Sentence] -> Contents
foldlSP_ :: [Sentence] -> Contents
foldlSPCol :: [Sentence] -> Contents

-- | partial function application of foldle for sentences specifically
foldlSent :: [Sentence] -> Sentence

-- | foldlSent but does not end with period
foldlSent_ :: [Sentence] -> Sentence

-- | foldlSent but ends with colon
foldlSentCol :: [Sentence] -> Sentence

-- | creates a list of elements separated by commas, including the last
--   element
foldlsC :: [Sentence] -> Sentence

-- | outputs sentence with % attached to it
addPercent :: Show a => a -> Sentence

-- | bulletFlat applies Bullet and Flat to a list.
bulletFlat :: [Sentence] -> ListType

-- | bulletNested applies Bullets and headers to a Nested ListType. t -
--   Headers of the Nested lists. l - Lists of ListType.
bulletNested :: [Sentence] -> [ListType] -> ListType
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence
displayConstrntsAsSet :: Quantity a => a -> [String] -> Sentence

-- | enumBullet apply Enumeration, Bullet and Flat to a list
enumBullet :: Reference -> [Sentence] -> LabelledContent
enumBulletU :: [Sentence] -> Contents

-- | enumSimple enumerates a list and applies simple and enumeration to it
--   s - start index for the enumeration t - title of the list l - list to
--   be enumerated
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents
eqN :: Int -> Sentence
eqUnR :: Expr -> Reference -> LabelledContent
eqUnR' :: Expr -> Contents

-- | takes a amount and adds a unit to it n - sentenc representing an
--   amount u - unit we want to attach to amount
fmtU :: (MayHaveUnit a) => Sentence -> a -> Sentence
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in..."
getTandS :: (Quantity a) => a -> Sentence

-- | makes sentences from an item and its reference a - String title of
--   reference b - Sentence containing the full reference
itemRefToSent :: String -> Sentence -> Sentence

-- | makeListRef takes a list and a reference and generates references to
--   match the length of the list l - list whos length is to be matched
makeListRef :: [a] -> Section -> [Sentence]

-- | makes a traceability matrix from list of row title, list of rows of
--   "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]
maybeChanged :: Sentence -> Sentence -> Sentence
maybeExpanded :: Sentence -> Sentence -> Sentence
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | zip helper function enumerates abbreviation and zips it with list of
--   itemtype s - the number from which the enumeration should start from t
--   - the title of the list l - the list to be enumerated
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | noRefs converts lists of simple ItemTypes into a lists which may be
--   used in Contents but not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | noRefsLT converts lists of tuples containing a title and ItemType into
--   a ListTuple which can be used with Contents but not directly
--   referable.
noRefsLT :: [(Sentence, ItemType)] -> [ListTuple]

-- | Create a list in the pattern of "The <b> are refined to the </b>".
--   Note: Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence
sortBySymbol :: HasSymbol a => [a] -> [a]
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]
tAndDOnly :: Concept s => s -> ItemType

-- | helpful combinators for making Sentences for Terminologies with
--   Definitions term (acc) - definition
tAndDWAcc :: Concept s => s -> ItemType
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | extracts the typical uncertainty to be displayed from something that
--   has an uncertainty
typUncr :: HasUncertainty c => c -> Sentence
underConsidertn :: ConceptChunk -> Sentence

-- | get a unit symbol if there is one
unwrap :: Maybe UnitDefn -> Sentence

-- | interweaves two lists together [[a,b,c],[d,e,f]] -&gt; [a,d,b,e,c,f]
weave :: [[a]] -> [a]

-- | appends a sentence to the front of a list of list of sentences
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | Creates an NP by combining two <a>NamedIdea</a>s with the word "and"
--   between their terms. Plural is defaulted to <tt>(phrase t1) "of"
--   (plural t2)</tt>
and_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>and_</a> combinator, except phrase default of second term
--   is plural instead of phrase
and_' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Customizable <a>and</a> combinator
andRT :: (NamedIdea c, NamedIdea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Combinator for combining two <a>NamedChunk</a>s into one. <i>Does not
--   preserve abbreviations</i>
compoundNC :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk
compoundNC' :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk
compoundNC'' :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> (NP -> Sentence) -> a -> b -> NamedChunk
compoundNC''' :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> a -> b -> NamedChunk
compoundNCP1 :: NamedChunk -> NamedChunk -> NamedChunk
compoundNCPlPh :: NamedChunk -> NamedChunk -> NamedChunk
compoundNCPlPl :: NamedChunk -> NamedChunk -> NamedChunk

-- | Inserts the word "for" between the titleized versions of two terms
for :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <a>for</a>, but uses titleized version of term 1 with the
--   abbreviation (if it exists, phrase otherwise) for term 2
for' :: (NamedIdea c, Idea d) => c -> d -> Sentence

-- | Similar to <a>for</a>, but allows one to specify the function to use
--   on each term before inserting for. For example one could use <tt>for''
--   phrase plural t1 t2</tt>
for'' :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> Sentence

-- | Creates a noun phrase by combining two <a>NamedIdea</a>s with the word
--   "of" between their terms. Plural is defaulted to <tt>(phrase t1) "of"
--   (plural t2)</tt>
of_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a noun phrase by combining two <a>NamedIdea</a>s with the word
--   "of" between them. <a>phrase</a> is defaulted to <tt>(phrase t1) "of"
--   (plural t2)</tt>. Plural is the same.
of_' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as of_, except plural default of second term is phrase
of_'' :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as of_, except phrase default of first term is plural instead of
--   phrase
of__ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as of__, except combining Sentence piece is "of a"
ofA :: (NamedIdea c, NamedIdea d) => c -> d -> NP
ofN_ :: (NamedIdea c, NounPhrase d) => c -> d -> NP
the :: (NamedIdea t) => t -> NP
the' :: (NamedIdea t) => t -> NP
theCustom :: (t -> Sentence) -> t -> NP
with :: (NamedIdea c, NamedIdea d) => c -> d -> NP
andIts :: Sentence -> Sentence -> Sentence
andThe :: Sentence -> Sentence -> Sentence
isExpctdToHv :: Sentence -> Sentence -> Sentence
isThe :: Sentence -> Sentence -> Sentence
ofGiv :: Sentence -> Sentence -> Sentence
ofGiv' :: Sentence -> Sentence -> Sentence
ofThe :: Sentence -> Sentence -> Sentence
ofThe' :: Sentence -> Sentence -> Sentence
sOf :: Sentence -> Sentence -> Sentence
sOr :: Sentence -> Sentence -> Sentence
sVersus :: Sentence -> Sentence -> Sentence
sAnd :: Sentence -> Sentence -> Sentence
sAre :: Sentence -> Sentence -> Sentence
sIn :: Sentence -> Sentence -> Sentence
sIs :: Sentence -> Sentence -> Sentence
toThe :: Sentence -> Sentence -> Sentence
